
### download1.pdf — Introduction to addEventListener

Introduction to addEventListener

addEventListener is a method in JavaScript that allows developers to attach event handlers or functions to HTML elements. It's a fundamental mechanism for managing events in web development.

How to Use addEventListener?

The general syntax for addEventListener is:

element.addEventListener(eventType, handlerFunction)

· element: Refers to the HTML element to which you want to attach the event listener.

· event type: Specifies the type of event to listen for (for example: 'click', 'change', 'mouseover', and so on).

· handlerFunction: JSON stores configuration settings, application states, and structured data in databases or files due to its simplicity and ease of use.

In comparing event handling methods, you examine scenarios with and without the use of addEventListener.

1. Without addEventListener

// <button id="myButton" onclick="handleButtonClick()">Click me</button>
<script>
function handleButtonClick() {
  console.log('Button clicked!');
}
</script>

In the absence of addEventListener, the HTML embeds an onclick attribute within the button element, triggering the specified function (handleButtonClick()) upon clicking.

2. With addEventListener

// <button id="myButton">Click me</button>
<script>
// Get the button element
const button = document.getElementById('myButton');
// Add event listener for 'click' event
button.addEventListener('click', handleButtonClick);
// Function to handle button click
function handleButtonClick() {
  console.log('Button clicked!');
}
</script>

· Select the button element with getElementById.

· Add an event listener for the 'click' event to the button using addEventListener.

· Assign the handleButtonClick function as the event handler to execute when the user clicks the button.

This configuration replicates the previous functionality but employs addEventListener instead of the inline onclick attribute to bind the event handler.

Using addEventListener brings several benefits

· Readability and maintainability: Decoupling JavaScript from HTML enhances code comprehension and maintenance.

· Scalability: As your codebase expands, managing event listeners becomes more straightforward. addEventListener enables easy addition or modification of listeners without HTML changes.

· Code reusability: Assigning named functions (for example: handleButtonClick) as event handlers fosters reusable code applicable across various elements or events.

· Consistency and best practices: Leveraging addEventListener aligns with modern JavaScript practices, promoting clean code separation and adhering to unobtrusive JavaScript principles.

· Multiple event handlers: A single element can host multiple event handlers for the same event, providing flexibility in managing diverse functionalities triggered by one event.

Events

JavaScript events represent user-initiated actions in a web browser, such as mouse and keyboard actions and form or window events, enabling dynamic and interactive web experiences.

1. Mouse events

Mouse events in JavaScript pertain to interactions with the mouse pointer in a web document, including clicks, movements over elements, entering/exiting areas, and dragging elements. Examples include 'click' (mouse button press and release), 'mouseover' (mouse enters an element), 'mouseout' (mouse leaves an element), and 'mousemove' (mouse moves within an element).

1.1 Click event

The click event triggers when a mouse button is pressed and released on an element, indicating a user interaction. In the example, a button with the ID 'clickButton' has a click event listener attached. When clicked, an alert with 'Button clicked!' appears.

// <button id="clickButton">Click Me !</button>
<script>
document.getElementById('clickButton').addEventListener('click', function() {
  alert('Button clicked!');
});
</script>

Code explanation: creates an HTML button and uses JavaScript to add a click event listener. When the user clicks the button, it activates an alert that displays 'Button clicked!'

1.2 Mouseover

Mouseover occurs when the mouse enters an element; mouseout happens when it leaves.

// <div id="moveArea" style="width: 200px; height: 200px; background-color: lightcoral;"></div>
<script>
const moveArea = document.getElementById('moveArea');
moveArea.addEventListener('mousemove', function(event) {
  console.log(`Mouse coordinates - X: ${event.clientX}, Y: ${event.clientY}`);
});
</script>

Code explanation: creates a <div> (moveArea) and attaches a 'mousemove' listener that logs pointer coordinates.

2. Keyboard events

Keyboard events include 'keydown' (press), 'keyup' (release), and 'keypress' (press and hold).

2.1 Keyup and Keydown

// <input type="text" id="keyInput">
<script>
const keyInput = document.getElementById('keyInput');
keyInput.addEventListener('keydown', function() {
  console.log('Key pressed down!');
});
keyInput.addEventListener('keyup', function() {
  console.log('Key released!');
});
</script>

Code explanation: input field with listeners for 'keydown' and 'keyup'; logs messages to console.

2.2 Keypress

// <input type="text" id="pressInput">
<script>
const pressInput = document.getElementById('pressInput');
pressInput.addEventListener('keypress', function() {
  console.log('Key pressed!');
});
</script>

Code explanation: input with 'keypress' listener logs 'Key pressed!' when a character-producing key is pressed.

3. Submit events

Form events like 'submit' let you handle form submission, validate, or prevent default behavior.

// <form id="myForm">
<input type="text" id="textInput">
<input type="submit" value="Submit">
</form>
<script>
document.getElementById('myForm').addEventListener('submit', function(event) {
  event.preventDefault();
  console.log('Form submitted!');
});
</script>

Code explanation: listener prevents default and logs on submission.

3.2 Change event: fires when input value changes (useful for live validation).

3.3 Focus event: 'focus' and 'blur' for visual cues or validation.

// <input type="text" id="textInput" placeholder="Click here">
<script>
const textInput = document.getElementById('textInput');
textInput.addEventListener('focus', function() {
  console.log('Input focused');
});
textInput.addEventListener('blur', function() {
  console.log('Input blurred');
});
</script>

4. Window events

4.1 Load event

<script>
window.addEventListener('load', function() {
  console.log('Page and all resources loaded');
});
</script>

4.2 Resize event

window.addEventListener('resize', function() {
  console.log('Window resized');
});

4.3 Scroll event

window.addEventListener('scroll', function() {
  console.log('Document scrolled');
});

Conclusion: addEventListener is vital for managing events, improving readability and scalability.

---

### download2.pdf — DOM Manipulation Methods (querySelectorAll & classList)

DOM Manipulation Methods

querySelectorAll is a method that selects multiple DOM elements using CSS selectors and returns a non-live NodeList. Use it to select by class, ID, or tag.

1. Selecting by class

HTML example with multiple <p class="highlighted"> elements.

JavaScript:
const elementsByClass = document.querySelectorAll('.highlighted');
console.log(elementsByClass);

Output: NodeList with matching <p> elements.

Explanation: returns NodeList; logs selected elements.

2. Selecting by ID

JavaScript:
const elementByID = document.querySelectorAll('#my-paragraph');
console.log(elementByID);

Output: NodeList with the element (even single result is a NodeList).

3. Selecting by tag name

JavaScript:
const elementsByTag = document.querySelectorAll('p');
console.log(elementsByTag);

Output: NodeList of all <p> elements.

ClassList

classList is a DOMTokenList on elements to manage classes with convenient methods:

Common methods:
- add(class1, class2, ...)
- remove(class1, class2, ...)
- toggle(class, force)
- contains(class)
- replace(oldClass, newClass)
- item(index)
- toString()

Example HTML + script:
<p id="myParagraph" class="highlight">This is a paragraph.</p>
<button onclick="performClassListOperations()">Perform Operations</button>

function performClassListOperations() {
  const paragraph = document.getElementById('myParagraph');
  paragraph.classList.add('italic');
  paragraph.classList.remove('highlight');
  paragraph.classList.toggle('underline', true);
  const hasItalicClass = paragraph.classList.contains('italic');
  console.log(`Has italic class: ${hasItalicClass}`);
  setTimeout(() => {
    paragraph.classList.replace('underline', 'strike');
    const classString = paragraph.classList.toString();
    console.log(`Current classes: ${classString}`);
  }, 2000);
}

Summary: demonstrates adding, removing, toggling, checking, and replacing classes.

---

### download3.pdf — Cheatsheet: Working with DOM in JavaScript

Cheatsheet covering debugging, BOM (browser object model), and DOM terminologies.

- try { ... } / catch { ... }:
  Example shows catching errors from accessing properties on undefined and continuing execution.

- getElementById():
  Example HTML with id attributes and usage: document.getElementById('main-heading').

- getElementsByClassName():
  Returns an HTMLCollection; sample code iterates and updates textContent.

- getElementsByTagName():
  Returns elements by tag name; examples logging paragraph elements.

- querySelector / querySelectorAll:
  querySelector selects first match; querySelectorAll returns NodeList of matches.

- textContent() and setAttribute():
  Examples of updating element text and attributes (e.g., image src).

- Adding elements:
  createElement, appendChild example to add <li> elements.

- cloneNode():
  cloneNode(true) to duplicate nodes.

BOM objects and methods (window, navigator, screen, history, location) with examples:
- window.alert, open, close, setTimeout, localStorage/sessionStorage
- navigator.appName, appVersion
- screen.width, screen.height
- history.back(), history.forward()
- location.href and redirects

Examples of attaching event listeners to buttons and using history/location.

DOM traversal:
- firstElementChild and lastElementChild example.

Container queries:
- container.querySelector and querySelectorAll usage.

Element styling:
- element.style.property = value examples
- classList usage and toggling classes with event listeners
- setAttribute, cssText, setProperty, removeProperty examples

Summary: practical code snippets for common DOM tasks and BOM interactions.

---

### download4.pdf — Hands-on Lab: Colorful Memory Match Game (JavaScript DOM)

Hands-on lab for building a memory match game using HTML, CSS, and JavaScript.

What you will learn
- Create dynamic game elements (cards), handle click events, implement scoring, timer, and restart logic using DOM manipulation, event handling, array shuffling, and game logic.

Prerequisites: basic HTML and Git, browser with console.

Step 1: Setup
- Clone repository, create folder colorfulMemoryGame, add files: colorful_memory_game.html, colorful_memory_game.js, colorfulGame.css.
- Link CSS and JS in HTML.

Step 2: HTML template
<!DOCTYPE html>
<html>
<head>
  <title>Colorful Memory Match Game</title>
  <link rel="stylesheet" href="./colorfulGame.css">
</head>
<body>
  <h1>Colorful Memory Match Game</h1>
  <div class="container">
    <div id="game-container"><!-- cards generated here --></div>
    <div class="startMain">
      <p id="score">Score: 0</p>
      <p id="timer">Time Left: 30</p>
      <button id="startbtn">Start/Restart</button>
    </div>
  </div>
  <script src="./colorful_memory_game.js"></script>
</body>
</html>

Step 3: Run with Live Server on port 5500.

Step 4: Git commands to add, commit, push.

Step 5: Define variables
const colors = ['red','blue','green','purple','orange','pink','red','blue','green','purple','orange','pink'];
let cards = shuffle(colors.concat(colors));
let selectedCards = [];
let score = 0;
let timeLeft = 30;
let gameInterval;

DOM selections:
const startbtn = document.getElementById('startbtn');
const gameContainer = document.getElementById('game-container');
const scoreElement = document.getElementById('score');
const timerElement = document.getElementById('timer');

Step 6: Functions

generateCards():
- Creates card divs: class 'card', dataset.color, textContent '?' and appends to gameContainer.

shuffle(array):
- Fisher–Yates shuffle implementation and returns shuffled array.

handleCardClick(event):
- Gets card element from event.target.
- Ignores clicks not on .card or on already matched cards.
- Reveals color: textContent = dataset.color and backgroundColor.
- Pushes card to selectedCards and if two selected, calls checkMatch after 500ms.

checkMatch():
- Destructures selectedCards into card1, card2.
- If dataset.color equal:
  - add 'matched' class to both
  - score += 2
  - update scoreElement.textContent = `Score: ${score}`
- Else:
  - restore textContent to '?'
  - set backgroundColor to '#ddd'
- Reset selectedCards = []

startGame():
- let timeLeft = 30; startbtn.disabled = true; score = 0; update scoreElement; startGameTimer(timeLeft);
- cards = shuffle(colors.concat(colors)); selectedCards = []; gameContainer.innerHTML = ''; generateCards();
- gameContainer.addEventListener('click', handleCardClick);

startGameTimer(timeLeft):
- timerElement.textContent = `Time Left: ${timeLeft}`;
- gameInterval = setInterval(() => {
    timeLeft--;
    timerElement.textContent = `Time Left: ${timeLeft}`;
    if (timeLeft === 0) {
      clearInterval(gameInterval);
      let timeLeft = 30; // redundant local redeclaration
      alert('Game Over!');
      startbtn.disabled = false;
    }
  }, 1000);

Event listeners:
startbtn.addEventListener('click', startGame);

Step 7: Output and expected behavior
- Game grid shows '?' cards, score and timer update.
- Clicking Start/Restart initializes timer and cards.
- Matching pairs increments score; timer counts down; when time ends, alert 'Game Over!' shown.

Summary
1. HTML structure for the game grid, score, timer, start button.
2. CSS for layout and style.
3. JavaScript for generateCards, shuffle, handleCardClick, startGame, timer.
4. Event listeners for start button and game container clicks.

---
### download5.pdf — JavaScript and Browser Support

JavaScript's functionality can vary across different browsers, making it crucial for developers to understand browser support to ensure their code works consistently across platforms. Here's an overview of JavaScript and browser support.

## JavaScript Features and Browser Compatibility

· Core JavaScript Compatibility: Modern browsers universally support fundamental JavaScript functionalities such as variables, loops, conditionals, functions, and data structures.

· ECMAScript Standards: JavaScript adheres to ECMAScript standards, with new versions introducing additional features and improvements. Older browser versions might not fully support newer standards.

. Cross-Browser Variations: Historically, browsers implemented JavaScript differently, leading to inconsistencies. While modern browsers have aligned more closely with standards, disparities may still exist, especially in older browsers like Internet Explorer.

· Feature Detection: Rather than relying on browser detection, developers use feature detection to determine if a specific feature or API is available in a browser. It enables graceful handling of unsupported functionalities.

. Polyfills and Transpilers: To address browser incompatibilities, developers use polyfills to replicate modern JavaScript features in browsers that lack native support. Transpilers like Babel convert newer JavaScript syntax into older versions for wider browser compatibility.

· Testing and Best Practices: Thoroughly test code across different browsers using tools like BrowserStack, cross-browser testing tools, or services offered by cloud-based platforms. Embrace best practices such as writing clean, standardized code and utilizing modern JavaScript features cautiously with fallbacks in place.

## Recommendations for Developers

· Stay Informed: Stay updated on ECMAScript standards and browser updates to leverage the latest JavaScript features.

· Feature Testing: Employ feature detection techniques rather than assuming consistent browser support.

· Fallback Strategies: Plan for unsupported features by implementing fallbacks or alternative approaches for a consistent user experience.

. Community Engagement: Engage with developer communities and utilize reliable resources like MDN Web Docs and caniuse.com to troubleshoot compatibility issues and learn about feature support in different browsers.

· Browser Compatibility: Understanding JavaScript's compatibility with various browsers empowers developers to create robust, cross-compatible applications. Developers can ensure their JavaScript code functions seamlessly across diverse browsing environments by employing feature detection fallback strategies and staying informed about standards and browser updates.

· Browser Support: Browser support is crucial when developing JavaScript applications to ensure compatibility across different browsers. Here's an example illustrating how to detect browser support for a specific feature, in this case, the localStorage API.

// Check if the browser supports localStorage
function isLocalStorageSupported() {
try {
const testKey = '\_test\_';
localStorage.setItem(testKey, testKey);
localStorage.removeItem(testKey);
return true;
} catch (e) {
return false;
}
}

if (isLocalStorageSupported()) {
console.log('localStorage is supported in this browser!');
} else {
console.log('Sorry, localStorage is not supported in this browser. ');
}

### Explanation:

1. The isLocalStorageSupported() function tests the browser's support for localStorage.

2. Inside the function:

· It tries to set an item in localStorage using setItem() with a key-value pair (in this case, both the key and the value are test).

o It then attempts to remove the item using removeItem() with the same key.

· If both operations (setItem and removeItem) succeed without throwing an error, it concludes support for localStorage and returns true.

o If an error occurs during the process (for instance, if the browser does not support localStorage or is disabled), it catches the error, indicating lack of support, and returns false.

3. The code then checks the return value of isLocalStorageSupported() and logs a corresponding message to the console informing whether the browser supports localStorage.

# Conclusion

Using a try ... catch block helps detect support for localStorage by attempting to perform operations specific to localStorage and handling any errors that may occur if the browser doesn't support it. If the try block fails and executes the catch block, it signifies the lack of support for localStorage, triggering the appropriate message in the console.

Understanding browser compatibility and knowing which features different browsers support is crucial. Websites like caniuse.com and MDN Web Docs offer detailed information about browser support for various JavaScript features, HTML elements, and CSS properties.

---

### download6.pdf — Hands-on Lab: Create a To-Do List Using JavaScript

Skills Network

Estimated time needed: 30 minutes

## What you will learn

In this To-Do List application lab, you will explore the process of building a functional task management interface using HTML, CSS, and JavaScript. Follow step-by-step instructions to understand the implementation of fundamental features, including adding tasks, dynamically displaying a task list, marking tasks as completed, clearing completed tasks, and implementing live search functionality. Throughout this process, you will grasp key concepts such as DOM manipulation, event handling, array manipulation for task management, and filtering tasks based on user input.

## Learning objectives

After completing this lab, you will be able to:

· Task management implementation: Learn the process of creating a functional task management interface by implementing features like adding tasks, displaying a task list dynamically, toggling task completion status, and clearing completed tasks using HTML, CSS, and JavaScript.

. DOM manipulation proficiency: Gain proficiency in manipulating the Document Object Model (DOM) using JavaScript to dynamically create and modify elements within the webpage, enabling real-time updates and interactions within the To-Do List application.

· Event handling and user interaction: Explore event-driven programming by implementing event listeners for user actions such as adding tasks, toggling completion, and filtering tasks based on search input, fostering a responsive and interactive user experience.

. Understanding front-end principles: Comprehend fundamental front-end development principles, including UI design considerations, CSS styling for layout and aesthetics, and integrating JavaScript functionalities to create a cohesive and user-friendly To-Do List application interface.

## Prerequisites

· Basic knowledge of HTML.

· Basic understanding of arrays, arrays methods and properties, DOM manipulation.

· Web browser with a console (Chrome DevTools, Firefox Console, and so on).

## Step 1: Setting up the environment

1. Firstly, you need to clone your main repository in Skills Network Environmemnt. Follow given steps:

· Click on terminal in the top-right window pane and then select New Terminal.

· Perform git clone command by writing the given command in the terminal.

git clone <github-repository-url>

Note: Put your own GitHub repository link instead of <github-repository-url> which you created in first lab.

!
Problems
>
theia@theia-richaar: /home/project >

theia@theia-richaar: /home/project$ git clone https://github.com/

· Above step will clone the folder for your GitHub repository under project folder in explorer. You will also see multiple folders inside the cloned folder.

Now you need to navigate inside the cloned folder. For this write the given command in the terminal:
cd <repository-folder-name>

<!-- PageBreak -->

Replace this with your cloned folder name

theia@theia-richaar: /home/project$ cd
jscoursetesting

Note: Write your cloned folder name instead of <repository-folder-name>". Perform git clone if you have logged out of Skills Network Environment and you cannot see any files or folder after you logged in.

2. Now select cloned Folder Name folder, right-click on it and click on New Folder. Enter folder name as TodoList. It will create the folder for you. Then select Todo List folder, right-click and select New File. Enter file named as todo_list.html and click OK. It will create your HTML file.

3. Create template structure of a HTML file by adding the following content:

<! DOCTYPE html>
<html>
<head>
<title>ToDo List</title>
</head>
<body>
<h1>ToDo List</h1>
<input type="text" id="taskInput" placeholder="Add a new task">
<button id="addTaskBtn">Add Task</button>
<!-- < input type="text" id="searchInput" placeholder="Search ... "> -- >
<ul id="taskList">
<!-- Tasks will be displayed here -- >
</ul>
<button id="clearCompletedBtn">Clear Completed</button>
</body>
</html>

4. The above HTML code includes the given points:

. This code snippet represents a simple web page layout. It includes the following elements:

· An <h1> heading indicates a "To-Do List." An <input> field with the ID taskInput allows users to input new tasks, and a button with the ID addTaskBtn is present
☐

to add these tasks.

· Task list display: An unordered list <ul> with the ID taskList displays the tasks users add. Initially, it is empty and meant to populate as users add tasks.
☐

· Clear completed button: Lastly, a button with the ID clearCompletedBtn intended to clear completed tasks from the list.
☐

Note: When you have pasted the code, save your file.

5. Now select TodoList folder again, right click and select New File. Enter the file named todo_list.js and click OK. It will create your JavaScript file.

6. To include js file in todo_list.html, You can use the script tag in the HTML file just above the </body> tag. You can use the given code to include and save the script file.
<script src="./todo_list.js"></script>

Step 2: Defining variables to access data

1. Declare a variable named taskInput and initialize it as follows:

o Write the given code in the todo_list.js file.
☐
const taskInput = document.getElementById("taskInput");

<!-- PageBreak -->

☐
o This line retrieves the HTML element with the ID "taskInput" from the document, assigning it to the constant variable taskInput. It enables access to the input field where users can enter new tasks using JavaScript in the Todo List application.

2. Similarly, add given code in todo_list.js file:

const addTaskBtn = document.getElementById("addTaskBtn");
const taskList = document.getElementById("taskList");
const clearCompletedBtn = document.getElementById("clearCompletedBtn");

. In the above lines of code, document.getElementById() is used to retrieve specific elements from the HTML document by their unique IDs, such as:

o addTaskBtn fetches the button element responsible for adding tasks.
☐

o taskList retrieves the unordered list element where tasks are displayed.
☐

o clearCompletedBtn accesses the button used to clear completed tasks.
☐

3. Declare an empty array with a variable named tasks.
let tasks = [];

### Step 3: Defining various functions to access data

1. Create the addTask function by including the given code in the JavaScript file.

function addTask() {
const taskText = taskInput. value. trim();
if (taskText !== "") {
tasks.push({ text: taskText});
taskInput. value = "";
displayTasks();
}

}

· The above code includes:

o taskText variable to retrieve the value entered into the taskInput HTML element by the user, trimming any trailing whitespace.
☐
o A conditional statement that uses an if block to check if the task Text is not an empty string; if not, it creates a new task object with the entered text.
☐

· Addition of this new task object using the push array method to the tasks array, representing the ToDo List.
☐

· Resetting the value of the taskInput field to an empty string after adding the task, clearing the input for the next task entry.
☐

· Calling the display Tasks function to display entered todo tasks, which you will create in the next step.
☐

2. Create the displayTasks function by including the given code in the JavaScript file.

function displayTasks() {
taskList. innerHTML = "";
tasks. forEach((task, index) => {
const li = document.createElement("li");
li.innerHTML = ><input type="checkbox" id="task-${index}" ${task.completed ? "checked" : ""}>
<label for="task-${index}">${task.text}</label>`;
li.querySelector("input").addEventListener("change", () => toggleTask(index));
taskList.appendChild(li);
});

}

<!-- PageBreak -->

· The above code includes the following:

o taskList. innerHTML = ""; to clear the existing content within the taskList element by setting its innerHTML to an empty string.
☐

o tasks. forEach iterates through the tasks array using forEach, creating a list item <li> for each task.
☐

o It constructs HTML content for each task by assigning it to li. innerHTML, which includes a checkbox, a label displaying the task text, and corresponding IDs.
☐

· Then, with the help of li. querySelector, it sets up an event listener for each checkbox within the task list <li> element. When the checkbox state changes, it triggers the toggle Task() function, which you will create in the next step.
☐

☐
Then appends the newly created list item containing the task details in the To-Do List interface using the appendChild method.

3. Create the toggle Task function and include the given code:

function toggleTask(index) {
tasks[index] . completed = ! tasks[index] . completed;
displayTasks();
}

o This toggle Task function toggles the completion status of a specific task in the tasks array based on the provided index.
☐

· It helps by selecting the checkbox regardless. If selected, then it will mark that particular task as completed.
☐

o For this, you need to call one more function called the clearCompletedTasks function.
☐

4. Create a clearCompletedTasks function:

}
function clearCompletedTasks() {
tasks = tasks. filter(task => !task. completed);
displayTasks();

· In the above code, the filter method filters the task array, which has the list of tasks entered by users.
☐

o tasks.filter(task => !task. completed); code filters the tasks array to retrieve only the tasks that are not marked as completed (task.completed is false), returning a new array excluding completed tasks.
☐

5. Perform addEventListener for addTask and clearCompletedTasks buttons to listen for clicks after clicking the Add Task and Clear Completed buttons.

addTaskBtn. addEventListener("click", addTask);
clearCompletedBtn.addEventListener("click", clearCompletedTasks);

6. The function calls the displayTasks function to show the entered todo task after clicking the Add Task button.
displayTasks();

#### Step 4: Check the output

1. To view your HTML page, right-click the todo_list.html file after selecting this file, then select "Open with Live Server."

<!-- PageBreak -->

· The server should start on port 5500, indicated by a notification on the bottom right side.

i
Server is Started at port : 5500

X

Don't show again

2. Click the Skills Network button on the left (refer to number 1). It will open the "Skills Network Toolbox". Next, click "Launch Application" (refer to number 2). From there, you enter port number 5500 at number 3 and click this button
7

.

3. It will open your default browser where you will see cloned-folder-name folder name. Click on that cloned-folder-name folder name. After clicking you will see multiple folders name, among those folders name click on TodoList folder. You will see files related to this folder where again you will click on todo_list.html file as shown below.

3. It will open the HTML page and show the output as shown below:

# To-Do List

Add a new task

Add Task


## Clear Completed

4. Then, enter any task in the input box and click the Add Task button; you will see the task on the front page as shown below.

# To-Do List

Add a new task
☐
Milk
☐
Bread

Add Task

Clear Completed

5. You can then select that particular task by clicking the check box and the Clear Completed button. You will see that the task is no longer visible on the front page.

## To-Do List

Add a new task

Add Task

☒
Milk
☐
Bread

Clear Completed

Step 5: Perform Git commands

1. Perform git add to add the latest files and folder in the git environment.
git add -- a

· Make sure the terminal has the path as follows:

theia@theia-richaar ://home/project/jscoursetesting$
git add -- a

Replace jscoursetesting with your cloned repository folder name

2. Then perform git commit in the terminal. While performing git commit, terminal can show message to set up your git config -- global for user.name and user.email. If yes, then you need to perform git config command as well for user. name and user. email as given below.

git config -- global user.email "you@example.com"

git config -- global user.name "Your Name"

3. Next, perform git push just by writing given command in terminal.
git push origin

· After the push command, the system will prompt you to enter your username and password. Enter the username for your GitHub account and the password that you created in the first lab. After entering the credentials, all of your latest folders and files will be pushed to your GitHub repository.

## Practice task

1. In this practice task, you need to include a button to clear all tasks at once.

2. For this you need to create a button named Clear All Tasks in the HTML file.

3. Then create a function to clear the tasks list, which you have stored in tasks array in lab, and call this function at the time the Clear All Tasks button is clicked.
Hint: you can empty the entire array when user clicks on the button.

Don't forget to perform git add, git commit and git push commands again after completing the task.

## Summary

1. HTML structure: Created essential HTML elements like title, To-Do List heading, input field, and buttons for adding tasks and clearing completed ones. Set up an empty list to display tasks.

2. Defined variables: To capture HTML elements using a document. getElementById variables were declared. Initialized an empty array of tasks to manage tasks.

3. Task management: addTask gathered user input, updated tasks, and refreshed the displayed list through displayTasks. This function dynamically generated HTML elements for each task. toggle Task and clearCompletedTasks managed task completion and removal.

4. Event handling: Set event listeners for the "Add Task" and "Clear Completed" buttons, triggering respective functions. Initially displayed existing tasks through displayTasks. This setup formed the foundation for a dynamic To-Do List, allowing smooth task addition, viewing, completion, and clearing.

IBM Corporation. All rights reserved.

---

### download7.pdf — Hands-on Lab: Debug a JavaScript Application in Chrome Dev Tools

Skills Network

Estimated time needed: 15 minutes

## What you will learn

In this lab, you will gain an understanding of how to debug code in JavaScript. You will learn about try and catch blocks and gain insight into how and where to use these blocks to make sure that your code is running smoothly.

## Learning objectives

After completing this lab, you will be able to:

· User input: Provides two input fields for users to enter numerical values.

· Operation execution: Multiplies the two input values when the "Perform Operation" button is clicked.

· Error handling: Checks if the entered values are valid numbers before performing the multiplication operation. If the values are not valid numbers, it displays an error message instead of the result.

· Debugging: Includes a debugger statement within the multiply() function to pause execution and allow developers to inspect the code, variables, and execution flow using browser Developer Tools.

## Prerequisites

· Basic knowledge of HTML.

· Basic understanding of console and debug.

· Web browser with a console (Chrome DevTools, Firefox Console, and so on).

## Step 1: Setting up the environment

1. Firstly, you need to clone your main repository in the Skills Network Environmemnt which you have created in the first lab and where you have pushed all of your previous labs files and folders. Follow given steps:

· Click on the terminal in the top-right window pane and then select New Terminal.

· Perform git clone command by writing given command in the terminal.

git clone <github-repository-url>

Note: Put your own GitHub repository link instead of <github-repository-url>.

!
Problems
>
theia@theia-richaar: /home/project x

theia@theia-richaar: /home/project$ git clone https://github.com/

o Above step will clone folder for your GitHub repository under project folder in explorer. You will also see multiple folders inside the cloned folder.

· Now, you need to navigate inside the cloned folder. For this, write the given command in the terminal:

cd <repository-folder-name>

Replace this with your cloned folder name

theia@theia-richaar: /home/project$ cd
jscoursetesting

Note: Write your cloned folder name instead of <repository-folder-name>. Perform git clone if you have logged out of Skills Network Environment and you cannot see any files or folder after you logged in.

2. Now select cloned Folder Name folder, right-click on it and click on New Folder. Enter folder name as DebugCode. It will create the folder for you. Then select DebugCode folder, right-click and select New File. Enter file named as debug_code.html and click OK. It will create your HTML file.

3. Create a basic template structure of an HTML file by adding content provided below.

<! DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Debugging Example</title>
</head>
<body>
<h1>Debugging Example</h1>
<label for="input1">Enter Number 1 :< /label>
<input type="number" id="input1"><br><br>
<label for="input2">Enter Number 2 :< /label>
<input type="number" id="input2"><br><br>
<button onclick="performOperation()">Perform Operation</button>
<p id="result"></p>
</body>
</html>

Note: After pasting the code, save your file.

4. Now select the DebugCode folder again, right-click, and select New File. Enter the file named debug_code.js and click OK. This action will generate your JavaScript file.

5. To include js file in debug_code.html, use the script tag in the HTML file above the </body> tag. You can use the given code to include and save the script file.
<script src="./debug_code.js"></script>

## Step 2: Defining variables

1. Include given code in debug_code.js file.

function performOperation() {
// Get user input from input fields
let num1 = parseInt(document.getElementById('input1').value);
let num2 = parseInt(document.getElementById('input2') .value);
// Check if inputs are valid numbers
if (!isNaN(num1) && ! isNaN(num2)) {
// Perform the operation
let result = multiply(num1, num2);
// Display the result
displayResult(result);
} else {
displayResult('Please enter valid numbers');
}
}
function multiply(a, b) {
// Introduce a debugger statement to pause execution
debugger;
// Multiply the numbers
return a * b;
}
function displayResult(result) {
// Display the result in the paragraph element
const resultElement = document. getElementById('result');
resultElement. textContent = `The result is: ${result} ;
}

2. Above code has following parts:

· performOperation() Function:

Retrieves numerical values entered by the user from HTML input fields (input1 and input2).

Validates that the entered values are valid numbers.

" Ifboth values are valid numbers, it calls the multiply() function passing these values, otherwise, it displays an error message.

· multiply() Function:

· Includes a debugger statement to pause code execution at this point for debugging purposes.

Multiplies two input numbers (a and b) and returns the result.

· displayResult() Function:

" Displays the result of the multiplication or an error message in a designated paragraph element (resultElement) on the webpage.

### Step 3: Debug the code to see the flow of the code

1. To view how your HTML page, right-click the debug_code.html file after selecting this file, then select "Open with Live Server".

2. The server should start on port 5500, indicated by a notification on the bottom right side.

i
Server is Started at port : 5500

X

Don't show again

3. Click on the Skills Network button on the left (refer to number 1), it will open the "Skills Network Toolbox". Then click on the Launch Application (refer to number 2).

From there you enter the port no. as 5500 at number 3 and click on this button
77
.

4. It will open your default browser where you will see cloned-folder-name folder name. After clicking you will see multiple folders name, among those folders name click on DebugCode folder. You will see files related to this folder where again you will click on debug_code.html file as shown below.

debug_code.js

Note: Save your file after pasting the code. If you edit your code, refresh your browser on port 5500. No need to relaunch the application.

5. You will see the output as below.

# Debugging Example

Enter Number 1:

Enter Number 2:

Perform Operation

6. Now enter the numbers in input boxes available and click on "Perform Operation" button.

7. Now to see the flow of this code, right-click in the same window of your browser where output is being displayed and then select "Inspect."

8. As soon as you click on the button, you will see the screen like as if it has paused, just like in the given screenshot. Also, value number 1 highlighted in red box in the screenshot shows that two numbers has been recived in variables a and b. Along with that, number 2 indicate where the pause has happened at debugger point, which is the current pointer of your code.

9. Then you need to click the forward arrow highlighted with a red box in given screenshot.

10. As soon as you will click on that button, your current pointer will move to the return a*b, indicating that the flow of the code has now reached to this point.

11. Click the forward button again, and the pointer will move towards the displayResult() function is called. Also number 2 indicate num1 and num2 has 12 and 13 values respectivly.

12. Again click on forward button and the pointer will move to number 1 in given screenshot, indicating that it is now trying to access the element whose ID is result. Also result variable has the awnswer to the multiplication.

13. Click the forward button again, and the pointer will shift towards number 1 in the screenshot, indicating that it has included the result in that element using textContent.

14. Then, click on the forward button again, and the pointer will go to number 1, indicating that the button has been clicked, and it will also show the result at number 2 in given screenshot.

15. After this, it will come out of the debugging zone.

# Step 4: Perform Git commands

1. Perform git add to add the latest files and folder in the git environment.
git add -- a

· Make sure the terminal has the path as follows:

theia@theia-richaar ://home/project/jscoursetesting$
git add -- a

Replace jscoursetesting with your cloned repository folder name

2. Then perform git commit in the terminal. While performing git commit, terminal can show message to set up your git config -- global for user.name and user.email. If yes, then you need to perform git config command as well for user. name and user. email as given.

git config -- global user.email "you@example.com"

Then perform the commit command as given:

git commit -m "message"

3. Next, perform git push by writing the given command in the terminal.

git push origin

· After the push command, the system will prompt you to enter your username and password. Enter the username for your GitHub account and the password that you created in the first lab. After entering the credentials, all of your latest folders and files will be pushed to your GitHub repository.

# Practice task

1. You need to perform arithmetic operations such as addition, multiplication, and division simultaneously using the same function.

2. Additionally, you need to check the flow of the code, which will depend on the arithmetic operation you are performing first.

3. Also, try assigning one value in the form of characters and observe how this value is displayed using the debugger.

# Summary

1. You have learned how to debug code to see the step by step flow of the program.

2. You have also learned that how using debugger keyword can also allow you to see the flow of input values which is being stored in variables in javaScript.

@ IBM Corporation. All rights reserved.

---

### download8.pdf — Cheatsheet: Arrays and Objects in JavaScript

JavaScript Array and Objects | Description | Code Example

Array declaration | Arrays in JavaScript are ordered, meaning that the elements are stored in a specific sequence. | const fruits = ["apple", "banana", "cherry"];

Array Indexing | Arrays are zero- indexed, meaning the first element is at index 0, the second at index 1, and so on. | const fruits = ["apple", "banana", "cherry"]; const firstFruit = fruits[0]; // "apple" const secondFruit = fruits[1]; // "banana"

Array Length | The length property is used to determine the number of items present in an array. | const fruits = ["apple", "banana", "cherry"]; const numFruits = fruits. length; // 3 console.log(numFruits); const fruits = ["apple", "banana", "cherry"]; fruits [2] = "strawberry"; // Modifying an element fruits [3] = "Kiwi"; // Adding an element

Array Mutability | Arrays in JavaScript are mutable, meaning you can change, add, or remove elements after the array is created.

push method | Adds one or more elements to the end of an array. | const fruits = ["apple", "banana"]; fruits.push("orange", "strawberry"); console. log(fruits)

pop method | Removes the last element from an array and returns it. | const fruits = ["apple", "banana", "orange"]; const removedFruit = fruits.pop(); console. log('Fruits are', fruits) console. log('Removed fruits are', removedFruit)

shift methods | Removes the first element from an array and returns it. | Removes the first element from an array and returns it.

unshift method | Adds one or more elements to the beginning of an array and returns it. | const fruits = ["banana", "orange"]; fruits.unshift("apple", "strawberry"); console.log(fruits);

splice method | Changes the contents of an array by removing, replacing, or adding elements at a specified position. | const fruits = ["apple", "banana", "cherry"]; fruits.splice(1, 1, "grape"); // Replace the second element with "grape" console. log(fruits)

concat method | The concat method in JavaScript arrays combines arrays in sequence, creating a new array containing the elements of the original arrays in the order they were concatenated. | const fruits = ["apple", "banana"]; const additionalFruits = ["orange", "strawberry"]; const combinedFruits = fruits. concat(additionalFruits); console. log('combinedFruits are', combinedFruits)

slice method | Returns a shallow copy of a portion of an array into a new array. | const fruits = ["apple", "banana", "cherry", "orange"]; const slicedFruits = fruits. slice(1, 3); // Creates a new array with elements from index 1 to 2 (not ir console. log('slicedFruits are', slicedFruits)

indexOf method | This method is used to find the index of a specified element within an array. It returns the index of the first occurrence of the element in the array, or - 1 if the element is not found. | const fruits = ["apple", "banana", "cherry", "banana"]; const index = fruits. indexOf("banana"); // Returns 1 (the first occurrence of "banana") console. log('Index of banana is', index)

reverse method | The reverse method reverses the order of elements in an array, effectively reversing the array in place. | const fruits = ["apple", "banana", "cherry"]; fruits.reverse(); // Reverses the order of the array console. log(fruits)

sort method | The sort method is used to sort the elements of an array in place and returns the sorted array. By default, it sorts elements as strings and in lexicographic order. | const numbers = [4, 2, 8, 6, 1,10]; numbers.sort(); // Sorts as strings: [1,10, 2, 4, 6, 8] numbers.sort((a, b) => a - b); // Sorts as numbers: [1, 2, 4, 6, 8] console. log(numbers)

Array iteration | A for loop can be used to iterate through the elements of an array to access and manipulate each item in the array. | const fruits = ['apple', 'banana', 'cherry', 'date']; for (let i = 0; i < fruits.length; i++) { console.log(fruits[i]); }

forEach | The forEach method iterates through an array and applies a provided function to each element.

map method | The map method creates a new array by applying a provided function to each element in the original array. | const products = [ { name: 'Laptop', price: 1000 }, { name: 'Smartphone', price: 500 }, { name: 'Tablet', price: 300 }, ]; products.map((product) => { console. log(`The price of ${product.name} is $${product.price} ); });

filter method | The filter method creates a new array containing elements that pass a specified condition. It's useful for extracting specific data from an array. | const minPrice = 100; // Minimum price threshold const maxPrice = 500; // Maximum price threshold const filteredProducts = filterProductsByPriceRange(products, minPrice, maxPrice); filteredProducts. forEach((product) => { }); console.log( ${product.name} is of $${product.price} );

reduce method | The reduce method allows you to reduce an array to a single value by applying a function to each element. It's excellent for aggregating data. | const orderPrices = [50, 30, 25, 40, 15]; const totalOrderValue = orderPrices.reduce((total, price) => total + price, 0); console. log('The total value of order is ', totalOrderValue)

find method | The find method returns the first element in an array that satisfies a specified condition. It's useful for searching for specific data. | const employees = [ { id: 1, name: 'Alice', Eid: 'EMP001', 'Contact details': 'alice@example.com', Role: 'Manager', Des { id: 2, name: 'Bob', Eid: 'EMP002', 'Contact details' : 'bob@example.com', Role: 'Engineer', Desigr { id: 3, name: 'Charlie', Eid: 'EMP003', 'Contact details': 'charlie@example. com', Role: 'Analyst', const employee = employees.find((e) => e.id === 2); ]; console. log(`Details of the employee\nname: ${employee.name} \nEid: ${employee. Eid} \nContact details: ${

2D Array example:
const grid = [
[1, 2, 3],
[4, 5,6],
[7,8,9]
];

A 2D array can be created by initializing an array of arrays.

for (let i = 0; i < grid.length; i++) {
for (let j = 0; j < grid[i]. length; j++) {
console.log(`Element at (${i}, ${j}): ${grid[i][j]} );
}
}

Access 2D Array
To access a specific element in a 2D array, you need to provide both row and column indices.

2D array to book seat
You can create a booking system using 2D array.

Example HTML + CSS + JS (seating chart + booking logic) with code snippets showing seats grid, CSS classes (.seat, .available, .booked), and functions bookSeat, updateSeatStatus, bookRandomSeat. (The PDF includes an example markup and script illustrating booking logic and randomly selecting available seats.)

Classes and Objects:

class Person {
constructor(firstName, lastName) {
this.firstName = firstName;
this. lastName = lastName;
}
getFullName() {
return ${this.firstName} ${this. lastName}`;
}

Classes are a way to create blueprint or templates for objects. They define the structure and behavior of objects of that class.

Creating an instance:
const person1 = new Person("John", "Doe");
console.log(person1.getFullName()); // Output: "John Doe"

Constructor Objects and Object Literals examples, Function Constructor example (Car), Dot and Bracket notation, Arrays of Objects examples, accessing nested objects, iterating, adding and removing objects, map/filter usage, find, nested array of objects examples.

Strings, template literals, string methods (toLowerCase, toUpperCase, indexOf, includes, substring, slice, substr, replace, split, trim), concatenation, string length, accessing characters.

Math methods: round, ceil, floor, pow, sqrt, log, random() with random quote generator example.

Date object: creating dates, retrieving components (getFullYear, getMonth, getDate, getHours, getMinutes, getSeconds), toLocaleDateString, toLocaleTimeString, date arithmetic (setFullYear, setDate), setTimeout/setInterval examples.

setInterval example:
let count = 0;
const intervalId = setInterval(function() {
console. log("Count: " + count);
count++;
if (count > 5) {
clearInterval(intervalId); // Stop after 6 iterations
}
}, 1000); // Displayed every second.

setInterval repeatedly executes a function at a specified interval.

Skills Network

---

### Transcrição completa dos PDFs

Cheatsheet: Arrays and Objects in JavaScript

<table>
<tr>
<th>JavaScript Array and Objects</th>
<th>Description</th>
<th>Code Example</th>
</tr>
<tr>
<td>Array declaration</td>
<td>Arrays in JavaScript are ordered, meaning that the elements are stored in a specific sequence.</td>
<td>const fruits = ["apple", "banana", "cherry"];</td>
</tr>
<tr>
<td>Array Indexing</td>
<td>Arrays are zero- indexed, meaning the first element is at index 0, the second at index 1, and so on.</td>
<td>const fruits = ["apple", "banana", "cherry"]; const firstFruit = fruits[0]; // "apple" const secondFruit = fruits[1]; // "banana"</td>
</tr>
<tr>
<td>Array Length</td>
<td>The length property is used to determine the number of items present in an array.</td>
<td rowspan="2">const fruits = ["apple", "banana", "cherry"]; const numFruits = fruits. length; // 3 console.log(numFruits); const fruits = ["apple", "banana", "cherry"]; fruits [2] = "strawberry"; // Modifying an element fruits [3] = "Kiwi"; // Adding an element</td>
</tr>
<tr>
<td>Array Mutability</td>
<td>Arrays in JavaScript are mutable, meaning you can change, add, or remove elements after the array is created.</td>
</tr>
</table>

<!-- PageBreak -->

<table>
<tr>
<td>push method</td>
<td>Adds one or more elements to the end of an array.</td>
<td>const fruits = ["apple", "banana"]; fruits.push("orange", "strawberry"); console. log(fruits)</td>
</tr>
<tr>
<td>pop method</td>
<td>Removes the last element from an array and returns it.</td>
<td>const fruits = ["apple", "banana", "orange"]; const removedFruit = fruits.pop(); console. log('Fruits are', fruits) console. log('Removed fruits are', removedFruit)</td>
</tr>
<tr>
<td>shift methods</td>
<td>Removes the first element from an array and returns it.</td>
<td>Removes the first element from an array and returns it.</td>
</tr>
<tr>
<td>unshift method</td>
<td>Adds one or more elements to the beginning of an array and returns it.</td>
<td>const fruits = ["banana", "orange"]; fruits.unshift("apple", "strawberry"); console.log(fruits);</td>
</tr>
<tr>
<td>splice method</td>
<td>Changes the contents of an array by removing, replacing, or adding elements at a specified position.</td>
<td>const fruits = ["apple", "banana", "cherry"]; fruits.splice(1, 1, "grape"); // Replace the second element with "grape" console. log(fruits)</td>
</tr>
</table>

<!-- PageBreak -->

<table>
<tr>
<td>concat method</td>
<td>The concat method in JavaScript arrays combines arrays in sequence, creating a new array containing the elements of the original arrays in the order they were concatenated.</td>
<td>const fruits = ["apple", "banana"]; const additionalFruits = ["orange", "strawberry"]; const combinedFruits = fruits. concat(additionalFruits); console. log('combinedFruits are', combinedFruits)</td>
</tr>
<tr>
<td>slice method</td>
<td>Returns a shallow copy of a portion of an array into a new array.</td>
<td>const fruits = ["apple", "banana", "cherry", "orange"]; const slicedFruits = fruits. slice(1, 3); // Creates a new array with elements from index 1 to 2 (not ir console. log('slicedFruits are', slicedFruits)</td>
</tr>
<tr>
<td>indexOf method</td>
<td>This method is used to find the index of a specified element within an array. It returns the index of the first occurrence of the element in the array, or - 1 if the element is not found.</td>
<td>const fruits = ["apple", "banana", "cherry", "banana"]; const index = fruits. indexOf("banana"); // Returns 1 (the first occurrence of "banana") console. log('Index of banana is', index)</td>
</tr>
<tr>
<td>reverse method</td>
<td>The reverse method reverses the order of elements in an array, effectively reversing</td>
<td>const fruits = ["apple", "banana", "cherry"]; fruits.reverse(); // Reverses the order of the array console. log(fruits)</td>
</tr>
</table>

the array in place.

<!-- PageBreak -->

<table>
<tr>
<td>sort method</td>
<td>The sort method is used to sort the elements of an array in place and returns the sorted array. By default, it sorts elements as strings and in lexicographic order.</td>
<td>const numbers = [4, 2, 8, 6, 1,10]; numbers.sort(); // Sorts as strings: [1,10, 2, 4, 6, 8] numbers.sort((a, b) => a - b); // Sorts as numbers: [1, 2, 4, 6, 8] console. log(numbers)</td>
</tr>
<tr>
<td>Array iteration</td>
<td>A for loop can be used to iterate through the elements of an array to access and manipulate each item in the array.</td>
<td>const fruits = ['apple', 'banana', 'cherry', 'date']; for (let i = 0; i < fruits.length; i++) { console.log(fruits[i]); }</td>
</tr>
<tr>
<td></td>
<td></td>
<td>function sendWelcomeEmail(email) { console. log(`Welcome email sent to ${email} ); }</td>
</tr>
<tr>
<td></td>
<td></td>
<td>const users = [ { name: 'Alice', email: 'alice@example.com' }, { name: 'Bob', email: 'bob@example.com' }, { name: 'Charlie', email: 'charlie@example.com' }, users. forEach((user) => { ]; }); sendWelcomeEmail(user.email);</td>
</tr>
<tr>
<td>forEach</td>
<td>The forEach method iterates through an array and applies a provided function to each element.</td>
<td></td>
</tr>
<tr>
<td>map method</td>
<td>The map method creates a new array by applying a provided function to each element in the original array.</td>
<td>const products = [ { name: 'Laptop', price: 1000 }, { name: 'Smartphone', price: 500 }, { name: 'Tablet', price: 300 }, ]; products.map((product) => { console. log(`The price of ${product.name} is $${product.price} ); });</td>
</tr>
</table>

<!-- PageBreak -->

<table>
<tr>
<td></td>
<td></td>
<td>const products = [ { name: 'Laptop', price: 1000 }, { name: 'Smartphone', price: 500 }, { name: 'Tablet', price: 300 }, { name: 'Monitor', price: 250 }, { name: 'Keyboard', price: 50 }, function filterProductsByPriceRange(products, minPrice, maxPrice) { ]; return products. filter((product) => product. price >= minPrice && product. price <= maxPrice); }</td>
</tr>
<tr>
<td>filter method</td>
<td>The filter method creates a new array containing elements that pass a specified condition. It's useful for extracting specific data from an array.</td>
<td>const minPrice = 100; // Minimum price threshold const maxPrice = 500; // Maximum price threshold const filteredProducts = filterProductsByPriceRange(products, minPrice, maxPrice); filteredProducts. forEach((product) => { }); console.log( ${product.name} is of $${product.price} );</td>
</tr>
<tr>
<td>reduce method</td>
<td>The reduce method allows you to reduce an array to a single value by applying a function to each element. It’s excellent for aggregating data.</td>
<td>const orderPrices = [50, 30, 25, 40, 15]; const totalOrderValue = orderPrices.reduce((total, price) => total + price, 0); console. log('The total value of order is ', totalOrderValue)</td>
</tr>
<tr>
<td>find method</td>
<td>The find method returns the first element in an array that satisfies a specified condition. It’s useful for searching for specific data.</td>
<td>const employees = [ { id: 1, name: 'Alice', Eid: 'EMP001', 'Contact details': 'alice@example.com', Role: 'Manager', Des { id: 2, name: 'Bob', Eid: 'EMP002', 'Contact details' : 'bob@example.com', Role: 'Engineer', Desigr { id: 3, name: 'Charlie', Eid: 'EMP003', 'Contact details': 'charlie@example. com', Role: 'Analyst', const employee = employees.find((e) => e.id === 2); ]; console. log(`Details of the employee\nname: ${employee.name} \nEid: ${employee. Eid} \nContact details: ${</td>
</tr>
</table>

<!-- PageBreak -->

const grid = [
[1, 2, 3],
[4, 5,6],
[7,8,9]
];

2D Array

A 2D array can be
created by initializing
an array of arrays.

for (let i = 0; i < grid.length; i++) {
for (let j = 0; j < grid[i]. length; j++) {
console.log(`Element at (${i}, ${j}): ${grid[i][j]} );
}
}

Access 2D Array

To access a specific
element in a 2D
array, you need to
provide both row
and column indices.

2D array to book
seat

You can create a
booking system
using 2D array.

<! DOCTYPE html>
<html>
<head>
<style>
/* CSS for styling the seats */
. seating-chart {
display: grid;
grid-template-columns: repeat(3, 70px);
gap: 10px;
justify-content: center;
}

.seat {
width: 70px;
height: 40px;
text-align: center;
line-height: 40px;
border: 1px solid #ccc;
cursor: pointer;
}
. booked {
background-color: #FF0000; /* Red */
cursor: not-allowed;
color: white; /* Set the text color to white for booked seats */
}
.available {
background-color: #7FFF00; /* Light Green */
}
. select-button {
width: 100%;
padding: 10px;
margin: 10px;
background-color: #007BFF; /* Blue */
color: white;
border: none;
cursor: pointer;
}
</style>

</head>
<body>
<h2>Movie Theater Seating</h2>
<div id="seating-chart" class="seating-chart">
<div class="seat available" onclick="bookSeat(0, 0)">A1</div>
<div class="seat available" onclick="bookSeat(0, 1)">A2</div>
<div class="seat available" onclick="bookSeat(0, 2)">A3</div>
<div class="seat available" onclick="bookSeat(1, 0)">B1</div>
<div class="seat available"
onclick="bookSeat(1, 1)">B2</div>
<div class="seat available" onclick="bookSeat(1, 2)">B3</div>
<div class="seat available" onclick="bookSeat(2, 0)">C1</div>
<div class="seat available"
onclick="bookSeat(2, 1)">C2</div>
<div class="seat available" onclick="bookSeat(2, 2)">C3</div>
</div>
<button class="select-button" onclick="bookRandomSeat()">Select Random Seat</button>

<!-- PageBreak -->

<script>
// JavaScript for booking seats
const theaterSeats = [
['X', 'O', 'X'],
☑ ☑
['O', 'X', '0'],
☑ ☑

☑
['X', 'O', 'X']

];
function bookSeat(row, col) {
if (theaterSeats[row] [col] === '0') {
theaterSeats [row] [col] = 'X';
}
}
}
☑
updateSeatStatus(row, col, 'booked');
alert("Seat ${String. fromCharCode(65 + row)}${col + 1} is booked.'");
} else {
alert(`Seat ${String. fromCharCode(65 + row)}${col + 1} is already taken.");
}
function updateSeatStatus(row, col, status) {
const seats = document. getElementsByClassName('seat');
const index = row * 3 + col;
seats[index] . classList. remove('available', 'booked');
seats[index]. classList. add(status);
}
function bookRandomSeat() {
const availableSeats = [];
for (let row = 0; row < theaterSeats. length; row++) {
for (let col = 0; col < theaterSeats[row]. length; col++) {
if (theaterSeats[row][col] === '0') {
availableSeats. push({ row, col });
}
if (availableSeats.length > 0) {
const randomIndex = Math. floor(Math.random() * availableSeats. length);
const { row, col } = availableSeats[randomIndex];
bookSeat(row, col);
} else {
alert('All seats are already booked. ');

}
}
}
</script>
</body>
</html>

class Person {
constructor(firstName, lastName) {
this.firstName = firstName;
this. lastName = lastName;
}
getFullName() {
return ${this.firstName} ${this. lastName}`;
}

Classes

Classes are a way to
create blueprint or
templates for
objects. They define
the structure and
behavior of objects
of that class.

}
 // Creating an instance of the Person class
const person1 = new Person("John", "Doe");
console.log(person1.getFullName()); // Output: "John Doe"

Constructor Objects

Objects are
instances of classes
or can be created as
standalone objects
without a class. They

class Car {
constructor(make, model, year) {
this.make = make;
this.model = model;
this. year = year;
}
startEngine() {
console. log( The ${this.make} ${this.model}'s engine is running. );

<!-- PageBreak -->

<table>
<tr>
<td></td>
<td>can have properties and methods.</td>
<td>} const myCar = new Car("Toyota", "Camry", 2022); } myCar.startEngine(); // Output: "The Toyota Camry's engine is running."</td>
</tr>
<tr>
<td>Object Literals</td>
<td>Object literals are a way to create ad- hoc objects without defining a class.</td>
<td>const person = { firstName: "Alice", lastName: "Johnson", getFullName: function() { return ${this.firstName} ${this. lastName} ; } console.log(person.getFullName()); // Output: "Alice Johnson" };</td>
</tr>
<tr>
<td>Function Constructor</td>
<td>A function constructor is a regular JavaScript function that is used to create and initialize objects. It’s a convention to name function constructors with an initial capital letter.</td>
<td>function Car(make, model) { this.make = make; this.model = model; const car1 = new Car("Toyota", "Camry"); } const car2 = new Car("Honda", "Civic"); console.log('Car1 details are', car1); console.log('Car2 details are', car2);</td>
</tr>
<tr>
<td>.</td>
<td> . (Dot) Notation</td>
<td>Dot notation is a way to access object properties.</td>
<td>const person = { firstName: "John", lastName: "Doe", age: 30 console. log(person.firstName); // Output: "John" }; console. log(person. lastName); // Output: "Doe" console. log(person.age); // Output: 30</td>
</tr>
</table>

<!-- PageBreak -->

<table>
<tr>
<td>Bracket Notation</td>
<td>Bracket notation is a way to access object properties, especially useful when property names contain special characters or spaces.</td>
<td>const person = { "first name": "John", "last name": "Doe", age: 30 console. log(person["first name"]); // Output: "John" }; console. log(person["last name"]); // Output: "Doe" console. log(person["age"]); // Output: 30</td>
</tr>
<tr>
<td>Arrays of Objects</td>
<td>An array of objects in JavaScript is a collection of multiple objects stored within a single array container.</td>
<td>const students = [ { name: "Alice", age: 25 }, { name: "Bob", age: 22 }, { name: "Charlie", age: 28 } ];</td>
</tr>
<tr>
<td>Access Array of Objects</td>
<td>You can access elements within an array of objects using the array index and using dot notation.</td>
<td>const students = [ { name: "Alice", age: 25 }, { name: "Bob", age: 22 }, { name: "Charlie", age: 28 } console.log(students[0].name); // Output: "Alice" ]; console.log(students[2].age); // Output: 28</td>
</tr>
<tr>
<td>Iterating Through an Array of Objects</td>
<td>Iteration of objects through arrays include for loops and array methods.</td>
<td>const students = [ { name: "Alice", age: 25 }, { name: "Bob", age: 22 }, { name: "Charlie", age: 28 } for (let i = 0; i < students. length; i++) { ]; console. log(students[i].name); }</td>
</tr>
</table>

<!-- PageBreak -->

//Adding Elements
const students = [
{ name: "Alice", age: 25 },
{ name: "Bob", age: 22 },
{ name: "Charlie", age: 28 }
];
students.push({ name: "David", age: 20 }); // Add a new student
console.log('After using push method ');
console. log(students);

Adding Objects

You can add new
objects to the array
using the push
method.

//Removing Elements
const students = [
{ name: "Alice", age: 25 },
{ name: "Bob", age: 22 },
{ name: "Charlie", age: 28 }
];
const removedStudent = students.pop();
console. log('After using pop method ');
console. log(students);

// Remove the last student

Removing Objects

You can remove
objects using the
pop method.

Filtering and
Mapping Arrays of
Objects

You can filter and
transform arrays of
objects using array
methods like filter
and map.

const students = [
{ name: "Alice", age: 25 },
{ name: "Bob", age: 22 },
{ name: "Charlie", age: 28 }
];
const adults = students. filter(student => student. age >= 23); // Filter students who are 18 or oldercc
const studentNames = students . map(student => student. name); // Create an array of student names
console. log('Using Filter Method');
console. log(adults);
console. log('Using Map Method'
console. log(studentNames);

<!-- PageBreak -->

const employees = [
{ name: "Alice", age: 35 },
{ name: "Bob", age: 32 },
{ name: "Charlie", age: 38 }
];
const employee = employees.map((employee) => {
return employee});
console. log(employee);

Mapping Arrays of
Objects

You can traverse and
transform arrays of
objects using array
method like map.

Searching for
Objects

You can search for
objects within an
array of objects
using array methods
like find.

const employees = [
{ name: "Alice", age: 35 },
{ name: "Bob", age: 32 },
{ name: "Charlie", age: 38 }
];
const employee = employees.find(employee => employee.name === "Charlie");
console. log(employee. age);

Nested Array of
objects

An array of objects
is used to store and
organize data in a
way that allows you
to access and
manipulate the
information easily.

let arrayOfObjects = [
{
name: 'John',
age: 25,
hobbies: ['Reading', 'Traveling'],
address: {
street: '123 Main St',
city: 'New York',
zip: '10001'
}

},
{
name: 'Alice',
age: 30,
skills: ['JavaScript', 'React', 'Node. js' ],
projects: [
{ title: 'Project A', completed: true },
{ title: 'Project B', completed: false }
]
},

{
title: 'Special Object',
data: [1, 2, 3],
metadata: { key: 'value' }
},

{
// An object with no specific properties
},
{
anotherObject: true,
nestedArrays: [
[1, 2,3],
['a', 'b', 'c']
],
additionalProperty: 'Extra'
}
];

<!-- PageBreak -->

<table>
<tr>
<td>Access Nested Array-Code Above Strings</td>
<td>Using . dot operator elements of nested array can be accesed, which has been described in just above code. Strings are data type in JavaScript used to represent text. They can contain letters, numbers, symbols, and whitespace characters.</td>
<td>// Accessing properties of the first object console.log(arrayOfObjects[0].name); // Output: John console.log(arrayOfObjects[0].hobbies[0]); // Output: Reading // Accessing properties of the second object console.log(arrayOfObjects[1].skills[2]); // Output: Node.js console.log(arrayOfObjects[1].projects[0].title); // Output: Project A // Accessing properties of the third object console.log(arrayOfObjects[2].metadata.key); // Output: value // Accessing properties of the fourth object console.log(arrayOfObjects[3]); // Output: {} // Accessing properties of the fifth object console.log(arrayOfObjects[4].anotherObject); // Output: true console. log(arrayOfObjects[4].additionalProperty); // Output: Extra const message = "This is a message.";</td>
</tr>
<tr>
<td>Strings</td>
<td>Strings are data type in JavaScript used to represent text. They can contain letters, numbers, symbols, and whitespace characters.</td>
<td>const message = "This is a message.";</td>
</tr>
<tr>
<td>template literals</td>
<td>Template literals in JavaScript are strings allowing embedded expressions, denoted by backticks (),</td>
<td>const fullName = ${firstName} ${lastName}';</td>
</tr>
</table>

<!-- PageBreak -->

<table>
<tr>
<th></th>
<th>enabling easy multiline strings and interpolation of variables using $ {} '.</th>
<th></th>
</tr>
<tr>
<td>String Concatenation</td>
<td>The concatenation operator + in JavaScript is used to combine (join) two or more strings together to create a single, longer string.</td>
<td>const firstName='Peter'; const greeting = 'Hello, ' + firstName + '!'; console.log(greeting);</td>
</tr>
<tr>
<td>String Length</td>
<td>To determine the length of a string, length property can be used.</td>
<td>const message1 = "This is a message."; const Stringlength1 = message1. length; const message2 = "Thisisamessage"; const Stringlength2 = message2. length; console.log(Stringlength1); console. log(Stringlength2)</td>
</tr>
<tr>
<td>Accessing Characters</td>
<td>Individual characters within a string can be accessed using bracket notation and a zero-based index.</td>
<td rowspan="2">const text = "JavaScript"; const firstCharacter = text[0]; const text = "Hello, World!"; const lowercaseText = text. toLowerCase(); // "hello, world!" const uppercaseText = text. toUpperCase(); // "HELLO, WORLD!" console. log('The lowercase for text is ', lowercaseText); console. log('The uppercase for text is ', uppercaseText);</td>
</tr>
<tr>
<td>toLowerCase and toUpperCase</td>
<td>JavaScript provides methods to change the case of a string into lowercase and uppercase.</td>
</tr>
</table>

<!-- PageBreak -->

<table>
<tr>
<td>indexOf() method</td>
<td>indexOf returns the index of the first occurrence of a specified substring within a string. It returns - 1 if the substring is not found.</td>
<td>const sentence = "The quick brown fox jumps over the lazy dog."; const indexOfFox = sentence.indexOf("fox"); // 16 console.log(indexOfFox);</td>
</tr>
<tr>
<td>includes() method</td>
<td>includes returns a boolean indicating whether a specified substring is found within a string, returning true if found and false if not.</td>
<td>const sentence = "The quick brown fox jumps over the lazy dog."; const hasFox = sentence. includes("fox"); // true console. log(hasFox);</td>
</tr>
<tr>
<td>substring() methods</td>
<td>substring extracts characters from a string between two specified indices. It means extracting a substring from the text starting at index 0 and ending at index 5 (excluding index 5).</td>
<td>const text = "Hello, World!"; const subText1 = text.substring(0, 5); // "Hello" console.log(subText1);</td>
</tr>
<tr>
<td>slice () method</td>
<td>slice extracts a section of a string and returns it as a new string, specifying the start and end positions. It means extracting a substring from the text starting at index 7 until the end of the string.</td>
<td>const text = "Hello, World!"; const subText2 = text.slice(7); console.log(subText2); // "World!"</td>
</tr>
</table>

<!-- PageBreak -->

<table>
<tr>
<td>substr() method</td>
<td>substr extracts a specified number of characters from a string, starting at a specified index.It means extracting a substring from the text starting at the 7th index and including 5 characters.</td>
<td>const text = "Hello, World!"; const subText3 = text. substr(7, 5); // "World" console. log(subText3);</td>
</tr>
<tr>
<td>Replacing Substrings</td>
<td>The replace method allows you to replace substrings with new values.</td>
<td>const text = "Hello, World!"; const updatedText = text.replace("World", "Universe"); console.log(updatedText);</td>
</tr>
<tr>
<td rowspan="2">Splitting Strings</td>
<td rowspan="2">You can split a string into an array of substrings using the split method.</td>
<td>const csvData = "Alice, 25, New York; Bob, 30, Los Angeles; Charlie, 28, Chicago"; const peopleArray = csvData. split(';'); console. log(peopleArray);</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>trim()method</td>
<td>The trim method removes leading and trailing whitespace from a string.</td>
<td>const text = " Trim me! "; console. log(text. length); const trimmedText = text. trim(); console.log(trimmedText. length);</td>
</tr>
<tr>
<td>round(), ceil() and floor() Math Methods</td>
<td>round() rounds a number to the nearest integer. ceil()</td>
<td>const number = 3.6; const rounded = Math. round(number); // Round to nearest integer: 4 const ceil = Math. ceil(number); // Round up: 4 const floor = Math. floor (number); // Round down: 3</td>
</tr>
</table>

<!-- PageBreak -->

<table>
<tr>
<th></th>
<th>rounds a number up to the nearest integer. floor() rounds a number down to the nearest integer.</th>
<th></th>
</tr>
<tr>
<td>pow(), sqrt() and log() Math Methods</td>
<td>pow() raises a number to a specified exponent. sqrt() returns the square root of a number. log() returns the natural logarithm (base e) of a number.</td>
<td>const base = 2; const exponent = 3; const power = Math.pow(base, exponent); // Power: 8 const squareRoot = Math. sqrt(base); const naturalLog = Math. log(base); // Square Root: 1.41421356237 // Natural Logarithm: 0.69314718056</td>
</tr>
<tr>
<td rowspan="3"></td>
<td rowspan="3">The random()</td>
<td>&lt;! DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Random Quote Generator&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Random Quote Generator&lt;/h1&gt; &lt;p id="quoteDisplay"&gt;&lt;/p&gt;</td>
</tr>
<tr>
<td>&lt;button onclick="generateRandomQuote()"&gt;Get Quote&lt;/button&gt;</td>
</tr>
<tr>
<td>&lt;script&gt; const quotes = [ "Life is what happens when you're busy making other plans. - John Lennon", "The only way to do great work is to love what you do. - Steve Jobs", "In three words, I can sum up everything I've learned about life: it goes on. - Robert Frost", "Don't count the days, make the days count. - Muhammad Ali", "The only thing we have to fear is fear itself. - Franklin D. Roosevelt", "To be yourself in a world that is constantly trying to make you something else is the greatest ¿ ];</td>
</tr>
<tr>
<td>random() Method</td>
<td>method in JavaScript generates a pseudo- random floating- point number between 0 (inclusive) and n (exclusive).</td>
<td>function generateRandomQuote() { const randomIndex = Math. floor(Math. random() * quotes. length); // Generate a random index const randomQuote = quotes [randomIndex]; // Get a random quote document. getElementById("quoteDisplay"). textContent = randomQuote; &lt;/script&gt; } &lt;/body&gt; &lt;/html&gt;</td>
</tr>
<tr>
<td>Date Object</td>
<td>Date objects are used to represent specific moments in time.</td>
<td>const currentDate = new Date(); // Current date and time const specificDate = new Date(2023, 0, 15); // January 15, 2023 const fromMilliseconds = new Date(1672569600000); // From milliseconds since the epoch</td>
</tr>
</table>

<!-- PageBreak -->

<table>
<tr>
<th>Retrieving Date</th>
<th>Date objects provide access to individual components of a date, such as year, month, day, and hour.</th>
<th>const date = new Date(); const year = date.getFullYear(); // Current year const month = date. getMonth(); const day = date.getDate(); // Current month (0-11) // Day of the month (1-31) const hours = date.getHours(); // Hours (0-23) const minutes = date. getMinutes(); // Minutes (0-59) const seconds = date. getSeconds(); // Seconds (0-59)</th>
</tr>
<tr>
<td>toLocale DateString() and toLocale Time String()</td>
<td>toLocaleDateString() to converts a date to a string representing the date portion according to the locale's formatting conventions. toLocale TimeString() to converts a date to a string representing the time portion according to the locale's formatting conventions.</td>
<td>const date = new Date(); const formattedDate = date. toLocaleDateString(); // "11/15/2023" const formattedTime = date. toLocaleTimeString(); // "1:30:45 PM"</td>
</tr>
<tr>
<td>Date Arithmetic</td>
<td>Date objects allow for various date arithmetic operations, including adding and subtracting time intervals.</td>
<td>const date = new Date(); date.setFullYear(2024); // Set the year to 2024 date.setDate(date.getDate() + 7); // Add 7 days const futureDate = new Date(); futureDate.setDate(futureDate.getDate() + 30); // Date 30 days from now</td>
</tr>
<tr>
<td>setTimeout() Method</td>
<td>The setTimeout function schedules the execution of a function after a specified delay in milliseconds:</td>
<td>setTimeout (function() { console. log("This message appears after a delay."); }, 2000); // Displayed after a 2-second delay</td>
</tr>
</table>

<!-- PageBreak -->

let count = 0;
const intervalId = setInterval(function() {
console. log("Count: " + count);
count++;
if (count > 5) {
clearInterval(intervalId); // Stop after 6 iterations
}
}, 1000); // Displayed every second.

setInterval

setInterval
repeatedly executes
a function at a
specified interval.

<figure>

Skills
Network

</figure>

---

Hands-on Lab: Develop Colorful Memory Match Game Using JavaScript DOM

Skills
Network

Estimated time needed: 30 minutes

## What you will learn

In this lab, you will learn the fundamentals of building a memory matching game using HTML and JavaScript. You will understand how to dynamically generate game elements,
such as cards with various colors, handle click events to reveal and match colors, implement a basic scoring system that increments upon successful matches, create a timer
mechanism to limit game time and initiate game restart functionalities. Through this lab, you will grasp key concepts of DOM manipulation, event handling, array manipulation
(shuffling), and basic game logic, offering practical insight into creating interactive web-based games.

## Learning objectives

After completing this lab, you will be able to:

· DOM manipulation: Understand and implement dynamic HTML element creation and modification using JavaScript to generate a playable memory matching game grid.

· Event handling: Learn to manage and respond to user interactions by handling click events on game cards, revealing colors, and implementing logic for matching pairs.

· Game logic implementation: Develop fundamental game logic by incorporating mechanisms to match pairs of colors, track scores, reset the game, and manage game
time through a simple timer.

· Fundamentals of web game development: Gain insights into core concepts essential for creating interactive web-based games, including array manipulation for shuffling
elements, styling elements with CSS, and integrating JavaScript functionalities for game interactivity and dynamics.

## Prerequisites

· Basic knowledge of HTML and GitHub.

· Web browser with a console (Chrome DevTools, Firefox Console, and so on).

## Step 1: Setting up the environment

1. Firstly, you need to clone your main repository in Skills Network Environmemnt which you have created in the first lab and where you have pushed all of your previous
labs files and folders. Follow given steps:

· Click on terminal in top-right window pane and then select New Terminal.

<figure>

File Edit Selection View Go Ruh

Terminal

Help

New Terminal

2

Ctrl+Shift+'

New Terminal (With Profile)

</figure>

· Perform git clone command by writing given command in the terminal.

git clone <github-repository-url>

Note: Put your own GitHub repository link instead of <github-repository-url>.

!
\>
Problems
☑
theia@theia-richaar: /home/project x

theia@theia-richaar:/home/project$ git clone https://github.com/

· Above step will clone folder for your GitHub repository under project folder in explorer. You will also see multiple folders inside cloned folder.

· Now you need to navigate inside the cloned folder. For this write given command in the terminal:
cd <repository-folder-name>

<!-- PageBreak -->

<figure>

Replace this with your cloned folder name
theia@theia-richaar: /home/project$ cd
jscoursetesting

</figure>

Note: Write your cloned folder name instead of <repository-folder-name> which you have created in first lab. Perform git clone if you have logged out of
Skills Network Environment and you cannot see any files or folder after you logged in.

2. Now select cloned Folder Name folder, right click on it and click on New Folder. Enter folder name as colorfulMemoryGame. It will create the folder for you. Then
select colorfulMemory Game folder, right click and select New File. Enter file named as colorful_memory_game.html and click OK. It will create your HTML file.

3. Now, select the colorfulMemoryGame folder again, right click and select New File. Enter the file named colorful_memory_game.js and click OK. It will create your
JavaScript file.

4. Again, select the colorfulMemory Game folder, right click and select New File. Enter the file named colorfulGame.css and click OK. It will create your CSS file.

5. Now, click on this link colorfulGame.css and copy the code from this link and paste it in colorfulGame.css file.

## Step 2: Create HTML template structure

1. Create a template structure of an HTML file by adding the following content:

<! DOCTYPE html>
<html>
<head>
<title>Colorful Memory Match Game</title>
<link rel="stylesheet" href="./colorfulGame.css">
</head>

<body>
<h1>Colorful Memory Match Game</h1>
<div class="container">
<div id="game-container">
<!-- Cards will be generated dynamically using JavaScript -- >
</div>
<div class="startMain">
<p id="score">Score: 0</p>
<p id="timer">Time Left: 30</p>
<button id="startbtn">Start/Restart</button>
</div>
</div>
<script src="./colorful_memory_game. js"></script>
</body>
</html>

2. The above HTML code includes the following:

o The structure for a colorful memory match game including a title, "Colorful Memory Match Game," and a game elements container.
☑
o It has link tag to include CSS file in the HTML file.
☑

☐o Inside the container, there’s a specific division <div> intended to hold dynamically generated cards using JavaScript, although the card generation code isn’t present
in this snippet.

☐. Additionally, there’s a section below the game container with a paragraph displaying the current score and a timer indicating the time left, initially set to 0 and 30
seconds, respectively. Finally, there’s a button labeled "Start/Restart" <button> intended to initiate or reset the game when clicked.

· To include the JavaScript file in colorful_memory_game.html, a script tag can be used above the </body> tag.
☑

Note: When you have pasted the code, save your file.

### Step 3: Check the output

1. To view how your HTML page will be displayed in the browser, use the built-in Live Server extension. Select file colorful_memory_game.html within
colorfulMemoryGame folder and right-click on that file and choose 'Open with Live Server'.

2. A notification will appear at the bottom-right, indicating that the server has started on port 5500.

<!-- PageBreak -->

i
Server is Started at port : 5500

X
☑

Don't show again

3. Click the Skills Network button on the left (refer to number 1) to open the "Skills Network Toolbox". Then select Launch Application (refer to number 2). From there,

enter port 5500 at number 3 and click this button
27

<figure>

.

</figure>

4. It will open your default browser where you will see cloned-folder-name folder name. Click on that cloned-folder-name folder name. After clicking you will see multiple
folders name, among those folders, click on the calculate Area folder. You will see files related to this folder where again you will click on calculate_Area.html file as
shown below.

<figure>

\>
colorful_memory_game.html

colorful_memory_game.js

</figure>

5. It will show the output like below.

<!-- PageBreak -->

# Colorful Memory Match Game

Score: 0

Time Left: 30

Start/Restart

# Step 4: Perform Git commands

1. Perform git add to add the latest files and folder in the git environment.
git add -- a

· Make sure the terminal has the path as follows:

<figure>

1

theia@theia-richaar ://home/project/jscoursetesting$
git add -- a

Replace jscoursetesting with your cloned repository folder name

</figure>

2. Then perform git commit in the terminal. While performing git commit, terminal can show message to set up your git config -- global for user.name and user.email. If
yes, then you need to perform git config command as well for user. name and user. email as given.
git config -- global user.email "you@example.com"

<!-- PageFooter="git config -- global user.name "Your Name"" -->

<!-- PageBreak -->

After this, perform git commit as given:

git commit -m "message"

3. Then, perform git push by writing given command in terminal.
git push origin

· After the push command, the system will prompt you to enter your username and password. Enter the username for your GitHub account and the password that
you created in the first lab. After entering the credentials, all of your latest folders and files will be pushed to your GitHub repository.

Note: Repeat step get add, git commit, and git push every time you made change in the code while working in Skills Network Environment.

# Step 5: Defining variables to access data

1. Initialization of arrays and variables using given code:

const colors = ['red', 'blue', 'green', 'purple', 'orange', 'pink', 'red', 'blue', 'green', 'purple', 'orange', 'pink'];
let cards = shuffle(colors.concat(colors));
let selectedCards = [];
let score = 0;
let timeLeft = 30;
let gameInterval;

· colors array: This array holds distinct color values in strings, representing the colors for the cards in the memory match game. These colors create pairs for the
game.
o cards array: Initialized by shuffling and attaching the 'colors' array, this 'cards' array holds the color values for the cards in the game. The shuffle function employs
the Fisher- Yates algorithm to randomize the order of the colors and then duplicates these colors to create pairs, forming the set of cards for gameplay.
o selectedCards: This variable acts as a temporary storage for the currently selected cards during the game. When a player clicks on a card, it gets added to this
array to enable match comparisons.
o score: This variable tracks the player's score throughout the game. The score gets incremented whenever the player matches a pair of cards successfully. It’s
updated and displayed to reflect the player's progress and performance.
o time Left: It represents the time remaining for the player to complete the game. Initially set to a specific duration, it counts down as the game progresses. When it
reaches zero, the game ends.
o gameInterval: This variable manages the game timer. It’s utilized to control the countdown mechanism for the game’s duration. The interval continuously
decrements the 'timeLeft' variable, updating the displayed time and triggering the game's end when the time expires.

2. DOM element selection:

· For this, inlcude the given code after the previous code.

const startbtn = document. getElementById('startbtn');
const gameContainer = document.getElementById('game-container');
const scoreElement = document.getElementById('score');
const timerElement = document.getElementById('timer');

<!-- PageBreak -->

o startbtn: This variable is assigned the HTML element with the ID 'startbtn'. It typically represents a button element intended to start or restart the game when
clicked. This variable allows the JavaScript code to access and manipulate this specific button element.

· game Container: This variable is assigned the HTML element with the ID 'game-container'; it refers to a div or container element that dynamically generates cards
for the memory match game. It allows JavaScript to manipulate or append child elements (cards) within this container.

o score Element: This variable represents the HTML element with the ID 'score'. It is associated with a paragraph or span element displaying the player's score
during the game. JavaScript can update the displayed score by manipulating this specific element's content.

· timerElement: This variable refers to the HTML element identified by the ID 'timer'. It’s presumably linked to a paragraph or span element that displays the time
remaining for the player to complete the game. JavaScript can update this element to reflect the countdown and notify the player about the remaining time.

## Step 6: Create and call functions to start the game

1. Create the generate Cards() function responsible for dynamically creating the card elements within the game container based on the 'cards' array that holds color values
for the cards. This function creates the card elements dynamically within the game-container div. Include given code in javaScript file after previous code.

function generateCards() {
for (const color of cards) {
const card = document.createElement('div');
card.classList. add('card');
card. dataset. color = color;
card. textContent = '?';
gameContainer.appendChild(card);
}

}

· It utilizes a 'for ... of loop to iterate over each element (color) in the 'cards' array. For each color in the 'cards' array:

· Inside the loop, it creates a new HTML div element using document. createElement ('div' ). This 'div' element represents a card in the game.

· It adds a class 'card' to the newly created 'div' element using card. classList. add('card' ). This class might contain CSS styles or rules to style the card elements.

· It sets the 'dataset.color' attribute of the card element to the current color value from the 'cards' array. This icon represents the card's hidden color until the player
clicks it.

The text content of each card is initially set to a question mark ('?'). This represents that the color of the card is hidden until it's clicked by the player.

Finally, the newly created card element is attached to the 'gameContainer' element as a child. This action adds each card element to the game interface within the
designated container.

2. The shuffle() Function is responsible for shuffling the elements of an array in random order. It uses the Fisher- Yates shuffle algorithm, a common method for randomizing
the order of elements in an array. Include given code after generate Cards () function.

function shuffle(array) {
for (let i = array.length - 1; i > 0; i -- ) {
const j = Math.floor(Math.random() * (i + 1));
[array[i], array[j]] = [array[j], array[i]];
}
return array;
}

· Array parameter: It takes an array as an argument, which contains yet to be shuffled elements.

o Shuffling process using loop through the array: The function starts by initiating a 'for' loop that iterates backward through the array starting from the last index
(let i= array.length - 1; i> 0; i-).

Random index selection: Within each iteration, it generates a random index 'j' using Math. floor (Math. random() * (i + 1)). This 'j' represents a random index
within the array.

<!-- PageBreak -->

· Swapping elements: It then swaps the elements at the 'i' and 'j' indices using array destructuring assignment: [ array[i], array[j]] = [array[j], array[i]].
This line efficiently swaps the values at positions 'i' and 'j' without requiring a temporary variable.

. Continuing the loop: The loop continues until it finishes iterating through the entire array, shuffling elements along the way.

o Returning the shuffled array: Once the loop is complete, the function returns the array with its elements rearranged into a random order.

3. The handle CardClick(event) function manages the logic when a user clicks the card in the memory match game. Include given code after shuffle() function. Let's break
down each step within this function:

function handleCardClick(event) {
const card = event. target;
if (!card.classList. contains('card') || card. classList. contains('matched' )) {
return;
}
card. textContent = card. dataset. color;
card. style.backgroundColor = card. dataset. color;
selectedCards.push(card);
if (selectedCards. length === 2) {
setTimeout(checkMatch, 500);
}
}

· Event Target using const card = event. target ;: This line retrieves the element that triggered the event (in this case, a clicked card) and assigns it to the 'card'
variable.

Checking the card: if (!card.classList. contains('card') || card. classList. contains('matched' )) { return; } This 'if statement checks whether the
clicked element is a card and if it's already matched. If either condition is true:

If the element is not a card or has already matched, the function returns early, ignoring any further actions for this particular click.

o Revealing the card:

" card. textContent = card.dataset.color ;: It sets the text content of the clicked card to the value stored in its 'dataset.color'. This action reveals the card's
color by changing the text content to the color value.

card.style.backgroundColor = card.dataset. color ;: Changes the card's background color to match the revealed color.

· Handling selected cards:

" selectedCards.push(card) ;: Adds the clicked card to the 'selectedCards' array, indicating that it's one of the cards currently chosen by the player.

· Checking for matches:

" if (selectedCards.length === 2) { setTimeout(checkMatch, 500); }: Checks if two cards have been selected. If two cards have been chosen, it uses
'setTimeout()' to delay the execution of the 'checkMatch()' function by 500 milliseconds. This brief delay allows the player to see both selected cards before
their comparison briefly.

4. The checkMatch() function evaluates whether the two selected cards match each other in the memory match game. Include given code after handle CardClick()
function.

function checkMatch() {
const [card1, card2] = selectedCards;
if (card1.dataset.color === card2.dataset.color) {
card1.classList. add('matched');
card2.classList. add( 'matched');
score += 2;
scoreElement. textContent = "Score: ${score} ;
} else {
card1. textContent = '?';
card2. textContent = '?';
card1.style.backgroundColor = "#ddd";
card2.style.backgroundColor = ' #ddd';
}
selectedCards = [];
}

Here's a detailed breakdown of the function:

o Destructuring selected cards:

" const [card1, card2] = selectedCards ;: This line uses array destructuring to assign the first two elements of the 'selectedCards' array to 'cardl' and
'card2'. These variables represent the two cards selected by the player for comparison.

<!-- PageBreak -->

· Comparing card colors:

" if (card1.dataset. color === card2. dataset. color) { ... }: This checks if the color value stored in the 'dataset.color' attribute of'cardl' matches the
color value of'card2'.

If the colors match: It adds the class 'matched' to both cards using 'classList. add('matched' )', marking them as matched pairs in the game.

Increases the 'score' by 2 points, as the player successfully matched a pair.

· Updates the 'scoreElement.textContent' to display the updated score to the player.

· Handling non-matching cards: If the colors of the two selected cards don't match, it resets the text content of both cards to a question mark ('?'), hiding their colors
again.

Sets the background color of both cards to a default color ('#ddd'), providing a visual cue that the selected cards didn't match.

· Resetting selection:

" selectedCards = [] ;: It clears the 'selectedCards' array to reset it for the next set of card selections. This action ensures the player can select two new
cards after the comparison.

5. The startGame() Function is a pivotal part of initializing and starting the memory match game. Include given code after checkMatch() function.

function startGame() {
let timeLeft = 30;
startbtn.disabled = true;
score = 0; // Reset score to zero
scoreElement. textContent = `Score: ${score} ;
startGameTimer(timeLeft);
cards = shuffle(colors.concat(colors));
selectedCards = [];
gameContainer.innerHTML = '';
generateCards();
gameContainer.addEventListener('click', handleCardClick);
}

Here's a summary of its functionalities:

· Setting initial game state:

let timeLeft = 30 ;: Initializes the 'timeLeft' variable to 30 seconds, setting the duration for the game.

" startbtn.disabled = true ;: Disables the 'startbtn' button to prevent multiple game initiations simultaneously, ensuring one game is in progress at a time.

" score = 0 ;: Resets the 'score' variable to zero, initializing it for the new game.

scoreElement.textContent = Score: ${score} ;: Updates the displayed score to show that it's reset to zero for the new game.

· Starting the game timer:

startGameTimer(timeLeft) ;: Initiates the game timer, counting down from the specified 'timeLeft' duration.

· Preparing cards and game elements:

" cards = shuffle(colors.concat(colors)) ;: Shuffles the 'colors' array and duplicates it to create pairs for the game cards.

selectedCards = [] ;: Clears the 'selectedCards' array to prepare for new card selections in the upcoming game.

gameContainer.innerHTML = '' ;: Clears the game container, removing any existing cards from previous games.

" generateCards() ;: Generates a new set of cards within the game container by calling the 'generateCards()' function, creating a fresh game layout for the
player.

· Enabling card click event:

"gameContainer. addEventListener('click', handleCardClick) ;: Adds an event listener to the game container, enabling card clicks and triggering the
'handleCardClick()' function to manage the gameplay when cards are clicked.

6. The startGame Timer(time Left) function manages the game timer, updating the displayed time and handling the end of the game when the timer reaches zero. Include
after startGame() Function.

function startGameTimer(timeLeft) {
timerElement. textContent = "Time Left: ${timeLeft} ;
gameInterval = setInterval(() => {
timeLeft --;
timerElement. textContent = "Time Left: ${timeLeft} ;
if (timeLeft === 0) {
clearInterval(gameInterval);
let timeLeft = 30;
alert('Game Over!');
startbtn.disabled = false;
}

<!-- PageBreak -->

}
}, 1000);

Here's a detailed explanation of its workings:

· Initial display:

" timerElement. textContent = Time Left: ${timeLeft} ;: Sets the initial display of the timer to show the 'timeLeft' value, indicating the starting time
remaining for the game.

· Interval setup:

" gameInterval = setInterval(() => { ... }, 1000) ;: Initiates an interval that triggers a function every second (1000 milliseconds) to update the timer.

· Countdown:

" timeLeft --;: Decrements the 'timeLeft' variable every second within the interval, simulating the countdown by reducing the remaining time.

· Updating displayed time:

" timerElement. textContent = Time Left: ${timeLeft} ;: Updates the displayed time on the HTML element ('timerElement') to reflect the updated
'timeLeft' value after each decrement.

· End of game:

" if (timeLeft === 0) { ... }: Checks if the remaining time reaches zero.

· If'timeLeft' equals zero:

clearInterval(gameInterval) ;: Stops the interval, effectively ending the timer from counting down further.

" let timeLeft = 30 ;: This line is redundant as it re-declares 'timeLeft' within the scope of this block, resetting it to 30, but it does not affect the 'timeLeft'
used in the interval.

" alert('Game Over!') ;: Displays an alert indicating that the game is over because the time limit has been reached.

" startbtn.disabled = false ;: Re-enables the 'startbtn' button, allowing the player to start a new game after the current one has ended.

7. Event listeners: To listen, click event startbtn adds an event listener to the 'startbtn' element, triggering the 'startGame' function when the button is clicked. Include the
given code at the end of javaScript file.

startbtn.addEventListener('click', startGame);

# Step 7: Check the output

1. Again check the output. It will be as shown below.

<!-- PageBreak -->

# Colorful Memory Match Game

Score: 0

Time Left: 30

Start/Restart

<table>
<tr>
<th>?</th>
<th>?</th>
<th>?</th>
<th>?</th>
</tr>
<tr>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
</tr>
<tr>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
</tr>
<tr>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
</tr>
<tr>
<td rowspan="2">?</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>?</td>
<td>?</td>
<td>?</td>
</tr>
<tr>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>

2. By clicking the Start/Restart button, you can start matching the colors! If the color matches, the score will update. The timer will also start as you click the
Start/Restart button.

<!-- PageBreak -->

## Colorful Memory Match Game

Score: 6

Time Left: 8

Start/Restart

<table>
<tr>
<th>?</th>
<th>?</th>
<th>?</th>
<th>?</th>
</tr>
<tr>
<td>?</td>
<td>?</td>
<td>blue</td>
<td>?</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>?</td>
<td>purple</td>
<td>?</td>
<td>?</td>
</tr>
<tr>
<td>blue</td>
<td>?</td>
<td>purple</td>
<td>?</td>
</tr>
<tr>
<td>?</td>
<td>red</td>
<td>?</td>
<td>red</td>
</tr>
<tr>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
</tr>
</table>

3. When the time has ended, it will generate a popup box to alert Game Over!

<!-- PageBreak -->

<figure>

127.0.0.1:5500 says

Game Over!

OK

Score: 6

Time Left: 1

Start/Restart

</figure>

<table>
<tr>
<th>?</th>
<th>?</th>
<th>?</th>
<th>?</th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>?</td>
<td>?</td>
<td>blue</td>
<td>?</td>
</tr>
<tr>
<td rowspan="2">?</td>
<td rowspan="2">purple</td>
<td></td>
<td></td>
</tr>
<tr>
<td>?</td>
<td>?</td>
</tr>
<tr>
<td>blue</td>
<td>?</td>
<td>purple</td>
<td>?</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>?</td>
<td>red</td>
<td>?</td>
<td>red</td>
</tr>
<tr>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
</tr>
</table>

5. Perform git add, git commit, and git push commands to update changes into your colorfulMemoryGame folder; GitHub repository for proper code management.

### Summary

1. HTML structure: Defines a game titled "Colorful Memory Match Game." It includes elements for the game grid, score, timer, and a start/restart button.

2. Styling: Applies CSS to create a visually appealing layout with specific colors, fonts, and button styles.

3. JavaScript functions:

· generateCards(): Creates card elements with colors for the game.

· shuffle(array): Randomizes the order of elements in an array.
o handleCardClick(event): Manages card clicks and checks for matches.
o startGame(): Resets the game, shuffles cards, and starts a timer.

4. Event listeners: Listens for clicks on the start/restart button to initialize the game. Listens for card clicks to reveal colors and check for matching pairs.

<!-- PageFooter="IBM Corporation 2023. All rights reserved." -->

---

Hands-on Lab: Debug a JavaScript Application in Chrome Dev Tools

Skills
Network

Estimated time needed: 15 minutes

## What you will learn

In this lab, you will gain an understanding of how to debug code in JavaScript. You will learn about try and catch blocks and gain insight into how and where to use these blocks
to make sure that your code is running smoothly.

## Learning objectives

After completing this lab, you will be able to:

· User input: Provides two input fields for users to enter numerical values.

· Operation execution: Multiplies the two input values when the "Perform Operation" button is clicked.

· Error handling: Checks if the entered values are valid numbers before performing the multiplication operation. If the values are not valid numbers, it displays an error
message instead of the result.

· Debugging: Includes a debugger statement within the multiply() function to pause execution and allow developers to inspect the code, variables, and execution flow using
browser Developer Tools.

## Prerequisites

· Basic knowledge of HTML.

· Basic understanding of console and debug.

· Web browser with a console (Chrome DevTools, Firefox Console, and so on).

## Step 1: Setting up the environment

1. Firstly, you need to clone your main repository in the Skills Network Environmemnt which you have created in the first lab and where you have pushed all of your
previous labs files and folders. Follow given steps:

· Click on the terminal in the top-right window pane and then select New Terminal.

<figure>

File Edit Selection View Go Rub

Terminal

Help

New Terminal

2

Ctrl+Shift+'

New Terminal (With Profile)

</figure>

· Perform git clone command by writing given command in the terminal.

git clone <github-repository-url>

Note: Put your own GitHub repository link instead of <github-repository-url>.

!
Problems
\>
theia@theia-richaar: /home/project x

theia@theia-richaar: /home/project$ git clone https://github.com/

o Above step will clone folder for your GitHub repository under project folder in explorer. You will also see multiple folders inside the cloned folder.

· Now, you need to navigate inside the cloned folder. For this, write the given command in the terminal:

cd <repository-folder-name>

<!-- PageBreak -->

<figure>

<!-- PageHeader="Replace this with your cloned folder name" -->
theia@theia-richaar: /home/project$ cd
jscoursetesting

</figure>

Note: Write your cloned folder name instead of <repository-folder-name>. Perform git clone if you have logged out of Skills Network Environment and you
cannot see any files or folder after you logged in.

2. Now select cloned Folder Name folder, right-click on it and click on New Folder. Enter folder name as DebugCode. It will create the folder for you. Then select
DebugCode folder, right-click and select New File. Enter file named as debug_code.html and click OK. It will create your HTML file.

3. Create a basic template structure of an HTML file by adding content provided below.

<! DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Debugging Example</title>
</head>
<body>
<h1>Debugging Example</h1>
<label for="input1">Enter Number 1 :</ /label>
<input type="number" id="input1"><br><br>
<label for="input2">Enter Number 2 :</ /label>
<input type="number" id="input2"><br><br>
<button onclick="performOperation()">Perform Operation</button>
<p id="result"></p>
</body>
</html>

Note: After pasting the code, save your file.

4. Now select the DebugCode folder again, right-click, and select New File. Enter the file named debug_code.js and click OK. This action will generate your JavaScript
file.

5. To include js file in debug_code.html, use the script tag in the HTML file above the </body> tag. You can use the given code to include and save the script file.
<script src="./debug_code.js"></script>

## Step 2: Defining variables

1. Include given code in debug_code.js file.

function performOperation() {
// Get user input from input fields
let num1 = parseInt(document.getElementById('input1').value);
let num2 = parseInt(document.getElementById('input2'). value);
// Check if inputs are valid numbers
if (!isNaN(num1) && ! isNaN(num2)) {
// Perform the operation
let result = multiply(num1, num2);
// Display the result
displayResult(result);
} else {
displayResult('Please enter valid numbers');
}
}
function multiply(a, b) {
// Introduce a debugger statement to pause execution
debugger;
// Multiply the numbers
return a * b;
}
function displayResult(result) {
// Display the result in the paragraph element
const resultElement = document. getElementById('result');
resultElement. textContent = `The result is: ${result} ;
}

<!-- PageBreak -->

2. Above code has following parts:

· performOperation() Function:

Retrieves numerical values entered by the user from HTML input fields (input1 and input2).

Validates that the entered values are valid numbers.

" Ifboth values are valid numbers, it calls the multiply() function passing these values, otherwise, it displays an error message.

· multiply() Function:

· Includes a debugger statement to pause code execution at this point for debugging purposes.

Multiplies two input numbers (a and b) and returns the result.

· displayResult() Function:

" Displays the result of the multiplication or an error message in a designated paragraph element (resultElement) on the webpage.

### Step 3: Debug the code to see the flow of the code

1. To view how your HTML page, right-click the debug_code.html file after selecting this file, then select "Open with Live Server".

2. The server should start on port 5500, indicated by a notification on the bottom right side.

<figure>

i
Server is Started at port : 5500

X

Don't show again

</figure>

3. Click on the Skills Network button on the left (refer to number 1), it will open the "Skills Network Toolbox". Then click on the Launch Application (refer to number 2).
From there you enter the port no. as 5500 at number 3 and click on this button
77
.

<figure>

File Edit Selection View Go Run Terminal Help

SKILLS NETWORK TOO
5

?

Launch Application X

\> DATABASES

\> BIG DATA

Launch Your Application

\> CLOUD

V OTHER

7 Launch Application

2

. To open any application in the browser, please select or enter
the port number below.

Open Link inside IDE

C

Open Cloud IDE with Open ...

Application Port

3

Open Cloud IDE Basic

& Suggest a feature or submi ...

Your Application

About Cloud IDE

A

1

</figure>

4. It will open your default browser where you will see cloned-folder-name folder name. After clicking you will see multiple folders name, among those folders name click on DebugCode folder. You will see files related to this folder where again you will click on debug_code.html file as shown
below.

<!-- PageBreak -->

<figure>

<!-- PageHeader="debug_code.html" -->

</figure>

debug_code.js

Note: Save your file after pasting the code. If you edit your code, refresh your browser on port 5500. No need to relaunch the application.

5. You will see the output as below.

# Debugging Example

Enter Number 1:

Enter Number 2:

Perform Operation

6. Now enter the numbers in input boxes available and click on "Perform Operation" button.

7. Now to see the flow of this code, right-click in the same window of your browser where output is being displayed and then select "Inspect."

8. As soon as you click on the button, you will see the screen like as if it has paused, just like in the given screenshot. Also, value number 1 highlighted in red box in the
screenshot shows that two numbers has been recived in variables a and b. Along with that, number 2 indicate where the pause has happened at debugger point, which is
the current pointer of your code.

<figure>

Paused in debu ...

\-

Welcome

Elements

Console

Debugging
Example

V

:

\+

more.html

☑

LI

top

mums - parque
let num2 = parseInt (document

22

Enter Number 1:

127.0.0.

23

12

24

// Perform the operatior
let result = multiply (nt

more.

25

Enter Number 2:

26

27

// Display the result
displayResult(result);

13

28

29

}

Perform Operation

30

31

function multiply(a, b) {
a =

LL Introduce a debugger stat

32

33

2

debugger;

34

35

// Multiply the numbers
return a * b;
}

36

37

38

39

function displayResult(result) {
// Display the result in the
const resultElement = docume
resultElement. textContent =

40

41

42

43

}

</script>

44

7 .

{ }
Line 33, Column 13 Coverage: n/a

</figure>

9. Then you need to click the forward arrow highlighted with a red box in given screenshot.

<!-- PageBreak -->

Games Area

X
☑
Debugging Example

X
☑

\+

i
127.0.0.1:5501/more.html

## Paused in debu ... Debugging Example

=

Welcome

Elements

Console

V

\+

☑
more.html

T7

top

det num - par sulumen
let num2 = parseInt (documen

22

Enter Number 1:

127.0.0.

23

24

// Perform the operatio
let result = multiply(n

12

more.

25

Enter Number 2:

26

27

13

// Display the result
displayResult(result);
}

28

29

Perform Operation

30

31

function multiply(a, b) { a =
// Introduce a debugger sta
debugger;

32

33

34

35

// Multiply the numbers
return a * b;
}

36

37

38

39

function displayResult(result)
// Display the result in th
const resultElement = docum
resultElement. textContent =

40

41

42

43

}

</script>

44

1 .

{ }
Line 33, Column 13 Coverage: n/a

Console

Issues

\+

1
21°℃

Sunny

Search

10. As soon as you will click on that button, your current pointer will move to the return a*b, indicating that the flow of the code has now reached to this point.

<!-- PageBreak -->

<table>
<tr>
<th colspan="2">Paused in debu ...</th>
<th></th>
<th colspan="3">Welcome</th>
<th></th>
<th>Elements Console 7</th>
</tr>
<tr>
<th colspan="2">Debugging</th>
<th>V :</th>
<th>€</th>
<th></th>
<th></th>
<th>more.html</th>
<th>☑</th>
</tr>
<tr>
<td colspan="2">Example</td>
<td>top</td>
<td>22 T7</td>
<td></td>
<td></td>
<td>- let num2 = parseInt (document</td>
</tr>
<tr>
<td colspan="2">Enter Number 1:</td>
<td>127.0.0.</td>
<td>23</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td colspan="2">12</td>
<td>more.</td>
<td>24 25</td>
<td></td>
<td></td>
<td>// Perform the operation let result = multiply (nu</td>
</tr>
<tr>
<td colspan="2"></td>
<td></td>
<td>26</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td colspan="2">Enter Number 2:</td>
<td></td>
<td>27</td>
<td colspan="2"></td>
<td>// Display the result</td>
</tr>
<tr>
<td colspan="2">13</td>
<td></td>
<td>28</td>
<td></td>
<td>// Display the result</td>
</tr>
<tr>
<td colspan="2"></td>
<td></td>
<td>29</td>
<td></td>
<td></td>
<td>}</td>
</tr>
<tr>
<td colspan="2">Perform Operation</td>
<td></td>
<td>30</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td colspan="2"></td>
<td></td>
<td>31</td>
<td></td>
<td></td>
<td>function multiply(a, b) { a = 1</td>
</tr>
<tr>
<td colspan="2"></td>
<td></td>
<td>32</td>
<td colspan="2"></td>
<td>// Introduce a debugger stat</td>
</tr>
<tr>
<td colspan="2"></td>
<td></td>
<td>33</td>
<td></td>
<td></td>
<td>debugger;</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>34</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>35</td>
<td colspan="2"></td>
<td>// Multiply the numbers</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>36</td>
<td></td>
<td></td>
<td>return a * b;</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>37</td>
<td></td>
<td></td>
<td>}</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>38</td>
<td colspan="2"></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>39</td>
<td colspan="2"></td>
<td>function displayResult(result) {</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>40</td>
<td colspan="2"></td>
<td>// Display the result in the</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>41</td>
<td colspan="2"></td>
<td>const resultElement = docume</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>42</td>
<td></td>
<td></td>
<td>resultElement. textContent =</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>43</td>
<td></td>
<td></td>
<td>}</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>44</td>
<td colspan="3"></td>
<td>&lt;/script&gt;</td>
</tr>
</table>

<figure>
</figure>

11. Click the forward button again, and the pointer will move towards number 1 in the given screenshot, indicating that the displayResult() function is called. Also number 2
indicate num1 and num2 has 12 and 13 values respectivly.

<figure>

"esult"</p>

.

\>

ction performOperation() {
2
// Get user input from input fields
let num1 = parseInt(document.getElementById('input1') .value);
num1 = 12
let num2 = parseInt(document.getElementById('input2') . value);
num2 = 13

// Perform the operation
let result = multiply(num1, num2);
result = 156, num1 = 12, num2=

<!-- PageBreak -->

// Display the result

3

displayResult(result);
1

</figure>

ction multiply(a, b) {
// Introduce a debugger statement to pause execution
debugger;

// Multiply the numbers
return a * b;

-tion dienlow Docult ( nochl+ ) S

<!-- PageBreak -->

12. Again click on forward button and the pointer will move to number 1 in given screenshot, indicating that it is now trying to access the element whose ID is result. Also
result variable has the awnswer to the multiplication.

<figure>

"esult"</p>

A

</figure>

function multiply(a, b) {
// Introduce a debugger statement to pause execution
debugger;
// Multiply the numbers
return a * b;
}
function displayResult(result) {
result = 156
2
LL Display the result in the paragraph element
1
const resultElement = document.getElementById('result');
resultElement . textContent = The result is: >{result} ;
}
</script>
-- Code injected by live-server -- >

;cript>
// <! [CDATA[ <-- For SVG support
if ('WebSocket' in window) {
(function () {
function refreshCSS() {
var sheets = [] . slice. call(document. getElementsByTagName (
var head = document.getElementsByTagName("head") [0];

13. Click the forward button again, and the pointer will shift towards number 1 in the screenshot, indicating that it has included the result in that element using textContent.

function multiply(a, b) {
// Introduce a debugger statement to pause execution
debugger;
// Multiply the numbers
return a * b;
}

resu

function displayResult(result) {
result = 156
// Display the result in the paragraph element
const resultElement - document . getelementbyid('result'),
resultElement. textContent = `The result is: ${result} ;
}
</script>
-- Code injected by live-server -- >
icript>
<!-- PageBreak -->

// <! [CDATA[ <-- For SVG support
if ('WebSocket' in window) {
(function () {
function refreshCSS() {
var sheets = [] . slice. call(document. getElementsByTagName ("head"))
var head = document.getElementsByTagName("head") [0];

14. Then, click on the forward button again, and the pointer will go to number 1, indicating that the button has been clicked, and it will also show the result at number 2 in
given screenshot.

<!-- PageBreak -->

<table>
<tr>
<th rowspan="2">Paused in deb .. Debugging</th>
<th></th>
<th colspan="2">Welcome Elements Console Öğ si</th>
</tr>
<tr>
<th>V ,</th>
<th>+</th>
<th>more.html X</th>
</tr>
<tr>
<td>Example</td>
<td>top</td>
<td>4</td>
<td>&lt;head&gt;</td>
</tr>
<tr>
<td>Enter Number 1:</td>
<td>127.0.0.</td>
<td>5</td>
<td>&lt;meta charset="UTF-8"&gt;</td>
</tr>
<tr>
<td>12</td>
<td></td>
<td>6</td>
<td>&lt;title&gt;Debugging Example&lt;/title&gt;</td>
</tr>
<tr>
<td>more.</td>
<td>7</td>
<td>&lt;/head&gt;</td>
</tr>
<tr>
<td></td>
<td></td>
<td>8</td>
<td></td>
</tr>
<tr>
<td>Enter Number 2:</td>
<td></td>
<td>9</td>
<td>&lt;body&gt;</td>
</tr>
<tr>
<td>13</td>
<td></td>
<td>10</td>
<td>&lt;h1&gt;Debugging Example&lt;/h1&gt;</td>
</tr>
<tr>
<td></td>
<td></td>
<td>11</td>
<td>&lt;label for="input1"&gt;Enter Number 1 :&lt; /lab</td>
</tr>
<tr>
<td>Perform Operation</td>
<td></td>
<td>12</td>
<td>&lt;input type="text" id="input1"&gt;&lt;br&gt;&lt;br&gt;</td>
</tr>
<tr>
<td></td>
<td></td>
<td>13</td>
<td>&lt;label for="input2"&gt;Enter Number 2 :&lt; /lab</td>
</tr>
<tr>
<td>The result is: 156</td>
<td></td>
<td>14</td>
<td>&lt;input_type="text" id="input2"&gt;&lt

### Transcrições dos PDFs anexados

### download13.pdf
Cheatsheet: Introduction to JavaScript Development

JavaScript Tag and Terminologies | Description | Code Example
---|---|---
<script> <script src> | Used to include the required JavaScript code in your HTML document. Used to link the required JavaScript files in your HTML document. | <body> <p id="showname"></p> <script> document.getElementById('showname').innerHTML='Peter'; </script> </body> <script_src="script.js"></script>
var | var is a keyword used to declare variables. | var num1=10; var num2=11;
var & Scope |  | <! DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Document</title> </head> <body> <p id="showname"></p> <script> function show() { var name = 'Peter'; document.getElementById('showname').innerHTML = name; </script> } </body> </html>
var has functional scope, allowing variable to be accessed within function only. | 
let | let is a keyword used to declare variables. | let num1=20; let num2=21;
let & Scope | let has block scope, allowing the variable to be limited to the block, statement, or expression in which it is defined, | <! DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Document</title> </head>

preventing redeclaration within the same scope. |  | <body> <p id="showemail"></p> <script>
{ let emailId = 'test@example.com'; document.getElementById('showemail'). innerHTML = emailId; } </script> </body> </html>

const | const is a keyword used to declare variables. | const employeeId=120; cont employeeId=121;

 |  | <! DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Document</title> </head> <body> <p id="showeEId"></p> <script>

const & Scope | It creates a constant whose value cannot be reassigned or redeclared. | { const employeeId = 120'; document.getElementById('showeEId').innerHTML = employeeId; </script> } </body> </html>

Arithmetic Operators | Arithmetic operators perform mathematical calculations like addition, subtraction, multiplication, division and modulus. | let x = 15; let y = 3; let sum = x + y; // Addition console. log(sum) //the answer is 8 let difference = x - y; // Subtraction console. log(difference) //the answer is 2 let product = x * y; // Multiplication console. log(product) //the answer is 8 let quotient = x / y; // Division console. log(quotient) //the answer is 8 let remainder = x % y; // Modulus console.log(remainder) //the answer is 0
Comparison Operators | Comparison operators compare values and return true/false based on the comparison. | let a = 5; let b = 7; let isEqual = a == b; // Equality let isNotEqual = a != b; // Inequality let isStrictEqual = a === b; // Strict equality let isGreaterThan = a > b; // Greater than

Logical Operators | Logical operators combine multiple conditions and return a boolean result. | let hasPermission = true; let isMember = false; let canAccessResource = hasPermission && isMember; // Logical AND let canViewPage = hasPermission || isMember; // Logical OR let isDenied = ! hasPermission; // Logical NOT
Assignment Operators | Assignment operators assign values to variables. For example, =, +=, -=. | let x = 10; // Assigns the value 10 to the variable x x += 5; // Equivalent to x = x + 5 x -= 5; //Equivalent to x = x + 5
Unary Operators | Unary operators act on a single operand, performing operations like negation or incrementing. | let count = 5; count++; // Increment count by 1 (count is now 6) count --; // Decrement count by 1 (count is now 5 again)
typeof Operator | typeof operator returns the data type of a variable or expression as a string. | let num1 = 42; console. log(typeof(num1)); //the awnswer is Number let name = 'John'; console. log(typeof(name)); //the awnswer is String
if Statement | The if statement is used to execute a piece of block code if the given condition is true. | let age = 25; if (age >= 18) { console. log("You are an adult."); } else { console. log("You are a minor."); }
else if Statement | It allows you to test multiple conditions sequentially. If the condition is true then it will execute if statement block otherwise execute else statement block. | <! DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Document</title> </head> <body> <p id="seasonmessage"></p> <script> let Seasonmonth = 'March to May'; if (Seasonmonth == 'March to May') { document . getElementById("seasonmessage") = 'It is spring season'; } else if (Seasonmonth == 'June to August') { document . getElementById("seasonmessage") ='It is summer season'; } else if (Seasonmonth == 'September to November') { document . getElementById("seasonmessage") = 'It is autumn season';

} else { document.getElementById("seasonmessage") = 'It is winter season'; } </script> </body> </html>

This statement allows you to test multiple conditions and execute different blocks of code based on the results of those conditions. | const temperature = 30; const isRaining = true; if (temperature > 30) { if (isRaining) { } else { console. log("It's hot and raining. Stay inside."); console. log("It's hot, but not raining. Enjoy the sunshine."); }

Nested if else Statement | } else { if (isRaining) { } else { console. log("It's not so hot, but it's raining. Take an umbrella."); console. log("It's not hot, and it's not raining. Have a nice day."); } } 
switch Statement | The switch statement is used for multiple conditional branches, allowing the execution of different code blocks based on the value of an expression. | let month = "December"; switch (day) { case "December": console.log("It's Christmas month."); break; case "November": console.log("It's Thanksgiving month"); break; default: console. log("It's a regular month."); }
Ternary Operator | The ternary operator is the simplest way to write conditional statements such as if else condition. | let age = 20; let canVote = age >= 18 ? "Yes" : "No";
for loop | A for loop is a control structure that allows to execute a block of code repeatedly for a specified number of times until a particular condition is met. | for (let i = 1; i <= 5; i++) { console.log(i); }
While loop | A while loop is a control structure that allows to execute a block of code repeatedly as long as a specified condition is true. | let limit = 50; let a = 0; let b = 1; while (a <= limit) { console. log(a); let temp = a + b; a = b; b = temp; }
do while loop | A "do ... while" loop in allows you to execute a block of code repeatedly as long as a specified condition is true and guarantees that the code block will execute at least once, even if the condition is initially wrong. | let roll = 1; do { console. log("Rolled a " + roll); roll++; } while (roll < 7);
Function Declaration and Call | Function is a reusable block of code that can be defined and executed as many times as needed. | function sayHello() { console.log("Hello!"); } //function declaration sayHello(); //function call
Non-Parameterized Functions | The functions that do not require any parameters to operate. | function greet() { const greeting = "Hello, World!"; console.log(greeting); } // Call the non-parameterized function greet(); // This will print "Hello, World!" to the console
Parameterized Functions | The function that accepts one or more values that provide input data for the function to work with. These values in the function's declaration called parameters, and during calling of the function called arguments. | <! DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Document</title> </head> <body> <p_id="functiondata1"></p> <script> function add(a, b) { return a + b; document.getElementById('functiondata1').innerHTML = add(3, 4); } </script> </body> </html>
Named Function | The functions with a specific name that can be called by that | const add = function(a, b) { console. log(a+b); }

//name of the function is add add(2, 3);

IIFE | Immediately Invoked Function Expression is a function in JavaScript that's defined and executed immediately after its creation. | (function sayWelcome() { })(); console.log("Welcome!");
Arrow Function | Arrow functions in JavaScript are a concise way to write function expressions, using the => syntax. | const arrowFunc = (a, b) => a + b; console.log(arrowFunc(5, 3));

return | The return statement in JavaScript is used to end the execution of a function and specify the value that the function should return to the caller. | <script> function multiply(message) { return message; // Returns the product of a and b document. getElementById('showmessage' ) . innerHTML = multiply('Hard work is the key'); } </script> </body> </html>
Function Closure Function Hoisting | A function closure in JavaScript allows a function to access and remember variables from its outer scope even after that scope has finished executing. Function hoisting means that function declarations are moved to the top of their containing scope during the compile phase, allowing them to be used before they are declared in the code. | function outerFunction() { const outerVar = "I am from the outer function"; function innerFunction() { console. log(outerVar); // innerFunction can access outerVar return innerFunction; } const closure = outerFunction(); } closure(); // This will log "I am from the outer function" sayHello(); // This works even though the function is called before it's declared function sayHello() { console.log("Hello!"); }

Function Hoisting for function expression | Function expressions where a function is assigned to a variable do not exhibit hoisting behaviour. | greet(); // This will result in an error const greet = function() { console. log("Greetings!"); };
addEventListener | addEventListener is a JavaScript method used to assign a function to execute when a specific event occurs on an element in the DOM. | <! DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Document</title> </head> <body> <p id="btnclick"></p> <button id="btn">Click Me</button> <script> // Get the element by its ID const button = document.getElementById('btn'); // Add an event listener for the 'click' event button.addEventListener('click', () => { document.getElementById('btnclick' ) . innerHTML = 'Button clicked!'; }); </script> </body> </html>
onclick Event | A way of assigning a function directly to an HTML element to execute when it's clicked. | <! DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Document</title> </head> <body> <button onclick="myFunction()">Click me</button> <script> function myFunction() { alert('Button clicked!');

} </script> </body> </html>
Mouseover Event | The mouseover event is triggered when the mouse cursor enters an element. | <! DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Document</title> </head> <body> <div id="myDiv" style="width: 200px; height: 200px; background-color: lightblue;"></div> <script> const myDiv = document. getElementById('myDiv'); // Adding a mouseover event listener myDiv.addEventListener('mouseover', () => { myDiv. style.backgroundColor = 'lightgreen'; }); </script> </body> </html>
mouseout Event | The mouseout event in JavaScript is triggered when the mouse pointer moves out of an element, indicating that the mouse is no longer over that specific element. | <! DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Document</title> </head> <body> <div id="myDiv" style="width: 200px; height: 200px; background-color: lightblue;"></div> <script> const myDiv = document.getElementById('myDiv'); // Adding a mouseover event listener myDiv.addEventListener('mouseover', () => { myDiv.style.backgroundColor = 'lightgreen'; myDiv.addEventListener('mouseout', () => { }); myDiv.style. backgroundColor = 'lightcoral'; }); </script> </body> </html>
Keydown Event | The keydown event is triggered when a key on the keyboard is pressed down. | <! DOCTYPE html> <html> <head> <title>Keydown Event Handling</title> </head> <body> <input type="text" id="myInput"> <p id="output"></p> <script> const input = document.getElementById("myInput"); const output = document.getElementById("output"); input. onkeydown = function(event) { output. textContent = `Key pressed: ${event.key}}; }; </script> </body> </html>
Change Event | The change event is triggered when the value of an input element changes. Typically, it's used for form elements like text fields or dropdowns. | <! DOCTYPE html> <html> <head> <title>Change Event Handling</title> </head> <body> <input type="text" id="myInput"> <p id="output"></p> <script> const input = document.getElementById("myInput"); const output = document.getElementById("output"); input. onchange = function() { output. textContent = "Value changed to: ${input. value}}; }; </script> </body> </html>
onsubmit Event | The onsubmit event in HTML occurs when a form is submitted, either by clicking a | <! DOCTYPE html> <html> <head> <title>Form Submission Example</title>
 | submit button or by calling the submit(). | </head> <body> <form id="myForm" onsubmit="validateForm()"> <label for="name">Name :< /label> <input type="text" id="name" name="name"><br><br> <label for="email">Email :< /label> <input type="email" id="email" name="email"><br><br> <input type="submit" value="Submit"> </form> <script>
function validateForm() { // Prevent the default form submission event.preventDefault(); // Retrieve form values const name = document. getElementById('name' ) . value; const email = document.getElementById('email').value; // Perform validation (for example, checking if fields are filled) if (name === '' || email === '') { alert('Please fill in all fields. '); return false; // Prevent form submission if validation fails
} // If validation passes, continue with form submission alert('Form submitted successfully!');
} </script> </body> </html>

Skills Network *

---

### download14.pdf
Hands-on Lab: Develop Product Feedback Survey Form Using Events

Skills Network

Estimated time needed: 30 minutes

What You Will Learn
In this lab, you will learn how to create a user feedback form for a luxury brand's products using HTML and JavaScript. You will discover how to design a structured form to collect diverse user information such as name, age, email, job, and product feedback. You will see how to use the JavaScript functions to manage form submission, capture input values, and dynamically display user-provided feedback on the webpage. You will also observe event handling mechanisms.

Learning objectives
After completing this lab, you will be able to:
- Form handling and user input capture: Explore the process of creating an interactive form using HTML elements, such as text inputs, select options, and text areas, to collect diverse user information, including name, age, email, job, product feedback, and more.
- DOM manipulation with JavaScript: Learn how JavaScript interacts with the Document Object Model (DOM) to retrieve input values from form elements and dynamically update the webpage content. This includes modifying the display style of an HTML element and populating its content based on user input.
- Event handling and user interactions: Explore event handling mechanisms in JavaScript, specifically the implementation of event listeners for button clicks and Enter key presses to trigger actions, such as submitting the form data and displaying feedback dynamically, providing a seamless user experience.
- User interface interaction design: Analyse the importance of presenting collected user information in a readable format on the webpage. Learners will gain insights into dynamically displaying user-provided feedback in a structured manner within the webpage, enhancing the overall user interface and experience.

Prerequisites
- Basic Knowledge of HTML.
- Basic understanding of events and function in javaScript.
- Web browser with a console (Chrome DevTools, Firefox Console, and so on).

Step 1: Setting up the environment
1. Clone repository, create folder productSurvey, files product_survey.html and product_survey.js.
2. product_survey.html template:
<! DOCTYPE html>
<html>
<head>
<title>Luxury Brand Feedback</title>
</head>
<body>
<h1>Welcome to Luxury Brand Products Feedback</h1>
<h2>Provide Your Feedback</h2>
<label for="name">Name : </label><br>
<input type="text" id="name" placeholder="Your Name" required><br>
<label for="age">Age : </label><br>
<input type="number" id="age" placeholder="Your Age" required><br>
<label for="email">Email : </label><br>
<input type="email" id="email" placeholder="Your Email" required><br>
<label for="job">Job : </label><br>
<input type="text" id="job" placeholder="Your Job" required><br>
<label for="designation">Designation : </label><br>
<input type="text" id="designation" placeholder="Your Designation" required><br>
<label for="productType">Product Type : </label><br>
<select id="productType" required>
<option value="perfume">Perfume</option>
<option value="cream">Cream</option>
<option value="oils">Oils</option>
</select><br>
<label for="feedbackText">Feedback : </label><br>
<textarea id="feedbackText" rows="5" cols="30" placeholder="Enter your feedback here" required></textarea><br>
<button id="submitBtn">Submit Feedback</button>
<hr>
<div id="userInfo" style="display: none;">
<h2>User Information :</h2>
<p>Name: <span id="userName"></span></p>
<p>Age: <span id="userAge"></span></p>
<p>Email: <span id="userEmail"></span></p>
<p>Job: <span id="userJob"></span></p>
<p>Designation: <span id="userDesignation"></span></p>
<p>Feedback for <span id="userProductChoice"></span>: <span id="userFeedback"></span></p>
</div>
<script src="./product_survey.js"></script>
</body>
</html>

Notes: dynamic display, hidden section becomes visible after submission.

Step 2: Defining variables and function
- Create submitFeedback() in product_survey.js.
- Retrieve values:
const username = document.getElementById('name').value;
const age = document.getElementById('age').value;
const email = document.getElementById('email').value;
const job = document.getElementById('job').value;
const designation = document.getElementById('designation').value;
const productType = document.getElementById('productType').value;
const feedback = document.getElementById('feedbackText').value;
- Get submit button: const submitButton = document.getElementById('submitBtn');
- Assign onclick: submitButton.onclick = submitFeedback;
- Alert after submit: alert('Thank you for your valuable feedback')

Step 3: Display user feedback on webpage
- Inside submitFeedback(), set innerHTML:
document.getElementById('userName').innerHTML = username;
document.getElementById('userAge').innerHTML = age;
document.getElementById('userEmail').innerHTML = email;
document.getElementById('userJob').innerHTML = job;
document.getElementById('userDesignation').innerHTML = designation;
document.getElementById('userProductChoice').innerHTML = productType;
document.getElementById('userFeedback').innerHTML = feedback;
- Make userInfo visible:
document.getElementById('userInfo').style.display = 'block';

Step 4: Implement key press to submit feedback
document.addEventListener('keydown', function(event) {
  if (event.key === 'Enter') {
    submitFeedback();
  }
});

Step 5: Check output and Live Server instructions, git add/commit/push steps.
Practice task: add another textarea with id='userExperince' to gather user experience and display it similarly.

Summary: form elements, dynamic display, visibility toggle, event listeners for click and Enter.

---

### download15.pdf
Hands-on Lab: Develop Followers Count Milestone Alerts Using Functions

Skills Network

Estimated time needed: 20 minutes

What you will learn
Create a follower counter for an Instagram post and simulate increasing followers. Manage a count variable, update UI elements, trigger actions at milestones.

Learning objectives
- Variables and incrementation: store and modify count
- Updating web content: display follower counts dynamically
- Conditional statements: trigger messages at milestones (10, 20)
- Function usage: organize incrementation, display, checks

Prerequisites: basic HTML and Git, functions.

Step 1: Setup
- Create folder followers Count with followers_count.html and followers_count.js
followers_count.html:
<! DOCTYPE html>
<html>
<head>
<title>Interactive Counter</title>
</head>
<body>
<h1>Interactive Counter</h1>
<h2>Account Holder Name: Peter Parker</h2>
<p>Followers: <span id="countDisplay">0</span></p>
<hr>
<h2>Click one button to follow</h2>
<button onclick="increaseCount()">Follow</button>
<script src="./followers_count.js"></script>
</body>
</html>

Step 2: Variables and functions
- Initialize count: let count = 0;
- increaseCount():
function increaseCount() {
  count++; // increment
  displayCount();
}
- displayCount():
function displayCount() {
  document.getElementById('countDisplay').innerHTML = count;
}

Step 3: Milestone alerts
function checkCountValue() {
  if (count === 10) {
    alert("Your Instagram post gained 10 followers! Congratulations!");
  } else if (count === 20) {
    alert("Your Instagram post gained 20 followers! Keep it up!");
  }
}
- Call checkCountValue() inside increaseCount().

Step 4: Check output and Live Server, git steps.
Practice task: add Reset Count button and function to reset count to 0 and alert.

Summary: HTML structure, functions for increment/display/check milestones.

---

### download16.pdf
Hands-on Lab: Writing Your First JavaScript Function

Skills Network

Estimated time needed: 30 minutes

What you will learn
Use functions to build an interactive web app that calculates area of a rectangle.

Learning objectives
- Understand HTML structure and inputs
- JS variable declaration
- Retrieving user input
- Implementing and executing functions

Prerequisites: HTML, JS basics.

Step 1: Setup
- Create calculate_Area.html and calculate_Area.js
calculate_Area.html:
<html>
<head>
<title>Rectangle Area Calculator</title>
</head>
<body>
<h1>Rectangle Area Calculator</h1>
<label for="length">Enter the length: </label>
<input type="number" id="length"><br><br>
<label for="width">Enter the width: </label>
<input type="number" id="width"><br><br>
<button onclick="calculateArea()">Calculate Area</button><br><br>
<p id="result"></p>
<script src="./calculate_Area.js"></script>
</body>
</html>

Step 2: JS
let length;
let width;
function calculateArea() {
  length = parseFloat(document.getElementById('length').value);
  width = parseFloat(document.getElementById('width').value);
  let area = length * width;
  document.getElementById('result').innerText = `The area of the rectangle is: ${area}`;
}

Git steps and Live Server instructions included.

Practice task: groceryTracker to sum three grocery amounts.

Summary: setup, variables, calculation, display.

---

### download8.pdf
Cheatsheet: Arrays and Objects in JavaScript

Array declaration and indexing examples:
const fruits = ["apple", "banana", "cherry"];
const firstFruit = fruits[0]; // "apple"
Array length: fruits.length // 3
Arrays mutable: fruits[2] = "strawberry"; fruits[3] = "Kiwi";

push/pop/shift/unshift/splice examples:
fruits.push("orange","strawberry");
const removedFruit = fruits.pop();
fruits.unshift("apple","strawberry");
fruits.splice(1,1,"grape");

concat/slice/indexOf/reverse/sort:
const combinedFruits = fruits.concat(additionalFruits);
const slicedFruits = fruits.slice(1,3);
const index = fruits.indexOf("banana");
fruits.reverse();
numbers.sort((a,b)=>a-b);

Iteration:
for loop, forEach, map examples:
const users = [ {name:'Alice', email:'alice@example.com'}, ... ];
users.forEach(user => sendWelcomeEmail(user.email));
const products = [...]; products.map(product => console.log(...));

filter/reduce/find:
filterProductsByPriceRange(products,min,max) uses filter.
orderPrices.reduce((total,price)=>total+price,0)
employees.find(e=>e.id===2)

2D arrays, seating chart example with CSS/JS, booking functions, randomness.

Classes and objects:
class Person { constructor(firstName,lastName){...} getFullName() {...} }
Object literals, function constructors, dot and bracket notation.

Arrays of objects: access, add/remove, filter/map examples.

Strings, template literals, concatenation, length, char access, toLowerCase/toUpperCase, indexOf/includes/substring/slice/substr/replace/split/trim.

Math methods: round/ceil/floor/pow/sqrt/log/random with random quote generator sample.

Date object: new Date(), getFullYear/getMonth/getDate/getHours/getMinutes/getSeconds, toLocaleDateString(), arithmetic, setTimeout, setInterval usage.

---

### download4.pdf
Hands-on Lab: Develop Colorful Memory Match Game Using JavaScript DOM

Skills Network

Estimated time needed: 30 minutes

What you will learn
Build memory matching game with dynamic card generation, event handling, scoring, timer, restart.

Learning objectives: DOM manipulation, event handling, game logic, array shuffling.

Prerequisites: Basic HTML/Git.

Steps:
- Create folder colorfulMemoryGame with colorful_memory_game.html, colorful_memory_game.js, colorfulGame.css.
- HTML template includes container, game-container (cards generated dynamically), score and timer, Start/Restart button and script include.
- JS: initialize colors array and shuffle to create cards; selectedCards, score, timeLeft, gameInterval variables.
- generateCards() creates card divs with class 'card' and dataset.color and textContent '?'.
- shuffle() implements Fisher-Yates shuffle.
- handleCardClick(event) reveals card, sets backgroundColor, pushes to selectedCards; if two selected, setTimeout(checkMatch,500).
- checkMatch() compares dataset.color of two selected cards; if match, add class 'matched', increment score, update scoreElement; else reset textContent and backgroundColor; clear selectedCards.
- startGame() resets timeLeft=30, disables start button, score=0, startGameTimer(timeLeft), shuffles cards, clears gameContainer, generateCards(), addEventListener('click', handleCardClick).
- startGameTimer(timeLeft) sets interval to decrement timeLeft each second, update timerElement, clearInterval when 0, alert 'Game Over!', enable startbtn.
- startbtn.addEventListener('click', startGame);

Check output via Live Server and instructions. Git add/commit/push steps.

Summary of HTML, CSS, JS functions: generateCards, shuffle, handleCardClick, startGame; event listeners.

---

### download7.pdf
Hands-on Lab: Debug a JavaScript Application in Chrome Dev Tools

Skills Network

Estimated time needed: 15 minutes

What you will learn
How to debug JS, try/catch, debugger statement, inspect variable flow.

Setup:
- Create folder DebugCode with debug_code.html and debug_code.js.
debug_code.html:
<! DOCTYPE html>
<html lang="en">
<head><meta charset="UTF-8"><title>Debugging Example</title></head>
<body>
<h1>Debugging Example</h1>
<label for="input1">Enter Number 1 :</label>
<input type="number" id="input1"><br><br>
<label for="input2">Enter Number 2 :</label>
<input type="number" id="input2"><br><br>
<button onclick="performOperation()">Perform Operation</button>
<p id="result"></p>
<script src="./debug_code.js"></script>
</body>
</html>

debug_code.js:
function performOperation() {
  let num1 = parseInt(document.getElementById('input1').value);
  let num2 = parseInt(document.getElementById('input2').value);
  if (!isNaN(num1) && !isNaN(num2)) {
    let result = multiply(num1,num2);
    displayResult(result);
  } else {
    displayResult('Please enter valid numbers');
  }
}
function multiply(a,b) {
  debugger;
  return a*b;
}
function displayResult(result) {
  const resultElement = document.getElementById('result');
  resultElement.textContent = `The result is: ${result}`;
}

Instructions to open Live Server, inspect, use debugger pause and step through code; explanation with screenshots steps on how pointer moves, values of variables, using forward arrow to continue, etc.

Practice task: perform multiple arithmetic operations, assign characters to inputs to observe debugger behavior.

Git add/commit/push steps and summary.

---

### download3.pdf
Cheatsheet: Working with DOM in JavaScript

Topics and examples:
- try { ... } catch { ... } with example accessing property of undefined.
- getElementById() example.
- getElementsByClassName(), getElementsByTagName().
- querySelector and querySelectorAll demos and examples.
- textContent and setAttribute examples.
- createElement, appendChild examples (adding elements).
- cloneNode(true) example to duplicate elements.
- Browser Object Model (BOM): window methods (alert, confirm, open, close, location, setTimeout, localStorage/sessionStorage, history).
- navigator, screen, history, location objects examples.
- DOM traversing: firstElementChild, lastElementChild, container querying with querySelector/querySelectorAll.
- Styling via element.style.property and element.classList with examples of toggle/add/remove/contains/replace.
- setAttribute for style, element.style.cssText, style.setProperty, style.removeProperty examples.
- Many code snippets and explanations for each method.

Summary and Skills Network footer.

---

### download10.pdf
Hands-on Lab: Develop an Application to Create Book Management System Using Objects

Skills Network

Estimated time needed: 30 minutes

What you will learn
Create book management UI with HTML form inputs, store/manage books using JS objects/arrays, display, edit, delete books.

Steps:
- Create bookSystem folder with book_system.html, book_system.js.
book_system.html includes inputs: bookName, authorName, bookDescription, pagesNumber, Add Book button, div id="books" to show books, script include.

JS book_system.js:
let books = [];
function addBook() {
  const bookName = document.getElementById('bookName').value;
  const authorName = document.getElementById('authorName').value;
  const bookDescription = document.getElementById('bookDescription').value;
  const pagesNumber = parseInt(document.getElementById('pagesNumber').value);
  if (bookName && authorName && bookDescription && !isNaN(pagesNumber)) {
    const book = { name: bookName, authorName, bookDescription, pagesNumber };
    books.push(book);
    showbooks();
    clearInputs();
  } else {
    alert('Please fill in all fields correctly.');
  }
}
function showbooks() {
  const booksDiv = books.map((book,index) => `<h1>book Number: ${index+1}</h1><p><strong>Book Name:</strong>${book.name}</p><p><strong>Author Name :</strong> ${book.authorName}</p><p><strong>Book Description :</strong> ${book.bookDescription}</p><p><strong>No. of Pages :</strong> ${book.pagesNumber} page(s)</p><button onclick="editbook(${index})">Edit</button>` );
  document.getElementById('books').innerHTML = booksDiv.join('');
}
function editbook(index) {
  const book = books[index];
  document.getElementById('bookName').value = book.name;
  document.getElementById('authorName').value = book.authorName;
  document.getElementById('bookDescription').value = book.bookDescription;
  document.getElementById('pagesNumber').value = book.pagesNumber;
  books.splice(index,1);
  showbooks();
}
function clearInputs() { document.getElementById('bookName').value = ""; document.getElementById('authorName').value = ""; document.getElementById('bookDescription').value = ""; document.getElementById('pagesNumber').value = ""; }

Live Server instructions, git steps. Practice task: add delete button (deletebook function using books.splice(index,1)).

Summary.

---

### download9.pdf
Hands-on Lab: Create Text Analysis Tool for Speed Testing Using String Manipulations

Skills Network

Estimated time needed: 30 minutes

What you will learn
Build typing speed test: display text to type, capture user input, compute words typed, time elapsed, words per minute (WPM).

Setup:
- Create speedAnalysis folder with speed_analysis.html and speed_analysis.js
speed_analysis.html includes two textareas: inputText (readonly) and userInput, Start Test and End Test buttons and output div.

JS:
let testText = "The quick brown fox jumps over the lazy dog.";
let startTime, endTime;
function startTest() {
  document.getElementById("inputText").value = testText;
  let userInput = document.getElementById("userInput");
  userInput.value = "";
  userInput.readOnly = false;
  userInput.focus();
  document.getElementById("output").innerHTML = "";
  startTime = new Date().getTime();
}
function endTest() {
  endTime = new Date().getTime();
  document.getElementById("userInput").readOnly = true;
  var timeElapsed = (endTime - startTime) / 1000;
  var userTypedText = document.getElementById("userInput").value;
  var typedWords = userTypedText.split(/\s+/).filter(function (word) { return word !== ""; }).length;
  var wpm = 0;
  if (timeElapsed !== 0 && !isNaN(typedWords)) {
    wpm = Math.round((typedWords / timeElapsed) * 60);
  }
  var outputDiv = document.getElementById("output");
  outputDiv.innerHTML = "<h2>Typing Test Results :</h2>" +
    "<p>Words Typed: " + typedWords + "</p>" +
    "<p>Time Elapsed: " + timeElapsed.toFixed(2) + " seconds</p>" +
    "<p>Words Per Minute (WPM): " + wpm + "</p>";
}

Live Server instructions, sample output (Words Typed: 9, Time elapsed example, WPM example). Practice task to include total length (userTypedText.length). Git steps.

Summary.

---

### download6.pdf
Hands-on Lab: Create a To-Do List Using JavaScript

Skills Network

Estimated time needed: 30 minutes

What you will learn
Build To-Do list app: add tasks, display tasks, mark completed, clear completed, search (optional). DOM manipulation and event handling.

Setup:
- Create TodoList folder, todo_list.html and todo_list.js.
todo_list.html:
<! DOCTYPE html>
<html>
<head><title>ToDo List</title></head>
<body>
<h1>ToDo List</h1>
<input type="text" id="taskInput" placeholder="Add a new task">
<button id="addTaskBtn">Add Task</button>
<!-- <input type="text" id="searchInput" placeholder="Search ... "> -->
<ul id="taskList"></ul>
<button id="clearCompletedBtn">Clear Completed</button>
<script src="./todo_list.js"></script>
</body>
</html>

todo_list.js:
const taskInput = document.getElementById("taskInput");
const addTaskBtn = document.getElementById("addTaskBtn");
const taskList = document.getElementById("taskList");
const clearCompletedBtn = document.getElementById("clearCompletedBtn");
let tasks = [];

function addTask() {
  const taskText = taskInput.value.trim();
  if (taskText !== "") {
    tasks.push({ text: taskText});
    taskInput.value = "";
    displayTasks();
  }
}

function displayTasks() {
  taskList.innerHTML = "";
  tasks.forEach((task,index) => {
    const li = document.createElement("li");
    li.innerHTML = `<input type="checkbox" id="task-${index}" ${task.completed ? "checked" : ""}><label for="task-${index}">${task.text}</label>`;
    li.querySelector("input").addEventListener("change", () => toggleTask(index));
    taskList.appendChild(li);
  });
}

function toggleTask(index) {
  tasks[index].completed = !tasks[index].completed;
  displayTasks();
}

function clearCompletedTasks() {
  tasks = tasks.filter(task => !task.completed);
  displayTasks();
}

addTaskBtn.addEventListener("click", addTask);
clearCompletedBtn.addEventListener("click", clearCompletedTasks);
displayTasks();

Live Server instructions, sample UI, clear completed behavior. Practice task: add Clear All Tasks button and handler. Git steps.

Summary.

---

### download12.pdf
Hands-on Lab: Working with Array Iteration for Restaurant Menu List

Skills Network

Estimated time needed: 20 minutes

What you will learn
Use map, forEach, and for loop to generate restaurant menus (breakfast, main course, dessert) dynamically.

Setup:
- Create restaurantMenu folder with restaurant_menu.html and restaurant_menu.js.
restaurant_menu.html has divs with IDs: breakfastTotalItems, breakfastMenuItems, maincourseTotalItems, maincourseMenuItems, dessertTotalItems, dessertMenuItems and script include.

JS:
const breakfastMenu = ['Pancakes','Eggs Benedict','Oatmeal','Frittata'];
const mainCourseMenu = ['Steak','Pasta','Burger','Salmon'];
const dessertMenu = ['Cake','Ice Cream','Pudding','Fruit Salad'];

Breakfast using map:
const breakfastMenuItemsHTML = breakfastMenu.map((item,index)=> `<p>Item ${index+1}: ${item}</p>`).join('');
document.getElementById('breakfastMenuItems').innerHTML = breakfastMenuItemsHTML;

Main course using forEach:
let mainCourseItem = '';
mainCourseMenu.forEach((item,index)=> { mainCourseItem += `<p>Item ${index+1}: ${item}</p>`;});
document.getElementById('maincourseMenuItems').innerHTML = mainCourseItem;

Dessert using for loop:
let dessertItem = '';
for (let i=0;i<dessertMenu.length;i++) { dessertItem += `<p>Item ${i+1}: ${dessertMenu[i]}</p>`;}
document.getElementById('dessertMenuItems').innerHTML = dessertItem;

Live Server instructions and git steps. Practice task: include prices as part of strings and display.

Summary.

---

### download11.pdf
Hands-on Lab: Display Employee Information using Array Methods

Skills Network

Estimated time needed: 30 minutes

What you will learn
Create employee management system demonstrating forEach/filter/reduce/find to display employees, calculate total salaries, filter by department, find by ID.

Setup:
- Create employeeDetails folder with employee_details.html and employee_details.js.
employee_details.html buttons: Display Employees, Calculate Total Salaries, Display HR Employees, Find Employee by ID 2, and div id="employeesDetails".

employee_details.js:
const employees = [
  { id:1, name:'John Doe', age:30, department:'IT', salary:50000 },
  { id:2, name:'Alice Smith', age:28, department:'HR', salary:45000 },
  { id:3, name:'Bob Johnson', age:35, department:'Finance', salary:60000 },
  // ...
];

function displayEmployees() {
  const totalEmployees = employees.map(employee => `<p>${employee.id}: ${employee.name} - ${employee.department} - $${employee.salary}</p>`).join('');
  document.getElementById('employeesDetails').innerHTML = totalEmployees;
}

function calculateTotalSalaries() {
  const totalSalaries = employees.reduce((acc,employee) => acc + employee.salary,0);
  alert(`Total Salaries: $${totalSalaries}`);
}

function displayHREmployees() {
  const hrEmployees = employees.filter(employee => employee.department === 'HR');
  const hrEmployeesDisplay = hrEmployees.map((employee) => `<p>${employee.id}: ${employee.name} - ${employee.department} - $${employee.salary}</p>`).join('');
  document.getElementById('employeesDetails').innerHTML = hrEmployeesDisplay;
}

function findEmployeeById(employeeId) {
  const foundEmployee = employees.find(employee => employee.id === employeeId);
  if (foundEmployee) {
    document.getElementById('employeesDetails').innerHTML = `<p>${foundEmployee.id}: ${foundEmployee.name} - ${foundEmployee.department} - $${foundEmployee.salary}</p>`;
  } else {
    document.getElementById('employeesDetails').innerHTML = 'no employee has been found with this ID';
  }
}

Live Server instructions, practice task: add specialization field and implement search by specialization. Git steps and summary.

---

### download2.pdf
DOM Manipulation Methods — querySelectorAll and classList

Explains querySelectorAll usage for selecting by class, ID, and tag with examples and outputs:
- document.querySelectorAll('.highlighted') returns NodeList of matching elements.
- document.querySelectorAll('#my-paragraph') returns NodeList with single element for unique ID.
- document.querySelectorAll('p') returns NodeList of <p> elements.

classList property: methods add/remove/toggle/contains/replace/item/toString with examples. Example HTML with paragraph id="myParagraph" class="highlight" and button performing classList operations:
- add('italic'), remove('highlight'), toggle('underline', true), contains('italic'), replace('underline','strike'), toString() logged.

Detailed breakdown of function performClassListOperations steps and CSS classes .highlight/.italic/.underline/.strike.

Summary on dynamic class manipulation.

---

### download1.pdf
Reading: Introduction to addEventListener

Explains addEventListener usage:
element.addEventListener(eventType, handlerFunction)
Benefits vs inline handlers: readability, maintainability, multiple handlers, reuse.

Events covered:
- Mouse events: click, mouseover/mouseout/mousemove examples
- Keyboard events: keydown/keyup/keypress examples
- Form events: submit (preventDefault example), change, focus/blur
- Window events: load, resize, scroll
Code examples provided for each event with explanations.

Conclusion: addEventListener essential for modern JS event handling.

---

### download5.pdf
JavaScript and Browser Support

Overview of cross-browser compatibility, ECMAScript standards, polyfills, transpilers (Babel), feature detection, testing (BrowserStack, MDN, caniuse.com).
Example of feature detection for localStorage:
function isLocalStorageSupported() { try { const testKey = '_test_'; localStorage.setItem(testKey,testKey); localStorage.removeItem(testKey); return true; } catch(e) { return false; } }
if (isLocalStorageSupported()) { console.log('localStorage is supported'); } else { console.log('Sorry, localStorage is not supported'); }

Conclusion and resources.

---
### Hands-on Lab: Writing Your First JavaScript Function (download16.pdf)

# Hands-on Lab: Writing Your First JavaScript Function

Skills  
Network

Estimated time needed: 30 minutes

## What you will learn

In this lab, you will delve into foundational JavaScript concepts vital for web development. You will learn how to use functions to create an interactive web application that calculates the area of a rectangle based on user-provided values.

## Learning objectives

After completing this lab, you will be able to:

· Understanding HTML structure: Recognize the structure of an HTML file and comprehend how to create an interactive user interface by implementing HTML elements like input fields and buttons.

· JavaScript variable declaration: Grasp the concept of declaring variables in JavaScript and understand their role in storing data retrieved from user input.

· Retrieving user input with JavaScript: Learn how to use JavaScript to fetch and process user-provided data entered into input fields within an HTML document.

. Function implementation and execution: Comprehend the creation and execution of JavaScript functions and their role in executing specific tasks, such as performing calculations and dynamically updating HTML content based on user actions.

## Prerequisites

· Basic Knowledge of HTML and Git commands.

· Basic understanding of functions and it's syntax.

· Web browser with a console (Chrome DevTools, Firefox Console, and so on).

## Step 1: Setting up the environment

1. Firstly, you need to clone your main repository in the Skills Network Environmemnt which you created in the first lab and where you have been pushing all work related to the previous labs. Follow the given steps to clone this repository:

· Click on the terminal in the top-right window pane and then select New Terminal.

File Edit Selection View Go Run

Terminal

Help

New Terminal

2

Ctrl+Shift+'

New Terminal (With Profile)

· Perform git clone command by writing the given command in the terminal.

git clone <github-repository-url>

Note: Put your own GitHub repository link instead of <github-repository-url>.

!
Problems
>
theia@theia-richaar: /home/project x

theia@theia-richaar:/home/project$ git clone https://github.com/

· Above step will clone the folder for your GitHub repository under project folder in explorer. You will also have multiple folders inside the cloned folder.

o Now you need to navigate inside the cloned folder. For this write given command in the terminal:

cd <repository-folder-name>

<!-- PageBreak -->


Replace this with your cloned folder name

theia@theia-richaar:/home/project$ cd
jscoursetesting

Note: Write your cloned folder name instead of <repository-folder-name>. Perform git clone if you have logged out of Skills Network Environment and you cannot see any files or folder after you logged in.

2. Now select cloned Folder Name folder, right click on it and click on New Folder. Enter folder name as calculate Area. It will create the folder for you. Then select calculate Area folder, right click and select New File. Enter file named as calculate_Area.html and click OK. It will create your HTML file.

3. Now, select calculate Area folder again, right click and select New File. Enter file named as calculate_Area.js and click OK to create your javaScript file.

4. Create the basic template structure for calculate_Area.html file by adding the provided content.

o Inside the HTML file, create an input form to collect the length and width of the rectangle along with a button to trigger the calculation.
☐

· To achive this, include the provided code into the calculate_Area.html file.
☐
<html>
<head>
<title>Rectangle Area Calculator</title>
</head>
<body>
<h1>Rectangle Area Calculator</h1>
<label for="length">Enter the length: < /label>
<input type="number" id="length"><br><br>
<label for="width">Enter the width: < /label>
<input type="number" id="width"><br><br>
<button onclick="calculateArea()">Calculate Area</button><br><br>
<p id="result"></p>
<script src="./calculate_Area. js"></script>
</body>
</html>

5. The provided HTML code includes:

☐
· Page title and heading: Sets up a webpage titled "Rectangle Area Calculator" and presents a primary heading <h1> displaying the same title, ensuring clarity about the page's purpose.

☐
· Input fields for user data: Provides input fields labeled for length and width <input type="number" id="length"> and <input type="number" id="width"> to allow users to input numerical values for the rectangle's dimensions.

☐
Calculation trigger and display: Includes a button <button onclick="calculateArea()">Calculate Area</button> to execute a JavaScript function named calculateArea() upon clicking. The calculated result of the rectangle's area will be displayed within the <p> element with the ID 'result'.

☐
. Dynamic result display: Prepares a placeholder <p id="result"></p> to dynamically display the calculated area, creating a user-friendly interface for real-time feedback after the calculation is performed.

· One <script> tag is added to include the js file in the calculate_Area.html file using the src attribute.
☐

### Step 2: Defining variables and function to calculate area

1. Declare two variables named length and width in calculate_Area.js file but do not assign any values to them yet. These variables will be used to store the length and width of the rectangle provided by the user through a form in HTML file.

let length;
let width;

2. Now create a function named as calculate Area in calculate_Area.js file as follows:

function calculateArea() {
}

<!-- PageBreak -->

3. Inside the above function, fetch values from user as input. For this you need to get values using document . getElementById from user input within calculate Area function as follows:

function calculateArea() {
length = parseFloat(document. getElementById('length'). value);
width = parseFloat(document. getElementById( 'width' ) . value);
}

4. Above code includes:

· document.getElementById ('length'): This part of the code retrieves an HTML element by its ID, specifically searching for an element with the ID 'length'.

o .value: After accessing the HTML element, .value is used to retrieve the value entered into the input field associated with that element. For instance, if a user enters '5' into the input field for length, .value retrieves the string '5'.

· parseFloat( ... ): The parseFloat() function converts the string value retrieved from the input field to a floating-point number. This conversion ensures that the input, typically text entered by the user, is treated as a number and can be used in mathematical operations.

· length and width: Finally, the obtained floating-point numbers (representing the length and width values entered by the user) are stored in the variables length and width, respectively. These variables will be utilized for further calculations, such as determining the area of a rectangle in this context.

5. Next, declare a variable named area and initialize it with length * width in calculate_Area.js file as following:

function calculateArea() {
length = parseFloat(document. getElementById('length' ). value);
width = parseFloat(document. getElementById('width' ) . value);
let area = length * width;
}

6. After the calculation of the rectangle's area is completed and stored within the variable named area, the given code involves presenting or displaying this result to the user interface. Include given code within the function after calculation of area.

document.getElementById('result').innerText = `The area of the rectangle is: ${area} ;

7. Above code includes:

o document.getElementById ('result'): This part of the code retrieves an HTML element by its ID. Specifically, it targets an element with the ID 'result'.

o .innerText = The area of the rectangle is: ${area} ;: Once the element is accessed, .inner Text is used to modify the text content within that HTML element.

o The backticks and $ {} notation allow for the inclusion of JavaScript variables within a string (using template literals). In this case, it sets the text content to display a message along with the calculated area stored in the variable area. For example, if area holds a value of 25, the text displayed will be "The area of the rectangle is: 25".

#### Step 3: Perform Git commands

1. Perform git add to add latest files and folder in git environment.

git add -- a

<!-- PageBreak -->

· Make sure the terminal has the same path as follows:

theia@theia-richaar ://home/project/jscoursetesting$
git add -- a

Replace jscoursetesting with your cloned repository folder name

2. Then perform git commit in the terminal. While performing git commit, terminal can show message to set up your git config -- global for user. name and user.email. Then you need to perform git config command as well for user. name and user. email as given.

git config -- global user.email "you@example.com"

git config -- global user.name "Your Name"

Now after this you can perform git command as given below:
git commit -m "message"

3. Then perform git push just by writing given command in terminal.
git push origin

After the push command, the system will prompt you to enter your username and password. Enter the username for your GitHub account and the password that you created in the first lab. After entering the credentials, all of your latest folders and files will be pushed to your GitHub repository.

##### Step 4: Check the output

1. To view your HTML page, right-click the calculate_Area.html file after selecting this file, then select "Open with Live Server."

The server should start on port 5500, indicated by a notification on the bottom right side.

2. Click the Skills Network button on the left (refer to number 1). This action will open the "Skills Network Toolbox." Next, select "Launch Application" (refer to number 2). Once there, enter port number 5500 in "Application Port" (refer to number 3) and click this button
7
.

It will open your default browser where you will see cloned-folder-name folder name. Click on that cloned-folder-name folder name. After clicking you will see multiple folders name, among those folders name click on calculate Area folder. You will see files related to this folder where again you will click on calculate_Area.html file as shown below.

calculate_Area.html

calculate_Area.js

3. It will open the HTML page where you can then enter the length and width values as shown below.

# Rectangle Area Calculator

Enter the length:
10

Enter the width:
11

Calculate Area

4. Then click on Calculate Area button and then you will see the answer.

# Rectangle Area Calculator

Enter the length:
10

Enter the width:
11

Calculate Area

The area of the rectangle is: 110

Note: After pasting the code, remember to save your file. If you edit your code, then just refresh your browser, which is running through port number 5500. This way there is no need to launch the application again and again.

# Practice task

In this task you need to create a function called grocery Tracker to calculate the total amount of the purchased grocery item. For this:

1. Include the following in the HTML File:

o You need to create at least three input boxes with ID named as "groceryl" and so on.
☐

· Also Label them using <label> as "Enter first grocery amount" and so on.
☐

· Create a button that calculates the total expenditure on the grocery purchases.

2. Include the following in the JavaScript file:

o Create a function which will accept these amount entered by users as a parameter.
☐

o Then write the logic to calculate the total amount spent on the grocery purchase.
☐

· Call this function in such a way so that after clicking on the button, it shows the total amount for the grocery purchase.

Enter Grocery-1 Amount:

56.99

Enter Grocery-2 Amount:

34.99

Enter Grocery-3 Amount:

12.66

Calculate Total Amount

The total amount is :$ 104.64

## Summary

1. Setting up the environment: Creating HTML and JavaScript files, initializing the basic HTML structure, input fields, and triggering calculation functionality.

2. Defining variables and functions: Declaring variables for user input storage and crafting a calculateArea() function to process this input. Retrieving user-entered values and computing the area of a rectangle based on these values.

3. Displaying calculated result: Dynamically updating the HTML content with the calculated area. Utilize JavaScript to modify specific elements within the HTML document, providing real-time feedback to the user.

---

### Hands-on Lab: Implementing Control Flow and Conditional Statements (download17.pdf)

# Hands-on Lab: Implementing Control Flow and Conditional Statements

Skills  
Network

Estimated time needed: 15 minutes

## What you will learn

In this lab, you will delve into the fundamental concept of control flow and conditional statements in JavaScript. Through hands-on implementation, you will grasp the essence of if ... else statements, nested statements, and switch statements, understanding how these structures enable code execution based on specific conditions. You will gain insight into how altering these elements impacts the program's flow and output.

## Learning objectives

After completing this lab, you will be able to:

· Decision-making constructs: Learn about if statements for single-condition execution, if else statements to execute different code blocks based on conditions, and nested if else statements to handle multiple conditions hierarchically.

. Control flow and efficiency: Explore logical flow control to manage program flow based on conditions and code optimization to enhance readability and efficiency.

· Handling multiple scenarios: Understand how to manage complexity to deal with multiple conditions effectively and switch statements to streamline code for multiple scenarios.

· Real-world application and problem-solving: Learn about applied problem solving to utilize conditional statements in practical scenarios and enhanced logic building to strengthen problem-solving skills through logic constructs.

## Prerequisites:

· Basic knowledge of HTML and Git commands.

· Basic understanding of JavaScript control flow and conditional statements such as if, if else, and switch case.

· Web browser with a console (Chrome DevTools, Firefox Console, and so on).

## Step 1: Setting up the environment

1. First, you need to clone your main repository in the Skills Network Environment. Follow the given steps:

. Click on the terminal in the top-right window pane and then select New Terminal.

File Edit Selection View Go Rub

Terminal

Help

New Terminal

2

Ctrl+Shift+'

New Terminal (With Profile)

· Perform git clone command by writing given command in the terminal.

git clone <github-repository-url>

Note: Put your own GitHub repository link instead of <github-repository-url> and it should look like as given below:

!
Problems
>
theia@theia-richaar: /home/project >

theia@theia-richaar: /home/project$ git clone https://github.com/

· Above step will clone folder for your GitHub repository under project folder in explorer. You will also see multiple folders inside cloned folder.

· Now you need to navigate inside the cloned folder. For this write given command in the terminal:
cd <repository-folder-name>

Replace this with your cloned folder name

theia@theia-richaar: /home/project$ cd
jscoursetesting

Note: Write your cloned folder name instead of <repository-folder-name>. Perform git clone if you have logged out of Skills Network Environment and you cannot see any files or folder after you logged in.

2. Now, select the cloned Folder Name folder, right-click on it, and choose New Folder. Enter the folder name as controlFlow. This will create the folder for you. Then, select the controlFlow folder, right-click, and choose New File. Enter the file name as control_flow.html and click OK. This will create your HTML file.

3. Now select the controlFlow folder again, right-click and select New File. Enter the file name as control_flow.js and click OK. This will create your javaScript file.

4. Create a basic template structure for control_flow.html file by adding the code provided below.

<! DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Control Flow</title>
</head>
<body>
<h1>Control Flow and Conditional Statements</h1>
<script_src="./control_flow. js"></script>

</body>
</html>

5. Above HTML code has one <h1> tag in file and one <script> tag to include js file in control_flow.html file using src attribute.

## Step 2: Defining variables and if else statement for userRole and accessLevel

1. Declare variable named userRole and initialize it with the string value "admin" in control_flow.js file. Also, declare one more variable named access Level but do not assign a value to it yet.

let userRole = "admin";
let accessLevel;

2. Now, execute the if ... else block by assigning different roles in the if ... else condition to check if userRole is equal to "admin"or not. Include the following code in the control_flow.js file after the previous code:

if (userRole === "admin") {
accessLevel = "Full access granted";
} else if (userRole === "manager") {
accessLevel = "Limited access granted";
} else {
accessLevel = "No access granted";
}

3. Now, the above code will check if userRole is "admin" or something else.

· IfuserRole is "admin", the code with assign access Level as "Full access granted".

· If not, it will proceed to check if userRole is "manager".

· If userRole is "manager", it will assign accessLevel as "Limited access granted".

· IfuserRole is neither "admin" nor "manager", the code will assign accessLevel as "No access granted".

4. Based on the value of userRole, the access Level variable will be set to one of the following:

o "Full access granted" if userRole === "admin"

· "Limited access granted" if userRole === "manager"

o "No access granted" for any other value of userRole

You will be able to see the output using this code:

console.log("Access Level:", accessLevel);

### Check output

1. To view your HTML page, right-click the control_flow.html file after selecting this file, then select "Open with Live Server".

2. The server should start on port 5500, indicated by a notification on the bottom-right side.

i
Server is Started at port : 5500

X

Don't show again

3. Click the Skills Network button on the left (refer to number 1). It will open the "Skills Network Toolbox". Then click Launch Application (refer to number 2). From there,

you enter port 5500 at number 3 and click this button
7

.

4. It will open your default browser, where you will first see the name of your cloned folder. Click on that folder, and inside it, among other folders, you will find the controlFlow folder name. Click on the controlFlow folder, and then select the HTML file, as shown below.

control_flow.html

control_flow.js

5. To view the output in the browser, right-click on the window that opens after selecting the "control_flow.html" file, and then choose the "inspect" option.

Elements

Console

Sources

Network

Performance

6. You will see the output Access Level:Full access granted because default value of userRole is admin.

Access Level: Full access granted

# Step 3: Defining variables and nested if ... else statementd for isLoggedIn and userMessage

1. Declare a variable named is LoggedIn and initialize it with the boolean value "true" in control_flow.js file. Declare one more variable named userMessage but do not assign a value to it yet. Insert the provided code after the previous code.

let isLoggedIn = true;
let userMessage;

2. Now, implement and execute the Nested if ... else statement to check if user is logged in or not:
if (isLoggedIn) {

if (userRole === "admin") {
userMessage = "Welcome, Admin!";
} else {
userMessage = "Welcome, User!";
}

} else {
userMessage = "Please log in to access the system.";
}

3. Ifuser is logged in isLoggedIn === true, the code checks the user's role (userRole).

· If userRole is "admin", it sets userMessage to "Welcome, Admin!".
☐

o If userRole is not "admin", it sets userMessage to "Welcome, User!".
☐

4. If User is not logged in isLoggedIn === false, then:

· The message is set to "Please log in to access the system."
☐

5. You can use the following console method to view the output:
console.log("User Message:", userMessage);

6. You will see the output as User Message: Welcome, Admin! because the default value of is LoggedIn is true.

Access Level: Full access granted
User Message: Welcome, Admin!

## Step 4: Defining variables and switch statement for user Type and userCategory

1. Declare a variable named userType and initialize it with the string value "subscriber" in control_flow.js file. Declare one more variable named userCategory but do not assign a value to it yet. Insert the provided code after the previous code.

let userType = "subscriber";
let userCategory;

2. Now, you need to implement and execute the switch statement to evaluate the value of userType by providing different case values:

switch (userType) {
case "admin":
userCategory = "Administrator";
break;
case "manager":
userCategory = "Manager";
break;
case "subscriber":
userCategory = "Subscriber";
break;
default:
userCategory = "Unknown";
}

3. The output for cases depend upon its value, such as:

· Case "admin":

· If userType is "admin", userCategory is assigned as "Administrator".
☐

o break; exits the switch statement after the assignment.
☐

· Case "manager":

· If userType is "manager", userCategory is assigned as "Manager".
☐

o break; exits the switch statement after the assignment.
☐

· Case "subscriber":

· If userType is "subscriber", userCategory is assigned as "Subscriber".
☐

o break; exits the switch statement after the assignment.
☐

. Default Case:

· If userType doesn't match any defined cases ("admin", "manager", or "subscriber"), userCategory is assigned as "Unknown".
☐

4. You can use the following console method to view the output:
console.log("User Category:", userCategory);

5. You will see the output as User Category: Subscriber because the default value of userType is subscriber.

Access Level: Full access granted

User Message: Welcome, Admin!

User Category: Subscriber

6. Perform git add, git commit, and git push commands to update changes of your controlFlow folder into GitHub repository for proper code management.

# Step 5: Use ternary operator for isAuthenticated and authenticationStatus

1. Declare a variable named is Authenticated and initialize it with the boolean value true in control_flow.js file.
let isAuthenticated = true;

2. Declare one more variable named authenticationStatus and use a ternary operator (? : ) to see if the user is authenticated or not.
let authenticationStatus = isAuthenticated ? "Authenticated" : "Not authenticated";

3. Now the condition will be checked.

o If is Authenticated is true, the expression before : (in this case, "Authenticated") is assigned to authenticationStatus.
☐
o If is Authenticated is false, the expression after : (in this case, "Not authenticated") is assigned to authenticationStatus.
☐

4. You can use the following console method to view the output:

console.log("Authentication Status:", authenticationStatus);

# Step 6: Perform Git commands

1. Perform git add to add latest files and folder by writing given command in terminal in git environment.
git add -- a

Make sure terminal should have path as follows:

theia@theia-richaar ://home/project/jscoursetesting$
git add -- a

Replace jscoursetesting with your cloned repository folder name

2. Then perform git commit in the terminal. While performing git commit, terminal can show message to set up your git config -- global for user. name and user.email. If yes, then you need to perform git config command as well for user. name and user. email as given.

git config -- global user.email "you@example.com"

git config -- global user.name "Your Name"

Note: Replace data within qoutes with your own details.
Then perform commit command as given:
git commit -m "message"

3. Then perform git push just by writing given command in terminal.
git push origin

· After the push command, the system will prompt you to enter your username and password. Enter the username for your GitHub account and the password that you created in the first lab. After entering the credentials, all of your latest folders and files will be pushed to your GitHub repository.

# Practice task

1. Suppose an organization arranges a "Dietary Services" program to provide diets to its employees and customers, based on a person's weight and day-to-day routine. You need to create an authorization-based code to provide access to people based on their roles in organization, such as employees, enrolled members for "Dietary Services," and subscribers.

o If the person is an Employee, they are authorized to have access to "Dietary Services".
☐

· If the person is an Enrolled Member, they are authorized to have access to "Dietary Services" and one-on-one interaction with a dietician.
☐

· If the person is a Subscriber, they are authorized to have partial access to facilitate "Dietary Services" only.
☐

· If the person is a Non-Subscriber, they need to enroll or at least subscribe first to avail this facility.
☐

2. You need to communicate with the user by printing a message indicating whether that person is eligible to avail which type of services.

# Summary

· Using conditional statements and control flow, you can direct how a program behaves based on different situations or criteria, allowing for decision-making and defining specific pathways within the code.

1. Variables declaration:

· Set up a HTML file linked to a JavaScript file in a folder named "controlFlow."
☐

· Create variables for userRole, accessLevel, isLoggedIn, userMessage, userType, userCategory, isAuthenticated, and authenticationStatus.
☐

2. Implementing control flow:

· Use if ... else statements to assign access levels based on user roles.
☐

· Implement nested if ... else statements to customize messages based on login status and user roles.
☐

· Utilize a switch statement to categorize users based on their type.
☐

3. Ternary operator for authentication:

o Use a ternary operator to determine the authentication status.
☐

· Depending on the value of isAuthenticated, set the authenticationStatus as "Authenticated" or "Not authenticated."
☐

@ IBM Corporation. All rights reserved.

---

### Hands-on Lab: Working with Variables and Their Scope (download18.pdf)

# Hands-on Lab: Working with Variables and Their Scope

Skills  
Network

Estimated time needed: 15 minutes

# What you will learn

In this lab, you will develop an understanding of JavaScript variables, including var, let, and const. JavaScript variables act as containers for storing data, allowing dynamic programming by facilitating the storage, manipulation, and retrieval of values across various sections of code within applications. You will learn how to use variables to enhance code readability and maintainability, enabling efficient management and reuse of variable values throughout your entire programs.

# Learning objectives

After completing this lab, you will be able to:

· Understand where variables work: Learn how 'var,' 'let,' and 'const' variables operate in different parts of your code, where you can use them, and potential issues they might cause.

· Know how variables behave: Discover the distinct behaviors of'var,' 'let,' and 'const.' Understand how they can change and when they remain constant. Learn why declaring variables with 'var,' 'let,' and 'const' is essential for maintaining safe and reliable data.

· Learn the right way to use them: Determine when to use 'let' for changing data, 'const' for constants, and why using 'var' might not be the best choice anymore. It's important to selecting the right variable for the code.

· Make your code stronger: Through a deep understanding of'var,' 'let,' and 'const,' you'll write more resilient code less prone to breakage. Avoid bugs and create code that is not only comprehensible to you but also to others, ensuring it operates smoothly.

# Prerequisites

· Basic Knowledge of HTML and Git commands.

· Basic understanding of JavaScript variables and their scope.

· Web browser with a console (Chrome DevTools, Firefox Console, and so on).

# Step 1: Setting up the environment

1. First, you need to clone your main repository in the Skills Network Environment. Follow the given steps:

· Click on the terminal in the top-right window pane and then select New Terminal.

File Edit Selection View Go Rub

Terminal

Help

New Terminal

2

Ctrl+Shift+'

New Terminal (With Profile)

· Perform git clone command by writing given command in the terminal.

git clone <github-repository-url>

Note: Put your own GitHub repository link instead of <github-repository-url> which should lokk like below:

!
Problems
>
theia@theia-richaar: /home/project x

theia@theia-richaar:/home/project$ git clone https://github.com/

o The above step will create a cloned folder for your GitHub repository under the project folder in the explorer, as indicated by number 1 (this folder name is just for reference). You will also see a SampleFolder inside the cloned folder, as this folder was pushed in the first lab, as shown at number 2.

Replace this with your cloned folder name

theia@theia-richaar: /home/project$ cd

jscoursetesting

2. Now, select the cloned Folder Name folder, right-click on it, and choose New Folder. A pop up box will appear where you will see default name shown at number 1.

New Folder ...

jscoursetesting

You will see your cloned folder name here

Untitled

1

OK

Instead of default name enter the folder name as Scope. This will create the folder for you. Then, select the Scope folder, right-click, and choose New File. Again a pop box will appear with default name, replace default name with the file name as scope_lab.html and click OK. This will create your HTML file.

3. Now select the Scope folder again, right click and select New File. Enter the file name as scope_lab.js and click OK. This action will generate your JavaScript file.

4. Create the basic template structure for scope_lab.html file by adding the below code.

<! DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Scoped Variables</title>
</head>
<body>
<h1>Scope Lab for Var, Let and Const</h1>
</h1>
<script src="./scope_lab.js"></script>

</body>
</html>

Note: After pasting the code, save your file.

5. The above HTML code has one <h1> tag in file and one <script> tag to include js file in scope_lab.html file using the src attribute.

Step 2: Defining variables with let, var, and const

1. Declare and initialize variables using let, var, and const. Then assign values to these variables for different scopes such as:

· Global scope

· Block scope

2. For the different scopes, include the given code in scope_lab.js. It is declared to show the scope of variables let, const, and var at a global and block level. Then, save the file.

// Global scope
var globalVar = "I'm a global variable";
let globalLet = "I'm also global, but scoped with let";
const globalConst = "I'm a global constant";
{

// Block scope
var blockVar = "I'm a block-scoped var";
let blockLet = "I'm a block-scoped let";
const blockConst = "I'm a block-scoped const";
}

Note: After pasting the code, save your file.

# Step 3: Scope of variables at a global level

1. Now, to observe the scope at a global level, include the given code after the previous code (after line number 12) and save the file.

// Global scope
console.log(globalVar); // Output: "I'm a global variable"
console.log(globalLet); // Output: "I'm also global, but scoped with let"
console. log(globalConst); // Output: "I'm a global constant"

2. To view how your HTML page is displayed in the browser, use the built-in Live Server extension with the following instructions:

o Select scope_lab.html, right click on this file and then choose 'Open with Live Server'.
☐

· A notification will appear at the bottom right, indicating that the server has started on port 5500.
☐

· Then, click the Skills Network button on the left (refer to number 1). This action will open the "Skills Network Toolbox." Next, select "Launch Application" (refer to number 2). Once there, enter port number 5500 in "Application Port" (refer to number 3) and click this button
7

. It will open your default browser, where you will first see the name of your cloned folder. Click on that folder, and inside it, among other folders, you will find the Scope folder. Click on the Scope folder, and then select the HTML file, as shown below.

scope_lab.html

scope_lab.js

Note: Save your file after pasting the code. If you edit your code, simply refresh your browser running on port 5500. No need to relaunch the application.

3. To view the output in the browser, right-click on the window that opens after clicking the "scope_lab.html" file, and then choose the "inspect" option.

Back

Alt+Left arrow

Refresh

Ctrl+R

Save as

Ctrl+S

Print

Ctrl+P

i Send tab to your devices

Create QR Code for this page

A» Read aloud

Ctrl+Shift+U

a& Translate to English

Add page to Collections

Share

Web capture

Ctrl+Shift+S

View page source

Ctrl+U

## Inspect

4. Next, go to console tab.

Elements

Console

Sources

Network

Performance

5. You will see output as given below.

I'm a global variable

I'm also global, but scoped with let
I'm a global constant

# Step 4: Scope of variables for block scope

1. Now to see the scope at the block level, include the provided code for variables declared at the block level after the previous JavaScript code, and save the file.

//Block Scope
console.log(blockVar);
console.log(blockLet);

2. You will see the output in console tab as below.

I'm a block-scoped var

scope_lab. js : 19

x Uncaught ReferenceError: blockLet is scope_lab. js : 20
not defined
at scope_lab. js : 20: 13

3. You will see output for block Var, because it can be accessed outside the curly brackets {}. But you will see Reference Error for blockLet because it cannot be accessed outside the curly brackets due to which it is known as block scoped variables. Such variables can only be accessed within curly brackets. You will see the same error for const as well.

Note: A ReferenceError occurs when code attempts to use a variable that has not been declared or is outside of its scope, preventing proper access or execution.

# Step 5: Scope of variables for function scope

1. In this step, you will explore how function-scoped variables work. For this, include the given code at the end of the JavaScript file and save the file.

function show(){
var functionVar = "I'm a block-scoped var";
let functionLet = "I'm a block-scoped let";
const functionConst = "I'm a block-scoped const";
}

show();
console. log(functionVar); // Throws ReferenceError
console. log(functionLet); // Throws ReferenceError
console.log(functionConst); // Throws ReferenceError

2. For the above code, when you view the output in the console, you will again see a Reference Error for var, let, and const. To see the output, you need to add the //
before the codes as shown below.

console.log(blockVar);
console.log(blockLet);

After putting // in front of above code it will look like as shown below.

// console.log(blockVar);
// console.log(blockLet);

Note: You can use // to convert a statement into a comment.

3. You will see Reference Error for function Var because it cannot be accessed outside the function making it a function scoped variable. Similarly, you will not be able to access let and const because they are block scoped variables.

Note: You will only see an error for functionVar because it acts as a blockage, preventing the execution of the subsequent lines of code. Ensure that your application is live throughout this process and that you have saved the file.

# Step 6: Perform Git commands

1. Perform git add to add the latest files and folder in the git environment.
git add -- a

· Make sure the terminal has the path as follows:

theia@theia-richaar ://home/project/jscoursetesting$
git add -- a

Replace jscoursetesting with your cloned repository folder name

2. Then, perform git commit in the terminal. While performing git commit, terminal can show a message to set up your git config -- global for the user. name and user. email. Then, you need to perform git config command as well for the user. name and user. email.

git config -- global user.email "you@example.com"

git config -- global user.name "Your Name"

git commit -m "message"

3. Then perform git push just by writing the given command in the terminal.
git push origin

· It will push all of your latest folders and files to your GitHub repository.
☐

# Practice task

1. Create one block using {} and declare variables using let, const, and var.

2. Then, try to reassign these variables within the curly braces {}. Check for any errors that may occur.

3. Next, try to reassign the same variables outside the block {} and check if assignment outside the sope of variables where the variables are assigned can be done or not.

# Summary

1. Variable scope overview:

· Global scope: Variables declared outside any block or function have a global scope and are accessible throughout the entire script.
☐

o Block scope: Variables declared within curly braces {} have block scope, accessible only within that block.
☐

o Function scope: Variables declared within a function have function scope, limited to that function's block.
☐

2. Variable declaration and initialization:

Used var, let, and const to declare and initialize variables in different scopes: global, block, and function.
☐

· Demonstrated the behavior of these variables in respective scopes by accessing them outside their defined scope.
☐

3. Output and scope analysis:

· Global variables were accessible everywhere in the script.
☐

· Block-scoped variables (inside {}) had limited accessibility, resulting in ReferenceErrors when accessed outside their blocks.
☐

· Function-scoped variables (inside a function) also led to ReferenceErrors when accessed outside the function.
☐

@ IBM Corporation. All rights reserved.

---
### download19
O arquivo download19.pdf está bloqueado pelo conteúdo e não foi possível extrair o texto.  

---

### download20 (transcrição)
Course Glossary

Welcome! This alphabetized glossary contains many of the terms you'll find within this course. This comprehensive glossary also includes additional industry-recognized terms not used in course videos. These terms are important for you to recognize when working in the industry, participating in user groups, and participating in other certificate programs.

Term — Definition
- Ajax (Asynchronous JavaScript and XML) — A set of web development techniques using various technologies, including JavaScript and XML/JSON, to create asynchronous web applications. It allows for updating parts of a web page without reloading the entire page.
- Array — A data structure used to store a collection of elements, each identified by an index or a key.
- Arrow Function — A concise way to write functions in JavaScript, introduced in ES6, with a simplified syntax compared to traditional function expressions.
- Asynchronous — Code execution that doesn't happen sequentially, allowing other code to run while waiting for an operation to complete. Commonly used with callbacks, promises, and async/await.
- Axios — A popular Promise-based HTTP client for making HTTP requests in the browser and Node.js. It provides an easy-to-use API and supports features like interceptors, cancellation, and more.
- BOM (Browser Object Model) — A set of objects provided by the browser that represent the browser's window. It includes objects like window, navigator, history, screen, and location, allowing interaction with the browser itself.
- Callback Function — A function passed as an argument to another function, to be executed later or upon the occurrence of a certain event.
- Callback Hell — A situation where multiple nested callbacks make code difficult to read and maintain, often encountered in asynchronous JavaScript.
- Closure — A function that retains access to variables from its parent scope even after the parent function has finished executing.
- Conditional Statements — Constructs like if, else if, and else used to execute different code based on specified conditions.
- DOM (Document Object Model) — A programming interface for web documents that represents the structure of HTML and XML documents, allowing scripts to manipulate the content and structure of web pages.
- Error Handling — The process of managing errors that occur during the execution of a program. In JavaScript, errors can be caught and handled using constructs like try ... catch, allowing developers to gracefully manage unexpected issues.
- ES6/ES2015 — Refers to the sixth edition of the ECMAScript standard, introducing new syntax and features like arrow functions, classes, let/const, and more.
- Event — An action or occurrence recognized by a program that can be handled by event listeners to trigger specific functionality.
- Fetch — A modern API for making network requests in browsers, used to fetch resources asynchronously from the server. It uses promises to handle responses.
- Function Closure — A function that retains access to variables from its parent scope, even after the parent function has finished executing. This allows the inner function to access and manipulate the variables of the outer function.
- Function Hoisting — In JavaScript, function declarations are hoisted to the top of their scope during the compilation phase. This means that you can call a function before it's declared in the code.
- Function — A block of code that can be called and executed to perform a specific task or calculate a value.
- JavaScript (JS) — A high-level, interpreted programming language used to create dynamic and interactive web content.
- JSON (JavaScript Object Notation) — A lightweight data interchange format that is easy for humans to read and write and easy for machines to parse and generate.
- Loop — A control flow statement that allows code to be executed repeatedly based on a condition. Examples include for, while, and do ... while loops.
- Module — A reusable piece of code that encapsulates related functionality, allowing for better code organization and reuse.
- Node.js — An open-source, server-side JavaScript runtime environment that allows execution of JavaScript code outside of a web browser. It enables building scalable network applications.
- NPM (Node Package Manager) — A package manager for JavaScript that allows developers to discover, install, and manage packages and dependencies for Node.js applications.
- Object — A complex data type that stores key-value pairs, often used to represent real-world entities.
- Promise Chaining — The practice of linking promises together using their then() method to execute asynchronous operations sequentially or handle multiple asynchronous operations.
- Promise — An object representing the eventual completion or failure of an asynchronous operation, often used for handling asynchronous operations in a more readable and manageable way.
- String — A primitive data type used to represent textual data. Strings are sequences of characters enclosed in single or double quotes.
- Template Literals — Introduced in ES6, these allow embedding expressions into strings using backticks and ${ } syntax, providing a more readable way to create strings with variables.

(continuação da tabela)
- TypeScript — A superset of JavaScript that adds static typing and other features to help catch errors and make JavaScript development more scalable and maintainable.
- Variable — A named storage location used to hold data values that can change during the execution of a script.
- Window Object — The global object in the browser environment that represents the browser window. It contains properties and methods that can be accessed globally within the browser.

Skills Network

---

### download21 (transcrição)
Cheatsheet: JavaScript Async

JavaScript Promises, Callback, Fetch and Axios Terminologies

- JSON — It is a text-based format used for structuring data in a way that is both human-readable and machine-readable.
  Code example: { "name": "John Doe", "age": 30, "city": "New York", "email": "johndoe@email.com", "hobbies": ["Reading", "Hiking", "Cooking"] }

- Callback — A callback in JavaScript is a function passed as an argument to another function, which is then executed at a later time or under certain conditions.
  Example code shows a greet(name, callback) pattern where a callback function is invoked after logging a greeting.

- XMLHttpRequest Object — Used to create an instance of the XMLHttpRequest object to initiate an HTTP request.
  Example: var xhr = new XMLHttpRequest();

- XMLHttpRequest Open Methods — The open() method sets up the request, specifying the HTTP method (GET, POST, etc.) and the URL.
  Example: xhr.open('GET', 'https://api.example.com/data', true);

- send() Method — Invokes sending the request to the specified URL.
  Example: xhr.send();

- Load Data Using XMLHttpRequest — Example HTML + JS for button to load users via xhr from https://jsonplaceholder.typicode.com/users; includes onload, onerror, parsing JSON, and displayUsers(users) that builds a list.

Promise Syntax
- Promises are used for tasks like fetching data from a server, reading files, or performing other time-consuming operations.
  Example:
  const myPromise = new Promise((resolve, reject) => {
    // Asynchronous operation...
  });

Promise with .then and .catch
- Example demonstrates setTimeout-based simulated async operation with resolve/reject and handling via then(success, error).

Fetch API Syntax
- Used for fetching resources from the web; returns a promise.
  fetch(url, options).then(response => { /* handle */ }).catch(error => { /* handle */ });

Fetch GET example
- fetch('https://jsonplaceholder.typicode.com/posts').then(handleResponse).then(data => { console.log('GET Request Result:', data); }).catch(error => { console.error('Error:', error); });

Fetch POST example
- Example building newPost object, fetch with method: 'POST', headers {'Content-Type': 'application/json'}, body: JSON.stringify(newPost), then(handleResponse)...

Fetch PUT, PATCH, DELETE examples
- PUT example shows updating posts/1 with method 'PUT' and JSON body.
- PATCH example shows partial update.
- DELETE example uses method: 'DELETE' and checks response.ok, error handling.

Axios Library Syntax
- axios({ method: 'HTTP_METHOD', url: 'URL', headers: { ... }, data: { ... } }).then(response => { /* success */ }).catch(error => { /* handle errors */ });
- Install: npm install axios
- Axios supports HTTP methods: GET, POST, PUT, DELETE, etc.

(The document also includes repeated examples and notes about handling responses and errors, plus a Skills Network footer.)

---
### download22.pdf — About npm / cdn to Get Axios

What is Node.js?

Node.js utilizes Chrome's V8 JavaScript engine, enabling developers to run JavaScript on the server side and allowing them to create scalable and high-performance applications. One of its key features is its non-blocking, event-driven design, making it efficient for building real-time applications.

How to Install Node.js:

- Download Node.js: Visit the official Node.js website and download the installer for your operating system from https://nodejs.org/en.
- Install Node.js: Follow the installation instructions to run the installer.
- Verify Installation: Open a terminal or command prompt and type node -v to verify the installation of Node.js. You should see the installed version number.

What is npm?

npm stands for Node Package Manager. It serves as a package manager for Node.js modules and packages. Npm installs manages, and shares packages of code from the registry (which is a collection of packages hosted on servers).

How to Use npm:

- Installing Packages: To install a package, use npm install <package-name> in the terminal of any code editor of your choice. For example, npm install express installs the Express framework.
- Using Packages: After installation, you can include these packages in your Node.js application using require(). For instance, const express = require('express').
- Managing Packages: Use npm commands like npm uninstall <package-name> to remove packages, npm update <package-name> to update packages, and npm search <keyword> to search for packages in the npm registry.
- Package.json: This file contains metadata about the project and the list of dependencies. You can create it manually or by using npm init to create a new project.

Node.js and npm have become integral parts of modern web development, empowering developers to create robust and scalable applications using JavaScript.

Axios

Axios is a JavaScript library used primarily for making HTTP requests from both Node.js environments and web browsers. It provides a simple and intuitive API for handling asynchronous HTTP requests. Axios supports various features such as interceptors, the ability to cancel requests, automatic JSON data transformation, and much more.

Installing Axios

Firstly, ensure you have Node.js and npm installed. Then, you can install Axios using npm:

npm install axios

Using Axios in Node.js

Here's an example of how you can make a simple GET request using Axios in a Node.js script:

```js
// Import Axios
const axios = require('axios');
// Make a GET request
axios.get('https://jsonplaceholder.typicode.com/posts')
  .then(response => {
    // Handle successful response
    console.log('Response:', response.data);
  })
  .catch(error => {
    // Handle error
    console.error('Error:', error);
  });
```

In this example:

- We import Axios using require('axios').
- Use axios.get to make a GET request to a sample API endpoint (https://jsonplaceholder.typicode.com/posts).
- The .then block handles the successful response, and the data is logged to the console.
- The .catch block catches any errors that may occur during the request and logs them to the console.

You can perform various HTTP methods (GET, POST, PUT, DELETE, etc.) using Axios by calling axios.<method> (e.g., axios.post, axios.put, axios.delete) and handling their respective responses and errors with .then and .catch blocks.

Remember, Axios returns Promises, allowing you to use async/await to handle asynchronous requests in a more synchronous style. For instance:

```js
async function fetchData() {
  try {
    const response = await axios.get('https://jsonplaceholder.typicode.com/posts');
    console.log('Response: ', response.data);
  } catch (error) {
    console.error('Error:', error);
  }
}
fetchData();
```

This async/await example achieves the same result as the previous example but using a more synchronous-looking code structure.

---

### download23.pdf — Hands-on Lab: Call API to Fetch Weather Data Using fetch()

Estimated time needed: 30 minutes

What you will learn

In this lab, you will integrate an external API OpenWeatherMap into a web application using JavaScript. You will learn how to fetch data asynchronously, parse JSON responses, and dynamically update the webpage based on the received information. You will understand the core concepts of API integration, asynchronous operations, DOM manipulation, and user interaction, providing a foundational understanding of web development practices for utilizing external data sources in a simple interface.

Learning objective

After completing this lab, you will be able to:

- User-friendly weather retrieval: Enable user input for city names, facilitating the retrieval of real-time weather information via an intuitive web interface.
- API integration for weather data: Utilize the OpenWeatherMap API to fetch precise weather data based on user-entered cities, dynamically displaying temperature and weather descriptions on the webpage.
- HTML form submission handling and JS event implementation: Manage form submissions within HTML and implement event listeners in JavaScript, ensuring smooth user interactions and data retrieval processes.
- Demonstration of asynchronous requests and dynamic DOM updates: Showcase the practical application of asynchronous requests using fetch(), parsing JSON responses, and dynamically updating the DOM to display fetched weather details seamlessly, eliminating the need for page refreshes.

Prerequisites

- Basic Knowledge of HTML.
- Web browser with a console (Chrome DevTools, Firefox Console, and so on).

Step 1: Setting up the environment

1. Clone your repository, open a new terminal, run:
   git clone <github-repository-url>
   cd <repository-folder-name>

2. Create folder weatherReport and files:
   - weather_report.html
   - weather_report.js

3. You need an OpenWeatherMap API key (sign up at https://openweathermap.org/). After signing up get your API key from the Dashboard → API keys.

Built-in API request by city name

You can call by city name or city name, state code and country code. Please note searching by states available only for the USA locations.

API call
- https://api.openweathermap.org/data/2.5/weather?q={city name}&appid={API key}
- https://api.openweathermap.org/data/2.5/weather?q={city name},{country code}&appid={API key}
- https://api.openweathermap.org/data/2.5/weather?q={city name},{state code},{country code}&appid={API key}

Create HTML Structure

weather_report.html (basic template)

```html
<!DOCTYPE html>
<html>
<head>
  <title>Weather Report</title>
</head>
<body>
  <h1>Weather Report</h1>
  <form id="weatherForm">
    <label for="city">Enter City :</label>
    <input type="text" id="city" name="city">
    <button type="submit">Get Weather</button>
  </form>
  <div id="weatherInfo"></div>
  <script src="./weather_report.js"></script>
</body>
</html>
```

Step 2: Defining variables and functions

1. Create function showweatherDetails in weather_report.js:

```js
function showweatherDetails(event) {
  event.preventDefault();
}
```

2. Inside showweatherDetails initialize variables:

```js
const city = document.getElementById('city').value;
const apikey = 'c4f86ece00bc8aa272652ac9065af12d'; // Replace with your own API key
const apiUrl = `https://api.openweathermap.org/data/2.5/weather?q=${city}&appid=${apiKey}&units=metric`;
```

3. Use fetch to get data:

```js
fetch(apiUrl)
  .then(response => response.json())
  .then(data => {
    const weatherInfo = document.getElementById('weatherInfo');
    weatherInfo.innerHTML = `<h2>Weather in ${data.name}</h2>
      <p>Temperature: ${data.main.temp} &#8451;</p>
      <p>Weather: ${data.weather[0].description}</p>`;
  })
  .catch(error => {
    console.error('Error fetching weather:', error);
    const weatherInfo = document.getElementById('weatherInfo');
    weatherInfo.innerHTML = `<p>Failed to fetch weather. Please try again.</p>`;
  });
```

4. Attach form submit listener (outside the function):

```js
document.getElementById('weatherForm').addEventListener('submit', showweatherDetails);
```

Step 3: Check the output

- Open weather_report.html with Live Server (port 5500).
- Enter a city name and click Get Weather. The page updates dynamically with city, temperature in Celsius, and weather description.
- Note: Do not upload real API keys to public repos; replace with 'YOUR_API_KEY' before pushing.

Practice Task

- Use alternate OpenWeatherMap endpoints such as by latitude/longitude:
  https://api.openweathermap.org/data/2.5/weather?lat={lat}&lon={lon}&appid={API key}
- Modify the HTML to collect latitude and longitude inputs and fetch weather for those coordinates.

Summary

- Built a form to input a city and fetch weather via OpenWeatherMap.
- Used fetch() to request data, parsed JSON responses, and updated the DOM with the results.
- Implemented error handling with catch().

---

### download24.pdf — Hands-on Lab: Develop an Application to Fetch Health Articles using XMLHttpRequest

Estimated time needed: 30 minutes

What you will learn

In this lab, you will explore the dynamic creation of HTML elements using JavaScript, enabling the manipulation and real-time construction of webpage content. You will learn to parse JSON data to extract and structure information, facilitating seamless display on a webpage. Additionally, you will discover how to organize and present data by creating unordered lists.

Learning objectives

After completing this lab, you will be able to:

- XHR integration proficiency: Acquire the skill to integrate XMLHttpRequest (XHR) into web applications for fetching external JSON data, facilitating dynamic content retrieval.
- Dynamic HTML construction: Develop the ability to dynamically construct the HTML elements using JavaScript, enabling the creation of structured content and layout modification quickly.
- JSON data manipulation: Learn to handle and parse JSON data retrieved from external sources, facilitating its structured presentation within a webpage.
- List generation competence: Explore the creation of unordered lists to organize and display data, mastering techniques for efficient information organization on webpages.
- Iterative content rendering: Understand and implement iterative content rendering, allowing for the dynamic display of multiple articles fetched from JSON data onto a webpage, enhancing the user experience through comprehensive content presentation.

Prerequisites

- Basic Knowledge of HTML and GitHub.
- Web browser with a console (Chrome DevTools, Firefox Console, and so on).

Step 1: Setting up the environment

1. Clone your repo and create folder healthArticle with files:
   - health_article.html
   - health_article.js
   - health_article.json (contains the article data)

2. health_article.html template:

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Health Articles</title>
</head>
<body>
  <h1>Health Articles</h1>
  <div id="articles"></div>
  <script src="./health_article.js"></script>
</body>
</html>
```

3. health_article.json: add articles data (title, description, ways_to_achieve, benefits).

Step 2: Perform Git commands

- git add --a
- git commit -m "message"
- git push origin

Step 3: Defining object and variables for XMLHttpRequest

```js
var xhr = new XMLHttpRequest();
var url = './health_article.json';
```

Step 4: URL definition and request set up

```js
xhr.open('GET', url, true);
xhr.responseType = 'json';
```

Step 5: Response type specification

- xhr.responseType = 'json';

Step 6: Handling the 'onload' event

```js
xhr.onload = function() {
  var articles = xhr.response.articles;
  var articlesDiv = document.getElementById('articles');

  articles.forEach(function(article) {
    var articleDiv = document.createElement('div');
    articleDiv.classList.add('article');

    var title = document.createElement('h2');
    title.textContent = article.title;

    var description = document.createElement('p');
    description.textContent = article.description;

    var waysHeader = document.createElement('h3');
    waysHeader.textContent = 'Ways to Achieve:';
    var waysList = document.createElement('ul');
    article.ways_to_achieve.forEach(function(way) {
      var listItem = document.createElement('li');
      listItem.textContent = way;
      waysList.appendChild(listItem);
    });

    var benefitsHeader = document.createElement('h3');
    benefitsHeader.textContent = 'Benefits:';
    var benefitsList = document.createElement('ul');
    article.benefits.forEach(function(benefit) {
      var listItem = document.createElement('li');
      listItem.textContent = benefit;
      benefitsList.appendChild(listItem);
    });

    articleDiv.appendChild(title);
    articleDiv.appendChild(description);
    articleDiv.appendChild(waysHeader);
    articleDiv.appendChild(waysList);
    articleDiv.appendChild(benefitsHeader);
    articleDiv.appendChild(benefitsList);
    articlesDiv.appendChild(articleDiv);
  });
};
```

Step 7: Sending the request

```js
xhr.send();
```

Step 8: Check the output

- Open health_article.html with Live Server (port 5500). The page will display articles with titles, descriptions, "Ways to Achieve" lists and "Benefits" lists, dynamically created from the JSON file.

Practice task

- Create a separate JSON and XHR flow to fetch news articles similarly.

Summary

- Created XHR request (xhr.open + xhr.responseType = 'json').
- Parsed xhr.response in xhr.onload and dynamically built DOM elements (div, h2, p, ul, li) for each article.
- Sent request with xhr.send() and displayed results on the webpage.

---

Design a JSON Schema to Define the Structure of a JSON Object


Como Projetar um Esquema JSON para Definir a Estrutura de um Objeto JSON
Introdução ao JSON
A notação de objeto JavaScript (JSON) é um formato leve e amigável que permite que humanos e máquinas leiam, escrevam, analisem e gerem dados com facilidade. JSON é independente de linguagem, embora tenha se originado do JavaScript.

Por que o JSON é importante?
Legibilidade: JSON é legível para humanos e fácil de entender, tornando simples para desenvolvedores e não desenvolvedores compreenderem dados estruturados.

Intercâmbio de dados: Serve como um formato universal de intercâmbio de dados. Aplicações e sistemas em diferentes linguagens de programação podem trocar dados facilmente usando JSON.

APIs da web: A maioria das APIs da web utiliza JSON como o formato de dados preferido para comunicação entre servidores e clientes. É um padrão para transmitir dados em requisições HTTP, tornando-se essencial para o desenvolvimento web.

Armazenamento de dados: JSON armazena configurações, estados de aplicação e dados estruturados em bancos de dados ou arquivos devido à sua simplicidade e facilidade de uso.

Independente de linguagem: Quase qualquer linguagem de programação pode usar JSON, estendendo-se além do JavaScript. Bibliotecas e analisadores que suportam várias linguagens facilitam a interoperabilidade de dados entre sistemas, independentemente da linguagem de programação subjacente.

Suporta vários tipos de dados: JSON armazena configurações, estados de aplicação e dados estruturados em bancos de dados ou arquivos devido à sua simplicidade e facilidade de uso.

Fácil integração com JavaScript: JSON é uma combinação natural para JavaScript porque sua sintaxe se assemelha a literais de objetos JavaScript, tornando fácil trabalhar com ele em aplicações JavaScript.

Leve: A simplicidade e a sintaxe mínima do JSON contribuem para sua natureza leve, tornando-o eficiente para transmitir dados por redes, especialmente em cenários onde a largura de banda é uma preocupação.

Vamos considerar um exemplo específico para explorar o JSON usando o código fornecido:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
// Define a JSON object representing information about a person
const personJSON = {
  "name": "John Doe",
  "age": 30,
  "email": "john@example.com",
  "address": {
    "street": "123 Main St",
    "city": "Anytown",
    "country": "USA"
  },
  "tags": ["JavaScript", "Node.js", "Web Development"],
  "isStudent": false,
  "workExperience": null
};
// Convert the JSON object to a string
const jsonString = JSON.stringify(personJSON);
console.log(jsonString);

Copied!

Wrap Toggled!
Neste exemplo:

personJSON encapsula informações sobre um indivíduo com campos como nome, idade, e-mail, endereço, tags, isStudent e workExperience.
O campo endereço é um objeto JSON embutido dentro do objeto JSON principal.
O campo tags é um array contendo strings.
isStudent é um valor booleano, e workExperience é nulo.
JSON.stringify() converte o objeto JavaScript personJSON em uma string JSON.
No JSON, tanto as chaves quanto os valores devem ser colocados entre aspas duplas.
A saída resultante de console.log(jsonString) será uma representação em string do objeto JSON:


JSON versus objeto JavaScript
A notação de objeto JavaScript (JSON) e os objetos JavaScript têm semelhanças e diferenças principais.

JSON

Formato: JSON opera como um formato baseado em texto para troca de dados. É um formato padronizado usado para transmitir e armazenar dados.
Sintaxe: A sintaxe JSON adere estritamente a um conjunto específico de regras. As chaves devem estar entre aspas duplas, e os valores podem ser strings, números, arrays, objetos, booleanos ou null.
Uso: Principalmente utilizado para intercâmbio de dados entre sistemas. Comumente usado em APIs, armazenamento de dados e comunicação entre servidores e clientes.
Representação em String: JSON tem representação em string. Para utilizar JSON em JavaScript, é necessário analisá-lo em um objeto JavaScript através de JSON.parse().
Objetos JavaScript:

Nativo do JavaScript: Objetos em JavaScript são um tipo de dado fundamental e armazenam coleções de dados como pares chave-valor.
Sintaxe: A sintaxe de objeto JavaScript é flexível. As chaves podem ser strings ou identificadores sem aspas, e os valores podem ser de qualquer tipo de dado.
Uso: Organiza e manipula dados dentro de aplicações JavaScript, modelando entidades do mundo real ou estruturas de dados dentro da linguagem.
Representação nativa: Objetos são nativos do JavaScript. Eles não são representados como strings e podem ser criados, manipulados e acessados diretamente dentro do código JavaScript.
Diferenças

Aspecto	JSON	Objetos JavaScript
Forma	JSON é um formato baseado em texto usado para troca de dados.	Objetos JavaScript são uma parte nativa da linguagem JavaScript.
Sintaxe	JSON tem uma sintaxe mais rígida; as chaves devem estar entre aspas duplas.	Objetos JavaScript têm uma sintaxe mais flexível para chaves e valores.
Representação	Permite converter a representação em string JSON em um objeto JavaScript ao analisá-lo.	Permite a manipulação direta de objetos JavaScript sem a necessidade de conversão, pois são nativos da linguagem.
JSON é um formato de dados padronizado usado para intercâmbio de dados. Ao mesmo tempo, os objetos JavaScript são uma parte fundamental da linguagem JavaScript usados para organizar e trabalhar com dados dentro do código JavaScript.

Vamos obter insights com a ajuda de um exemplo.

Estrutura JSON versus objeto JavaScript

Estrutura JSON:

1
2
3
4
5
6
7
8
// JSON structure represented as a string
const jsonString = '{"name": "John Doe", "age": 30, "isStudent": true}';
// JavaScript object
const personObject = {
  name: "Jane Smith",
  age: 25,
  isStudent: false
};

Copied!

Wrap Toggled!
Diferença no uso
Usando JSON (Representação em String):

1
2
3
4
5
6
7
8
// Parsing JSON string to JavaScript object
const parsedJSON = JSON.parse(jsonString);
console.log(parsedJSON); // Output: { name: 'John Doe', age: 30, isStudent: true }
console.log(typeof parsedJSON); // Output: object
Directly Using JavaScript Object:
console.log(personObject); // Output: { name: 'Jane Smith', age: 25, isStudent: false }
console.log(typeof personObject); // Output: object

Copied!

Wrap Toggled!
Explicação
Estrutura JSON: Representa a estrutura JSON como uma string (jsonString) que requer análise usando JSON.parse() para se tornar um objeto JavaScript.

Objeto JavaScript: personObject é um objeto JavaScript nativo, que não requer análise e pode ser acessado e manipulado diretamente dentro do código JavaScript.

Este exemplo demonstra a diferença na representação e uso entre uma estrutura JSON (em forma de string) e um objeto JavaScript. Analise o JSON para transformá-lo em um objeto JavaScript, enquanto o objeto JavaScript é prontamente utilizável dentro do código JavaScript sem etapas adicionais.

Em conclusão, JSON, ou Notação de Objeto JavaScript, é um formato de intercâmbio de dados versátil e independente de linguagem que oferece legibilidade, flexibilidade e ampla aplicabilidade no desenvolvimento web. Seu papel em facilitar a troca de dados sem costura e sua simplicidade e compatibilidade com JavaScript o tornam uma ferramenta fundamental na programação moderna.
[MUSIC] Welcome to Introduction
to Development Concepts. After watching this video, you will be
able to define software engineering and explain JavaScript's
role in web development. The software engineering world
is where creativity meets precision in crafting
cutting-edge applications. You can create high-quality, reliable and maintainable software by embracing
a systematic and disciplined approach and using well-defined principles,
methods, and practices. JavaScript is a popular and versatile
programming language that plays a crucial role in modern software development. Let's explore key development concepts and practices in software engineering using
JavaScript as our programming language. Let's first understand the software
development lifecycle, or SDLC. It is a structured approach to guiding
the creation of software applications. It comprises various phases like
requirements analysis, design, implementation, testing,
deployment, and maintenance. JavaScript is used in different phases
of SDLC to build web applications both on the client and server-sides. JavaScript is an object
oriented programming or OOP language that uses
objects as building blocks. Developers use classes and
objects to model real-world entities, enhancing code reusability and
maintainability. For instance,
imagine defining a class for a car and creating instances to represent
different cars in your software. Efficient data structures and algorithms
are the backbone of software engineering. You can use arrays, objects, maps, and
sets in JavaScript to store and manipulate data. You can also access various
built-in methods and libraries to perform common operations
like sorting and searching. You can use design patterns as
reusable solutions to common problems in software design. JavaScript developers use design
patterns to create robust, scalable, and maintainable code. Some popular design patterns in JavaScript
include the singleton, factory, and observer patterns. These patterns help structure code and
improve code quality. Version control systems
like Git are essential for collaborative software development. They enable multiple developers
to work on the same code base, track changes, and resolve conflicts. JavaScript projects provide version
control to ensure code integrity and collaboration. Testing is a critical aspect
of software engineering. JavaScript developers write unit,
integration, and end-to-end tests to ensure
their code works correctly. You can use common tools like Jest and
Mocha for testing JavaScript applications. Quality assurance processes are integral
to delivering reliable software. JavaScript is the cornerstone
of web development, it powers interactivity and
dynamic behavior on websites. Front-end frameworks like React, Angular
and vue.js use JavaScript extensively. Node.js, a server side JavaScript runtime,
is popular for building back-end services. Asynchronous programming allows tasks to
run independently without waiting for other tasks to finish,
improving efficiency. JavaScript uses callbacks,
promises, and async/await to handle asynchronous operations like
fetching data from servers or performing input/output operations
without blocking the main thread. Functional programming emphasizes using
pure functions and immutable data, leading to more predictable and
maintainable code. Using JavaScript, you can utilize higher
order functions like map, filter, and reduce to manipulate arrays and
use functions successfully. ECMAScript 2015 or ES6 and its subsequent
versions provide regular updates to the language by
introducing new syntax and features to improve developer
productivity and code readability. JavaScript boasts various
features like arrow functions, restructuring assignments, let and
const for variable declarations, template literals, and
the implementation of classes. Error handling and debugging revolve
around implementing strategies to detect, handle, and debug errors effectively,
ensuring the robustness of applications. JavaScript puts this into practice
by using the try catch blocks for error handling with tools
like the browser console and employing debugging tools
like Chrome DevTools. Frameworks and libraries leverage existing
tools to expedite development and streamline common tasks. In JavaScript, this translates to using
frameworks like React, Angular and vue.js for frontend development while
employing libraries such as Express.js for back-end development. Testing and test-driven development, or
TDD, represents a concept where tests are crafted before code creation to
ensure reliability and maintainability. In JavaScript, this involves
the utilization of testing frameworks like Jest, Mocha, or Jasmine to script and
automate application tests. Security is vital in software engineering. JavaScript developers must be aware
of security vulnerabilities such as cross-site scripting or XSS and
cross-site request forgery or CSRF, and follow best practices to mitigate these
risks when building web applications. Lastly, software engineering doesn't
end with deployment, maintenance and documentation are ongoing processes. Proper documentation,
including comments and ReadMe files helps other developers
understand and extend the code. JavaScript developers often use tools
like JSDoc for documenting code. In this video, you learn that JavaScript
guides the creation of web applications across SDLC phases, ensuring a structured
and effective development process. JavaScript's object-oriented principles
and versatile data structures empower developers to enhance code reusability and
manipulate data effectively. Design patterns like singleton, version
control with Git and robust testing using tools like Jest contribute to creating
maintainable and scalable JavaScript code. JavaScript is the driving force behind
web development, enabling dynamic and interactive features on both the front and
back end. JavaScript excels in asynchronous
programming, utilizing callbacks, promises and async/await,
while also embracing functional programming principles for
predictable and maintainable code. And you should stay updated
with JavaScript's evolution, leverage effective error handling,
address security vulnerabilities, and prioritize ongoing maintenance and
documentation for robust applications. [MUSIC]
[MUSIC] Welcome to Introduction
to Development Concepts. After watching this video, you will be
able to define software engineering and explain JavaScript's
role in web development. The software engineering world
is where creativity meets precision in crafting
cutting-edge applications. You can create high-quality, reliable and maintainable software by embracing
a systematic and disciplined approach and using well-defined principles,
methods, and practices. JavaScript is a popular and versatile
programming language that plays a crucial role in modern software development. Let's explore key development concepts and practices in software engineering using
JavaScript as our programming language. Let's first understand the software
development lifecycle, or SDLC. It is a structured approach to guiding
the creation of software applications. It comprises various phases like
requirements analysis, design, implementation, testing,
deployment, and maintenance. JavaScript is used in different phases
of SDLC to build web applications both on the client and server-sides. JavaScript is an object
oriented programming or OOP language that uses
objects as building blocks. Developers use classes and
objects to model real-world entities, enhancing code reusability and
maintainability. For instance,
imagine defining a class for a car and creating instances to represent
different cars in your software. Efficient data structures and algorithms
are the backbone of software engineering. You can use arrays, objects, maps, and
sets in JavaScript to store and manipulate data. You can also access various
built-in methods and libraries to perform common operations
like sorting and searching. You can use design patterns as
reusable solutions to common problems in software design. JavaScript developers use design
patterns to create robust, scalable, and maintainable code. Some popular design patterns in JavaScript
include the singleton, factory, and observer patterns. These patterns help structure code and
improve code quality. Version control systems
like Git are essential for collaborative software development. They enable multiple developers
to work on the same code base, track changes, and resolve conflicts. JavaScript projects provide version
control to ensure code integrity and collaboration. Testing is a critical aspect
of software engineering. JavaScript developers write unit,
integration, and end-to-end tests to ensure
their code works correctly. You can use common tools like Jest and
Mocha for testing JavaScript applications. Quality assurance processes are integral
to delivering reliable software. JavaScript is the cornerstone
of web development, it powers interactivity and
dynamic behavior on websites. Front-end frameworks like React, Angular
and vue.js use JavaScript extensively. Node.js, a server side JavaScript runtime,
is popular for building back-end services. Asynchronous programming allows tasks to
run independently without waiting for other tasks to finish,
improving efficiency. JavaScript uses callbacks,
promises, and async/await to handle asynchronous operations like
fetching data from servers or performing input/output operations
without blocking the main thread. Functional programming emphasizes using
pure functions and immutable data, leading to more predictable and
maintainable code. Using JavaScript, you can utilize higher
order functions like map, filter, and reduce to manipulate arrays and
use functions successfully. ECMAScript 2015 or ES6 and its subsequent
versions provide regular updates to the language by
introducing new syntax and features to improve developer
productivity and code readability. JavaScript boasts various
features like arrow functions, restructuring assignments, let and
const for variable declarations, template literals, and
the implementation of classes. Error handling and debugging revolve
around implementing strategies to detect, handle, and debug errors effectively,
ensuring the robustness of applications. JavaScript puts this into practice
by using the try catch blocks for error handling with tools
like the browser console and employing debugging tools
like Chrome DevTools. Frameworks and libraries leverage existing
tools to expedite development and streamline common tasks. In JavaScript, this translates to using
frameworks like React, Angular and vue.js for frontend development while
employing libraries such as Express.js for back-end development. Testing and test-driven development, or
TDD, represents a concept where tests are crafted before code creation to
ensure reliability and maintainability. In JavaScript, this involves
the utilization of testing frameworks like Jest, Mocha, or Jasmine to script and
automate application tests. Security is vital in software engineering. JavaScript developers must be aware
of security vulnerabilities such as cross-site scripting or XSS and
cross-site request forgery or CSRF, and follow best practices to mitigate these
risks when building web applications. Lastly, software engineering doesn't
end with deployment, maintenance and documentation are ongoing processes. Proper documentation,
including comments and ReadMe files helps other developers
understand and extend the code. JavaScript developers often use tools
like JSDoc for documenting code. In this video, you learn that JavaScript
guides the creation of web applications across SDLC phases, ensuring a structured
and effective development process. JavaScript's object-oriented principles
and versatile data structures empower developers to enhance code reusability and
manipulate data effectively. Design patterns like singleton, version
control with Git and robust testing using tools like Jest contribute to creating
maintainable and scalable JavaScript code. JavaScript is the driving force behind
web development, enabling dynamic and interactive features on both the front and
back end. JavaScript excels in asynchronous
programming, utilizing callbacks, promises and async/await,
while also embracing functional programming principles for
predictable and maintainable code. And you should stay updated
with JavaScript's evolution, leverage effective error handling,
address security vulnerabilities, and prioritize ongoing maintenance and
documentation for robust applications. [MUSIC]
Welcome to introduction
to JavaScript and ES6. After watching this video, you will be able to explain how JavaScript enhances user
experience in web development, explain how to create a basic JavaScript
code in HTML file, and describe the various ways to display or output
information in JavaScript. JavaScript is a versatile and widely
used programming language that plays a pivotal
role in web development. It allows developers to create interactive and dynamic websites enhancing the user experience. Let's understand the
basics of JavaScript and learn how to make web
pages come to life with it. JavaScript was created
in the mid '90s and has since become a fundamental part of
web development. JavaScript is executed
in web browsers, making it an essential tool for enhancing the
user experience. Here are a couple of things
JavaScript is known for. Manipulating the DOM: JavaScript can change a web page's content
structure and style. It's like having a magic
wand for web elements. Handling events: From button
clicks to mouse movements, JavaScript can respond to
various user interactions, making websites more engaging. When you visit a website, your web browser downloads
the HTML and CSS files. It also downloads
JavaScript code, which serves as instructions
for your browser on how to make the web page
interactive and user friendly. For example, when
you click a button, JavaScript can be programmed
to show a message, change the page's colors, or load new information without needing to
refresh the whole page. JavaScript is like
the magician behind the scenes that brings your
favorite websites to life, making them dynamic
and responsive. JavaScript's evolution
over the years has brought about
several significant updates and enhancements, with ECMA script 6, ES6 or ECMA script 2015 being one of the most
transformative milestones. It marked a
significant upgrade to the JavaScript language and introduced numerous
new features, syntax enhancements, and
improved functionality, making JavaScript more powerful
and developer friendly. JavaScript is a fundamental part of web development and is used in various ways.
Enhancing user experience: JavaScript can
validate form data, create interactive forms, and provide real time
feedback to users. Dynamic web content: It can load new content
without refreshing the entire page like real
time social media feeds. Animations and visual effects: JavaScript can create
animations, sliders, and other visual effects to
improve website aesthetics. Web applications: Many web apps such as Google
Docs, Netflix, or Trello, rely heavily on
JavaScript to provide a smooth and responsive
user experience. Before we dive into coding, let's explore where
we can incorporate JavaScript code and visualize the impressive results
it can produce. To create JavaScript
in an HTML file, you have a few options. The most common methods
are: In-line JavaScript-- You can include JavaScript
code directly in your HTML file using the
script tag within the body. You can also place this tag
within the head section, but it may lead to
unexpected results. External JavaScript file: For larger projects and
better organization, it's recommended to put
your JavaScript code in a separate JS file and link it to your HTML file using the script tag with
a SRC attribute. Here's how. Step 1, create a separate JS file, e.g. script.js, and add your
JavaScript code to it. Step 2, in your HTML file
include a script tag with the SRC attribute pointing to your JavaScript file just before the closing body tag
for best practice. This approach keeps your
HTML structure clean and separates your JavaScript code for easier maintenance
and reuse. In JavaScript, there are various ways to display
or output information. Here are the most
common methods. Using console.log: it's
handy for checking values, debugging errors, and seeing
the results of your code. To use console.log,
follow these steps. To open the developer
console in most browsers, press F12 or right click
anywhere on the web page and select Inspect
or Inspect element, then go to the console tab. Altering the DOM: JavaScript can
dynamically change the content of your web
page by altering the DOM. You can update text, insert elements, or
modify attributes. Here's a simple example. In this case, the
JavaScript code finds an HTML element with the ID output and
changes its content. You can create pop-up
dialogues to display messages or
prompt users for input. JavaScript provides three
types of dialogues. Alert shows a message
in a pop up dialogue. Confirm displays a message and prompts the user
for a yes no response. Prompt displays a message and allows the user
to input text. Choose the method that
best suits your purpose. In this video, you learned that JavaScript is a crucial
language for web development, making websites interactive
and responsive. JavaScript instructs
browsers to update web pages dynamically
without full reloads. ES6 improved JavaScript
with new features, enhancing its power and
developer friendliness. JavaScript is essential for user experience, dynamic
content, animations, and web applications and
JavaScript can be embedded in HTML or linked externally with output shown
via console.log, DOM manipulation,
or pop up dialogs.[MUSIC] Welcome to data types and variables. After watching this video, you will
be able to explain how variables in JavaScript store and manage data,
explain common naming conventions and rules, and define the concept
of data types in JavaScript. In JavaScript, variables are used
to store and manage data. Variables act as containers for
various types of information or values. You can think of a variable as a named
storage location that holds data, and you can use this data in
your JavaScript code. Let's explore some key points
about variables in JavaScript. For the initialization of a variable, you can optionally assign
an initial value to it. To create a variable in JavaScript, you also need to declare it using one
of three keywords, var, let, or const. The declaration tells JavaScript that
you want to reserve a spot in memory to store data. Var was the original way to declare
variables in JavaScript, and it has function level scope. This means that a variable declared with
var is available throughout the entire function in which it is declared. Let was introduced in ES6 and
provides block level scoping. This means, that a variable declared with
let is only available within the block enclosed by curly braces
in which it is defined. This scope is more predictable and
less error prone. Const is also introduced in ES6 and is used to declare variables
with constant values. Once you assign a value
to a const variable, you cannot reassign it a different value. It also has block level scoping. Const variables are often used for
values that should not change, such as mathematical constants or
references to immutable objects. Variable names must start with a letter,
underscore, or dollar sign, and can contain letters, numbers,
underscores, and dollar signs. Variable names are case sensitive. Here are a few of the examples
of variable names. Variables declared with
let can be reassigned, but not redeclared within the same block. While variables declared with const are
constant and can neither be reassigned nor redeclared within the same block. Understanding variables is crucial for
managing and manipulating data in JavaScript programs. They allow you to work with
different types of information, making your code dynamic and adaptable. In JavaScript, data types are
classifications or categories that specify what kind of data can be stored and
manipulated in a program. JavaScript is a dynamically typed
language, which means that you don't need to explicitly specify the data
type of a variable when you declare it. The data type is determined dynamically at
runtime based on the value you assign to the variable. JavaScript has several
built-in data types, which can be categorized into
the following major categories. Primitive data types,
composite data types. Let's learn about primitive data types. Strings represents text. A string is enclosed in single or
double quotes. Number represents both integers and
floating-point numbers. Boolean represents true or false values. Undefined represents a variable
that has been declared, but hasn't been assigned a value. Null represents an empty value or
absence of any object value. Now, let's learn about
composite data types. Composite data types
are those that can hold and manage multiple values as a single unit. These data types are used to organize and
manipulate collections of data, making it easier to work with
more complex structures. Array and
object are two composite data types. An array in JavaScript is a list like data
structure for storing multiple value. While an object is a collection
of key value pairs used for structured data storage. JavaScript's dynamic typing allows
variables to change data types during execution, making it a versatile language. Understanding these data types is crucial
for effective JavaScript programming, as it helps in working with
different kinds of data and performing various operations on them. In this video, you learn that
JavaScript variables store and manage data with optional initialization
using var, let, or const. Var has function-level scope,
let has block-level scope, and const is used for constants. Variable names are case sensitive and
start with and contain a letter,
underscore, or dollar sign. Primitive data types include strings,
numbers, booleans, undefined, and null. And composite data types like arrays and
objects, handle multiple values and
structured data. [MUSIC]
Welcome to Operators and Expressions. After watching this video, you will be able to Classify JavaScript operators into six categories and explain their uses. And Create expressions by integrating values, variables, and operators. Operators and expressions are fundamental concepts in JavaScript, as they are essential for performing various operations and calculations. Let's explore these concepts in more detail. Operators in JavaScript are special symbols or keywords used to perform operations on variables and values. JavaScript supports a variety of operators, including Arithmetic operators, Comparison operators, Logical operators, Assignment operators, Unary operators, and Type of operator. Now let's delve into each type of operator in detail. Arithmetic operators are used for basic mathematical calculations. Common arithmetic operators include addition, subtraction, multiplication, division, and modulus. Comparison operators are used to compare two values or variables and return a Boolean true or false result. Boolean comparison operators include equality, inequality, strict equality, strict inequality, less than, greater than, less than or equal to, and greater than or equal to. Logical operators are used to combine or manipulate Boolean values. Common logical operators include logical, and, logical, or, and logical, not. Assignment operators are used to assign values to variables. The most basic assignment operator is the equal sign. Unary operators operate on a single value or variable. Common unary operators include increment and decrement. The Type of operator is a built-in operator in JavaScript that allows you to determine the data type of a variable or an expression. It returns a string representing the type of operand. It is often used in conditional statements or for checking the type before performing certain operations. In these examples, the Type of operator is used to determine the type of variable, check the type in a conditional statement, and find the type of an expression. The possible return values for Type of are undefined, if the variable is declared but not defined, object for objects, arrays, and null, Boolean for Boolean values, number for numbers, and string for strings. Now let's learn about expressions. An expression is a combination of values, variables, and operators that can be evaluated to produce a single value. Expressions can be simple or complex and are an integral part of JavaScript code. Examples of expressions include arithmetic expressions involving combining numbers with operators, variable expressions including combining variables with operators, function call expressions involving calling a function and using its return value, conditional expressions involve using the ternary operator to create conditional expressions. Understanding operators and expressions is crucial for writing JavaScript code that effectively performs calculations, makes decisions, and manipulates data. They are the building blocks for creating complex algorithms and applications. In this video, you learned that Operators and expressions are fundamental concepts in JavaScript, allowing various operations and calculations. Operators consist of arithmetic, comparison, logical, assignment, unary, and type of operators. Expressions combine values, variables, and operators to produce single results used in arithmetic, variable assignment, function calls, or conditional logic. And a strong grasp of these concepts is crucial for effective JavaScript coding, enabling tasks from calculations to complex algorithms and application development.
Welcome to Operators and Expressions. After watching this video, you will be able to Classify JavaScript operators into six categories and explain their uses. And Create expressions by integrating values, variables, and operators. Operators and expressions are fundamental concepts in JavaScript, as they are essential for performing various operations and calculations. Let's explore these concepts in more detail. Operators in JavaScript are special symbols or keywords used to perform operations on variables and values. JavaScript supports a variety of operators, including Arithmetic operators, Comparison operators, Logical operators, Assignment operators, Unary operators, and Type of operator. Now let's delve into each type of operator in detail. Arithmetic operators are used for basic mathematical calculations. Common arithmetic operators include addition, subtraction, multiplication, division, and modulus. Comparison operators are used to compare two values or variables and return a Boolean true or false result. Boolean comparison operators include equality, inequality, strict equality, strict inequality, less than, greater than, less than or equal to, and greater than or equal to. Logical operators are used to combine or manipulate Boolean values. Common logical operators include logical, and, logical, or, and logical, not. Assignment operators are used to assign values to variables. The most basic assignment operator is the equal sign. Unary operators operate on a single value or variable. Common unary operators include increment and decrement. The Type of operator is a built-in operator in JavaScript that allows you to determine the data type of a variable or an expression. It returns a string representing the type of operand. It is often used in conditional statements or for checking the type before performing certain operations. In these examples, the Type of operator is used to determine the type of variable, check the type in a conditional statement, and find the type of an expression. The possible return values for Type of are undefined, if the variable is declared but not defined, object for objects, arrays, and null, Boolean for Boolean values, number for numbers, and string for strings. Now let's learn about expressions. An expression is a combination of values, variables, and operators that can be evaluated to produce a single value. Expressions can be simple or complex and are an integral part of JavaScript code. Examples of expressions include arithmetic expressions involving combining numbers with operators, variable expressions including combining variables with operators, function call expressions involving calling a function and using its return value, conditional expressions involve using the ternary operator to create conditional expressions. Understanding operators and expressions is crucial for writing JavaScript code that effectively performs calculations, makes decisions, and manipulates data. They are the building blocks for creating complex algorithms and applications. In this video, you learned that Operators and expressions are fundamental concepts in JavaScript, allowing various operations and calculations. Operators consist of arithmetic, comparison, logical, assignment, unary, and type of operators. Expressions combine values, variables, and operators to produce single results used in arithmetic, variable assignment, function calls, or conditional logic. And a strong grasp of these concepts is crucial for effective JavaScript coding, enabling tasks from calculations to complex algorithms and application development.
Welcome to Control Flow and Conditional Statements. After watching this video, you will be able to Define Control Flow and Conditional Statements in JavaScript and Assess and Compare various Conditional Statements. Control Flow and Conditional Statements are fundamental in directing the flow of a JavaScript program. Control Flow refers to the order in which statements are executed in a JavaScript program. While Conditional Statements, often referred to as decision-making statements, are used to manage this flow based on specified conditions. Some of the Conditional Statements in JavaScript are If Statement, Else If Statement, Else Statement, Nested If Else Statement, Switch Statement, and Ternary Operator. Let's explore each in more detail. The If Statement is used to execute a block of code if a specified condition is true. If the condition is false, the code block is skipped. In this example, the code checks if the age variable is greater than or equal to 18. If the condition is true, it prints, you are an adult. Otherwise, it prints, you are a minor. The Else If Statement allows you to test multiple conditions sequentially, especially when you have more than two possible outcomes. For instance, if you have an HTML file with a P tag, and this P tag has an ID called timeMessage, then you can include the messages in the P tag using the given code in a separate JS file. Here, the code checks the value of time and prints a different greeting based on the time of day on your browser. The Else Statement is used to specify a block of code to be executed if the condition in the If Statement is false. In this example, if it's raining, isRaining is true. It advises you to bring an umbrella. Otherwise, it tells you that there's no need for one. Nested If Else Statements are a common programming construct in JavaScript and many other programming languages. They allow you to test multiple conditions and execute different blocks of code based on the results of those conditions. Here, the code provides different messages based on the combination of temperature and rainfall, considering whether it's hot, cold, rainy, or sunny. The Switch Statement allows you to compare a value against multiple possible case values and execute code based on the first matching case. In this example, the code evaluates the value of day and prints a message based on the day of the week. The Ternary Operator is a concise way to write conditional statements, such as If Else Condition. The Ternary Operator checks if the age is greater than or equal to 18. If it is, it sets Can Vote to Yes. Otherwise, it sets it to No. Control flow and conditional statements are crucial for building responsive JavaScript applications. They enable your code to make decisions, execute different actions, and provide a personalized experience to users based on specific conditions, making your programs more dynamic and interactive. In this video, you learned that Control flow in JavaScript manages execution order using conditional statements. The If statement executes code when a specified condition is true. Otherwise, the code block is skipped. Else If sequentially tests multiple conditions for situations with more than two possible outcomes, enabling various actions based on each condition. Else specifies code to run when the If statement's condition is false, providing an alternative action. Nested If Else statements assess multiple conditions, executing distinct code blocks based on each condition's results. And, the Switch statement compares a value against multiple cases and runs code based on the first matching case, offering structured handling of multiple options.

Welcome to Looping
and Iteration. After watching this video, you will be able to
define looping in JavaScript and
differentiate between for, while, and do while loops. Looping and iterations
in JavaScript are techniques that allow you to execute a block of
code repeatedly. They are used to perform
repetitive tasks, traverse data structures
like arrays and objects, and handle various
scenarios in your code. Loops in JavaScript are
essential for automating repetitive tasks and processing large sets of data efficiently. They allow you to
iterate through arrays, perform actions on each element, and control the flow of
your code dynamically. Loops are fundamental
for building dynamic and interactive
web applications. JavaScript provides
several looping constructs and methods for this purpose, such as, for loop, while loop, do while loop. Let's explore each
in more detail. A for loop is a
control structure in JavaScript that allows you to execute a block of code repeatedly for a specified
number of times, or until a particular
condition is met. It consists of three parts, initialization,
condition, and update. Initialization,
this part is where you initialize a loop
control variable, typically with an initial value. Condition, this is a Boolean expression that is evaluated before each iteration. If the condition is true, the loop continues,
otherwise it terminates. Update, this part is responsible for changing the loop control
variable in each iteration, often incrementing or
decrementing its value. Here's an example
of a simple for loop that prints
numbers from 1-5. In this example, initialization, let i=1 initializes the loop
control variable i to1. Condition i less than equal 5 checks whether i is
less than or equal to 5. Update, i++ increments i
by 1 after each iteration. The loop starts with i=1
and for each iteration, it prints the value of i
and increments i by 1. When i becomes greater than 5, the condition becomes false
and the loop terminates. The answer to the
example for loop is a sequence of numbers from 1-5, each printed on a new line. A while loop is a control
structure in JavaScript that allows you to execute
a block of code repeatedly. As long as the specified
condition is true, it continually evaluates the condition before
each iteration. Here's the basic syntax
of a while loop. The condition is evaluated
before each iteration. If the condition is true, the code block is executed. If the condition is false,
the loop terminates. Here's an example of a while
loop that calculates and prints the Fibonacci sequence
until a specified limit. In this example, we start
with the limit set to 50, which represents the upper limit for the Fibonacci sequence. The loop continues as long as a is less than or
equal to the limit. Inside the loop, we
calculate the next number in the Fibonacci sequence by adding the previous two numbers, a and b, and store it in temp. Then we update a with the value of b and b
with the value of temp. The output of this loop will
be the Fibonacci sequence up to and including numbers
less than or equal to 50. The loop continues until
the next Fibonacci number exceeds the specified
limit, 50 in this case. This example demonstrates
how a while loop can be used to generate a sequence of numbers based on a condition. A do while loop in JavaScript is a control
structure that allows you to execute a block of code repeatedly as long as a
specified condition is true. Unlike the for or while loops, a do while loop guarantees that the code block will execute at least once, even if the condition
is initially false. The structure of a do
while loop is as follows. The code block is
executed first, then the condition is checked. If the condition is true, the loop continues and the
code block is executed again. If the condition is false,
the loop terminates. Here's an example of
a do while loop that simulates rolling a dice
until a six is rolled. In this example, the loop starts by declaring
a variable roll. The code block within
the loop generates increment numbers
from one and six, simulating a dice roll
and prints the result. We start with roll=1. The loop will execute
the code block, print the current value of roll, and then increment roll by one. If roll reaches seven, it is going to come out
of the loop because a standard dice only
has six phases. The loop continues until
roll is equal to six. Here's an example of
the possible output. In this example, the
loop rolled seven, which caused the loop to exit. Now, let's look at the difference between the
three JavaScript loops. For loops are used when you know the exact number of
iterations while, while and do while
loops are used when the number of iterations
is condition dependent. For loops have an explicit initialization step
within the loop header, while while and do
while loops require you to initialize the loop control variable
before the loop. Do while loops guarantee that their body is executed
at least once, while for and while
loops may not execute the body at all if the initial
condition is false. The choice of loop depends on the specific use case and
control flow in your code. Use for loops for
precise control, while loops for condition
dependent repetition, and do while loops when you need to ensure at least
one execution. In this video, you
learn that looping simplifies repetitive tasks and data handling in JavaScript, a vital aspect of dynamic
web applications. For loop executes tasks, a specific number of times
or until a condition is met. While loop repeats tasks
while a condition is true, evaluating it before
each iteration. Do while loop ensures at least one task execution
while a condition is true, and you should select the appropriate loop based on your specific needs
and control flow.Welcome to introduction to functions and types
of functions. After watching this video, you will be able to define the concepts of
functions in JavaScript, differentiate between non parameterized and
parameterized functions, and identify the
two main ways of defining functions and the
various types of functions. In JavaScript, a function
is a reusable block of code that can be defined and executed as many
times as needed. Functions are a fundamental part of the language and are used to encapsulate and organize code into manageable, reusable units. They are essential for building complex applications as they help improve code structure, readability, and
maintainability. Let's delve into more details
by introducing functions in JavaScript The first step
is declaring a function. You can declare a function using the function keyword
followed by a name, enclosed parentheses, and the functions code
enclosed in curly braces. Here's a basic example. After declaring a function, you can call it by using its name, followed
by parentheses. When you call a function, it executes the code
within its block. In JavaScript, functions can be categorized into two main types based on their parameters, inputs, non-parameterized
functions and parameterized functions. Let's explore each in detail. Non-parameterized
functions do not require any parameters
to operate. They can perform
their tasks without receiving any specific
input values. Non-parameterized functions
are often used for tasks that rely solely on their internal
logic or external factors. Parameterized functions except
one or more parameters, also called arguments that provide input data for the
function to work with. You define these parameters in the function's declaration, and when you call the function, you pass specific values
for those parameters. Both parameterized and
non-parameterized functions have their uses in JavaScript, depending on the specific
requirements of your code. Parameterized functions
are versatile because they can adapt to
different input values, making them more flexible. While non parameterized
functions are simpler and more suitable for tasks that don't need external data. Now let's learn about
parameters and arguments. Parameters are
variables you define in the function declaration
to accept input values. Arguments are the
actual values you pass to a function
when calling it. In the previous example, A and B are parameters, and when we call add 3, 4 by passing values, these values are the arguments that get passed to the function. There are two ways of writing
a function in JavaScript, function declaration,
function expression. Let's explore each
in more detail. Function declaration is the traditional way
to define a function. It is similar to how we define a function in other
programming languages. We start by declaring it
using the keyword function, then we write the function
name and the parameters. Function expression
is another way to define a function
in JavaScript. Here we define a function using a variable and store the
returned value in that variable. Finally, let's explore
the various types of functions in JavaScript. They are, named function, immediately invoked
function expression, IIFE, arrow function
and anonymous function. Let's learn about
each in detail. Named functions
have specific names that can be called
by their names. They are typically
declared using the function keyword and can be defined at any
point in your code. In the given example, the
name of the function is add. Named function expressions
are beneficial for debugging because they display the function's name
in the call stack, aiding and identifying and
tracking bugs in your code. Immediately invoked function
expression, or IIFE, is a function in
JavaScript that's defined and executed
immediately after its creation. It's often employed
to encapsulate variables and code
within a private scope, helping to prevent global
scope contamination and variable conflicts. The arrow function is
a more concise way to write functions
introduced in ES6. They are often used for
short, simple functions. Anonymous functions
are without a name. These are often
used as arguments for other functions or
assigned to variables. For example, you can create anonymous functions using
the arrow function syntax. In this video, you
learned that functions are code blocks that enhance code organization
and readability. JavaScript functions
enhance code structure and maintainability for
complex applications. Functions are defined with
a function keyword, a name, parameters, and code
in curly braces, and can be invoked using
the function name. There are two categories
of functions, non-parameterized
functions that operate without specific input, and parameterized
functions that accept input parameters defined in
the functions declaration. There are two ways
to write functions. Function declaration is
the traditional way, and function expression
uses variables. The types of functions
include named function, immediately invoked
function expression, IIFE, arrow function,
and anonymous function.Welcome to ECMAScript function syntax and return statement. After watching this video, you will be able to describe
ECMAScript and its specifications. Define the arrow function
and identify its categories, and explore the return
statement along with examples. ECMAScript, often
abbreviated as ES, is a standardized scripting
language specification that serves as the foundation for several scripting languages. JavaScript is the most well known and widely
used implementation. It defines the core features and functionality that a
scripting language should provide to ensure
consistent behavior across different platforms
and environments. The ECMAScript specification
is maintained by ECMA International, a
standards organization. The ECMAScript specification
provides rules, guidelines, and requirements for
scripting languages, including syntax, data types, control structures, and
object manipulation. It ensures that scripts written in different
implementations, such as JavaScript in
web browsers no.js and others can be interoperable and produce
consistent results. Let's now explore
the arrow functions. Arrow functions introduced
in ECMAScript 6, referred to as ES6, offer a concise way to write
functions in JavaScript. They provide a more compact
and readable syntax for creating functions compared to traditional function
expressions. Arrow functions are especially useful for simple
one liner functions. Here's an overview
of arrow functions. Arrow functions have a more
compact and readable syntax. They use a fat arrow to
define the function, which is why they're commonly referred to as arrow functions. Arrow functions do not
require the function keyword. This makes the code cleaner
and easier to write. Arrow functions can also be
categorized in two ways, parameterized and non
parameterized functions. Let's learn about
each in more detail. A parameterized
arrow function takes one or more parameters and performs an operation
based on those parameters. In this example, the
arrow function "add" takes two parameters, A and B, and returns their sum. A non parameterized arrow
function doesn't take any parameters and
typically performs a task without relying on
external input values. In this example, the
arrow function greet doesn't take any parameters, but simply logs a greeting
message to the console. However, it's
important to note that arrow functions are not
a complete replacement for traditional functions. Traditional functions
are still necessary in cases where you require
named function expressions. The choice between
arrow functions and traditional functions depends on the context and
requirements of your code. Let's now explore the
return statement. In JavaScript functions, the return statement
is used to value that a function should produce as its result when it's called. It's essential for controlling
the output of functions and is crucial for making functions reusable
and versatile. Here's an overview of what
return statements do, why they're important,
and how they work. The purpose of using return
statements is as follows. The return statement is used to produce an output
value from a function. This output can be a
specific data value, a calculated result, or
even another function. It serves as an exit
point for a function. Once a return statement
is encountered, the function terminates and the control flow is handed back to the code that
called the function. Return enables functions
that can be used in various contexts because
they provide results that can be captured and used by other parts
of your code. Let's now look at the importance
of return statements. Without return, functions would not be able to produce
meaningful values. They would only perform actions, but not yield results. Return allows functions
to process data, perform calculations, and provide results that are
needed for various tasks. It's a fundamental concept in creating modular, reusable code. Functions encapsulate specific actions
and return results, making your code more
organized and maintainable. Now let's explore how a
return statement works. A return statement
typically appears inside the function body and specifies the value that
the function should return. When the function is called, it executes its code and
evaluates the return statement. The function then
immediately exits and the specified value is returned to the code that
called the function. You can capture
the returned value by assigning the
function call to a variable or using it
directly in other expressions. Here's a simple example
of a function that uses a return statement to calculate
the sum of two numbers. In this example, the
return statement within the add
function allows us to capture the sum of A and B when we call the function and use it in other parts of our code. Let's look at another example using a different output method. Here you have an HTML file that contains the
following code. You also have a
separate file named returndemo.js with the
following JavaScript code. In this example, you
have an HTML file with an empty paragraph element P tagged with the
ID functiondata1. This paragraph will display
the result of a function. To incorporate JavaScript code from an external file named returndemo.js you
use the script tags SRC attribute in your HTML. Within returndemo.js
there's a function called add takes two parameters, A and B, and returns their sum. After defining the add function, JavaScript locates
the HTML element with the ID functiondata1 using document dot get
element by ID functiondata1. The inner HTML property of
this HTML element is set to the result of calling the add function with
the Arguments 3 and 4. As a result, the sum (which is 7)
is displayed within the functiondata1 paragraph
in your HTML document. In this video, you learn
that ECMAScript is a standardized scripting language specification
that serves as the foundation for
scripting languages like JavaScript, it defines core language
features and guidelines for consistent behavior across
different environments. ES enables interoperability and consistent results in
various implementations. Arrow functions
introduced in ES6, provide a concise way to
write JavaScript functions, especially for simple tasks. Return statements determine
the value of function produces and serve
as exit points for functions and
return statements are used for data output, data processing, and
code modularity.Welcome to Function Closure
and Function Hoisting. After watching this video, you will be able to define function closure and
identify practical examples, explain the concept
of function hoisting, and differentiate between function closure and
function hoisting. In Javascript, a function
closure is a function that retains access to variables from its enclosing
function scope. Even after the
enclosing function has finished executing, closures allow you to
create private variables, implement data hiding, and maintain state
between function calls. Here's an example of
a function closure. In this example, inner function is a closure because it can access the outer var variable from its containing function, outer function, even after outer function has
finished executing. Now, let's explore why using function
closure is important. Closures allow you
to encapsulate data within a function scope. Creating a private
environment for variables. This is crucial for building modular and maintainable code. As it helps prevent
unintended interference or modification of variables
from outside the function. By using closures, you
can hide certain data and expose only the
necessary parts of your code's functionality. This is fundamental for creating clean and secure application
programming interface, or API's libraries and modules. Closures enable
functions to remember and maintain state
between function calls. This is valuable for tasks
like implementing counters, timers, or managing
application state in event driven programming. In this example,
the greet function takes a name parameter, and returns an inner
function, sayHello. The greeting variable is enclosed within the
scope of sayHello. Thanks to the closure, you can create
multiple greetings by calling greet with
different names, and each greeting retains
its specific name. When you invoke greet
John and greet Alice, they still remember their
respective name values, resulting in
different greetings. Let's now learn about
function hoisting. Function hoisting,
is a behavior in Javascript where
function declarations are moved to the top of
their containing scope during the compilation phase, allowing you to use a function before it's actually
declared in the code. This behavior only applies to function declarations,
not function expressions. Here's an example of
function hoisting. In this example, the
sayHello function is called before it's declared. But it works because function
declarations are hoisted to the top of their
containing scope during the compilation phase. It's important to note
that function expressions, where a function is
assigned to a variable, do not exhibit
hoisting behavior. For example, in the
above code, greet is a function expression
and is not hoisted. So calling it before the assignment will
result in an error. Let's now learn the importance
of function hoisting. Function hoisting
can make code more readable and self explanatory, by allowing you to use functions before they
are defined in the code. This can improve the
logical flow of your code, and make it easier
to understand. Hoisted functions can be defined at any point within
their containing scope, regardless of the order
in which they are called. This flexibility can be
helpful when structuring your code and organizing
related functions. Function hoisting is crucial
for recursive functions, as it allows the function to call itself within
its own definition. You can conditionally
execute functions based on certain criteria without having to define them in
a specific order. The main difference between function closure and
function hoisting, is that function closures
allow functions to maintain access to variables from
their containing scope. While function hoisting
is a behavior where function declarations
are moved to the top of their containing scope
during compilation, enabling functions
to be called before their actual declaration
in the code. However, it's important to use function hoisting
judiciously, and understand its behavior, as it may lead to
unexpected results, if not used carefully. In contrast, function closures
are a fundamental concept for creating isolated modular
and maintainable code, and are widely used in many
programming scenarios, including creating
private variables, event handling, and
maintaining state. Function closures, are essential
for data encapsulation, information hiding,
and state management. While function hoisting, is valuable for code
organization, order independence, and recursive functions, both concepts contribute to the power and flexibility
of Javascript. In this video, you learned that function closures and
Javascript retain access to variables from
their containing scope, even after the
containing function has finished executing. Closures enable
private variables, data hiding and state maintenance
between function calls. Function hosting and
JavaScript moves function declarations
to the top of their containing scope
during compilation, allowing functions to be used
before they're declared. And function hosting
improves code readability, order independence, and enables recursion and conditional
execution of functions.Welcome to Events in Javascript. After watching this video, you will be able to describe
events in Javascript, recognize some common
Javascript event types, and explain how to attach event handlers to HTML
elements using Javascript. In Javascript, events
are crucial for creating interactive and
dynamic web applications, these are actions or
occurrences in the browser, such as user interactions, page loading, or mouse
movements over elements. Some of the common events
in Javascript are click, mouse over, keydown, and change. Let us explore these events and understand how to handle
them on web pages. The click event
is triggered when a user clicks an
element like a button. This example demonstrates how to handle the click event by changing the content
of a paragraph when a user clicks a button. This is an HTML document containing a button and
a paragraph element. The Javascript
code at the end of the document first
retrieves references to these elements using
document.getElementById and stores them in the
button and output variables. Next, attach an event handler to the button element using
the onclick property. The event handler, an
anonymous function, specifies what should happen when
clicking the button. In this case, it changes
the paragraph's content, identified by the output
variable, to "Button clicked!" The mouseover event is triggered when the mouse cursor
enters an element. In this example, you handle
the mouseover event to display a message when the
mouse moves over a div. The HTML document contains a
div and a paragraph element. The Javascript code starts by selecting these elements with getElementById, just like
in the previous example. You can then attach
an event handler to the div element using the
onmouseover property. The event handler, defined as an anonymous function, specifies that when the mouse
moves over the div, the content of the
paragraph identified by the output variable should
change to "Mouse over the div!" The keydown event
is triggered when you press down a key
on the keyboard. This example demonstrates
handling the keydown event by displaying the pressed key
when typing in an input field. This HTML document contains an input field and a
paragraph element. Javascript is used to select these elements with
document.getElementByID. An event handler for the
keydown event is attached to the input field using
the onkeydown property. This event handler
is defined to accept an event parameter which contains information about
the key that was pressed. It retrieves the
pressed key using the event key and display
it in the paragraph. As you type into
the input field, an event handler listens
for keydown events and dynamically updates the paragraph with
the key you pressed. The change event is
triggered when the value of an input
element changes. Typically, you can
use it to form elements like text
fields or drop-downs. This example handles
the change event to display a message when
the input value changes. You have an input field and a paragraph element in
this HTML document. Javascript selects
these elements with document.getElementByID. The event handler for the
change event is attached to the input field using
the onchange property. When the input value changes, the event handler triggers and updates the paragraphs content with value changed to followed by the new
value of the input. If you write "Hello",
the paragraph will display "Value
changed to: Hello." As you edit the input field by typing or
deleting characters, the event handler detects
the change event and modifies the paragraph to
show the updated value. For instance, if you change
the input from Hello to Hi, the paragraph will display
"Value changed to: Hi." These examples illustrate
different types of events and how you can use Javascript to capture and respond to those events
in your web pages. Event handling is
crucial for creating interactive and user-friendly
web Applications. In this video, you learn that
events in Javascript are fundamental for creating interactive and dynamic
web applications, events represent actions or
occurrences in the browser, including user
interactions, page loading, and mouse movements
over elements. Click event is
triggered when a user clicks on an element
like a button, mouse over event
is triggered when the mouse cursor enters
an element like a div, keydown event is triggered by pressing down on a
key on the keyboard, and change event is triggered when the value of an
input element changes.Welcome to Introduction to Arrays. After watching this video, you will be able to Describe the fundamental concepts of arrays in JavaScript and Examine common use cases and methods for working with arrays. In JavaScript, an array is a data structure used to store and organize a collection of values. These values can be of various data types, such as numbers, strings, objects, or even other arrays. Arrays are one of the most commonly used data structures in JavaScript and play a crucial role in grouping related data together. Arrays in JavaScript are ordered, which means that the elements are stored in a specific sequence, and each element is accessible by its index or position in the array. It's important to note that arrays in JavaScript are zero-indexed, meaning the first element is at index 0, the second element is at index 1, and so on. You can access and manipulate individual elements within an array using their indices. Creating an array in JavaScript is straightforward. You can use square brackets to declare an array and store elements within it, separated by commas. Here is an example of a JavaScript array named Fruits with three elements, apple, banana, and cherry. Let's see how basic functionalities can be used with this array. Arrays are zero-indexed, so you can access elements using their index. In this example, a new variable named firstFruit is declared and assigned the value of fruits 0, which is apple, and another variable named secondFruit is declared and assigned the value of fruits 1, which is banana. This is done by accessing the elements using their indices 0 and 1, respectively. To find out how many elements are in an array, you can use the length property. For instance, this code will provide 3 as the array length. Arrays in JavaScript are mutable. This means that you can change, add, or remove elements after creating the array. Here, the line fruits 2 equals strawberry modifies the third element, at index 2, of the fruits array. It changes cherry to strawberry. As a result, the fruits array now contains apple, banana, strawberry, with strawberry replacing cherry as the third element. JavaScript provides a variety of built-in methods to perform operations on arrays, including push, pop, shift, unshift, splice, slice, concat, map, filter, and many more. These methods offer powerful ways to manipulate and work with arrays. In this example, fruits.push, orange, adds the element orange to the end of the fruits array. After this operation, the array becomes apple, banana, cherry, orange. Fruits.pop removes the last element from the fruits array. Since cherry is the last element, it is removed, resulting in the array apple, banana. Arrays can also contain other arrays, allowing you to create multidimensional arrays or complex data structures. This is a valuable feature for handling structured data. For instance, this code defines a JavaScript array named matrix. It contains three subarrays, each representing a row in a matrix and stored in a nested array structure. This type of data structure is useful for handling and processing two-dimensional data in applications and algorithms. Arrays are frequently used for various tasks, such as storing lists of items, iterating through data, implementing stacks and queues, managing data in tables and grids, and much more. They are versatile and adaptable, making them a fundamental tool for developers. You can iterate through the elements of an array using loops, like for loops, or more modern methods like foreach, map, filter, and reduce. Array iteration is a powerful way to process and manipulate array elements. In this video, you learned that JavaScript arrays are data structures used to store and organize collections of values. Arrays can contain various data types, such as numbers, strings, objects, or even other arrays. Arrays in JavaScript are ordered, and elements are accessible by their index. The first element is at index 0, the second at index 1, and so on. Arrays are versatile and used for tasks such as storing lists, data iteration, implementing data structures, and more. And understanding how to work with arrays is a crucial skill for JavaScript developers.Welcome to Manipulating
and Iterating Arrays. After watching this video, you will be able to identify the standard array manipulation
methods in JavaScript, explain how to modify
arrays using those methods, and describe the array
iteration process. Arrays are fundamental data
structures in JavaScript, and they often require
manipulation and iteration to work with
data effectively. JavaScript provides a wide range of built-in array
methods that allow you to perform
various operations on arrays without
writing custom code. These methods can make
array manipulation more efficient and convenient. JavaScript offers several
built-in array methods to manipulate
arrays efficiently, such as push, pop, shift, unshift, splice, concact, slice, indexOf, reverse, sort, and length property. Let's explore them in detail. The push method adds
one or more elements to an array's ends and returns
the array's new link. This example starts
with an array of fruits containing
two elements; an apple and a banana. You can use push method to add orange and strawberry to
the end of the array, and the updated array
has all four elements. The pop method removes the last element from an array
and returns that element. In this example, there is an array of fruits
with three elements. You can use the pop method to remove the last element, orange. The removed fruit variable
stores the removed element. The shift method removes the first element from an array
and returns that element. In this example, you have an array of fruits
with three elements. Shift method removes the
first element, which is apple, and the removed fruit variable stores the removed element. The unshift method adds one or more elements to
an array's beginning, and returns the
array's new link. This example starts
with an array of fruits containing two elements. Unshift method is used to add apple and strawberry to the
beginning of the array, and logs the updated array. The splice changes the contents
of an array by removing, replacing or adding elements
at a specific position. In this example, there is an array of fruits
with three elements. Splice (1,1, "grape") replaces the element at index one
which is banana with grape. The concat method combines
two or more arrays to create a new array without
modifying the original ones. In this example, you
have two arrays, fruits and additional fruits. Concat method combines them into a new array called
combinedFruits. The slice method returns a
shallow copy of a portion of an array into a new array without modifying the
original content. In this example, Slice (1, 3) creates a new array, slicedFruits containing
elements from index 1-2, excluding index 3 of the
original fruits array. The indexOf method finds the index of a specified
element within an array. It returns the index of the first occurrence
of the element, or minus one, if it is not
able to find the element. In this example,
indexOf banana returns the indexOf the
first occurrence of banana in the fruits
array, which is one. The reverse method reverses
the order of elements, effectively reversing
the array in place. In this example, you can use the reverse method to reverse the order of elements
in the fruit array. The sort method is used to
sort the elements of an array. By default, it sorts elements as strings and in
lexicographic order, to sort numbers correctly, you can provide a
comparison function. In this example, sort method is used first without
a comparison function, resulting in a
lexicographic sort. Then, sort method is used with a custom comparison function to sort the numbers correctly. The length property returns the number of elements
in the array. You can use it to
determine the size, or to resize an array
by changing its length. In this example,
numFruits is assigned the value of fruits.length,
which is three. You can expand an array by
changing its length property. In this case, the code sets the fruit array's
length to five. JavaScript adds two undefined
values to the collection, which is five elements. Adding undefined values
is a way to increase the array size without
explicitly adding new features. You can truncate an
array by setting its length property
to a smaller value. Reducing the length effectively removes elements from
the end of the array. In this case, you set the
fruits array's length to two, which removes the last element, cherry, from the array. Let's now learn about
Array iteration. Iterating through an
array is a common task, and JavaScript provides multiple
methods to achieve this. One of the most basic
and versatile ways is using a for loop. Let's see how to iterate through an array using a for loop. You have an array called fruits that contains four
string elements. You use a for loop to iterate
through the array and initialize the
loop variable i to 0, and the loop continues as long as i is less than
the collection link. Inside the loop, fruits[i] accesses the element at
the current index i, and you can log it to the
console using console.log. The loop runs from i=0 to i=3, accessing each element in the array and logging
them to the console. In this video you
learn that JavaScript provides a variety of built in array methods to manipulate
arrays efficiently. Some standard methods are push, pop, shift, unshift, splice, concact, slice, indexOf, reverse, sort, and
length property. These methods and techniques empower you to perform
various operations on arrays from modifying
their contents to efficiently iterating
through their values. You can use a for loop to iterate through the
elements of an array.Welcome to Array Methods. After watching this video, you will be able to describe the various JavaScript
array methods and explain how to utilize array methods to transform and manipulate data
within arrays. Arrays in JavaScript, come with a rich set
of built-in functions, often called array methods, that simplify common
array operations. These methods provide
a convenient way to perform various
operations on arrays, from iterating through their
elements to filtering, transforming, aggregating, and searching for specific data. The common array
methods used to handle various tasks are forEach, map, filter, reduce, and find. Let's explore these methods and understand how they work,
and when to use them. The forEach method
iterates through an array, and applies a provided
function to each element. It's commonly used when
you want to perform a specific action
for each element, without creating a new array. Imagine you have an
array of user objects and want to send a welcome
email to each user. This JavaScript code sends welcome emails to
users by iterating through an array of
user objects and using a function.
Here's a breakdown. This is a function that logs
a welcome email message to console.log for a
given email address. Const users
created an array called users containing name and email. Users.forEach iterates
through the array. For each user, it calls the sendWelcomeEmail function
with the user's email. This defines an arrow
function that takes the current user
object as a parameter. This function logs
a welcome message with the provided
email to the console. As a result, you'll see
messages in the console indicating that welcome
emails have been sent to each user's
email address. The map method creates
a new array by applying a provided function to each element in the
original array. It's perfect for
transforming data without modifying
the original array. Suppose you have an
array of products, and want to extract their
prices into a new array. The map method constructs and logs messages for each product, displaying the product name and price in the specified format. This code dynamically generates and logs messages
for each product, displaying its name and price. Let's go through the
code step by step. Const products declare
an array with objects, each representing a product with name and price properties. The map method iterates
through the products array, and executes the provided arrow function for each element, saving the element in
the product variable. Console.log logs messages to the console within
the map function, displaying product
information. This template string replaces placeholders with actual values. The filter method
creates a new array containing elements that
pass a specified condition. It's useful for extracting
specific data from an array. You have an array of
products and want to filter out products as
per the price range. Let's go through the
code step by step. Const products declare a
constant variable named product. This takes three parameters. Return products.filter, filters the product array based on the specified criteria. Const minPrice and const
maxPrice set price threshold. Const filteredProducts,
store the filtered products. This calls the function with the specified parameters to
obtain the filtered products. Filtered products.forEach iterates through the
filtered products, saving the element in
the product variable. Console.log prints a
message to the console. The code then
filters and displays the product names and prices within the specified
price range. The reduce method allows
you to reduce an array to a single value by applying
a function to each element. It's excellent for
aggregating data. You have an array
of order prices, and want to calculate
the total order value. Let's break down the
code step by step. Const orderPrices, stores
the order price data. Const totalOrderValue, stores
the total order value. OrderPrices.reduce, uses the reduce
method to iterate through the array and
accumulate the values. This is an arrow
function that calculates the total by adding each price
to the accumulated total. After iteration, the
reduce method returns the final total order value stored in the total
order value variable. Console.log prints the total
order value to the console. As a result, the code calculates
the total order value by adding up all the prices
in the order prices array, and displays it in the console. In this case, the total
order value is 160. The find method returns
the first element in an array that satisfies
a specified condition. It's useful for searching
for specific data. You have an array
of employees and want to find an employee
with a specific ID. Let's go through the
code step by step. Const employees, store employee data with
various properties. Employees.find, searches for an employee based
on the specific condition. This checks if the
ID property of each employee object, e = 2. Console.log displays the result, \n creates line breaks
for better formatting. Dollar sign interpolates and
inserts employee objects. For example, ${employee.name} inserts the employee's name. As a result, the code will check whether an employee
has an Eid equal to 2, and display the details using console.log and
template literals. In this video, you learned that the forEach method
iterates through an array executing a provided
function for each element, often for side effects. The map method generates a new array by applying a
function to each element, which is useful for
data transformation. The filter method produces
a new array with elements, meeting a specified condition, effectively filtering
the original array. The reduce method
consolidates array values into a single result using
a provided function, commonly for calculating totals. The find method locates the first array element
meeting a condition, returning that element, or undefined if there
are no matches.[MUSIC] Welcome to Working with
Two-Dimensional Arrays. After watching this video, you will be
able to describe a two-dimensional array and explain how to create an interactive
2D array using HTML, CSS and JavaScript. A 2D array,
also known as a two-dimensional array, is collection of elements
organized in rows and columns. It's a versatile data structure
used in various programming and mathematical context. Each element in a 2D array is
accessed using two indices, one for the row and another for the column. In JavaScript, you can create a 2D array
by initializing an array of arrays, for example, this is a representation of
a three-by-three 2D array of integers. To access a specific
element in a 2D array, you need to provide both row and
column indices. For example, to access the element
in the second row and third column of this array with a zero-based index,
you would use grid 1 ,2, which is 6. You can use nested loops
to traverse a 2D array, this allows you to perform
operations on each element or row. For instance, this is a nested loop structure where
the outer loop i iterates through rows. And the inner loop j iterates
through columns of the 2D array, printing each element's
value along its position. 2D arrays are used in a wide
range of applications, including representing game boards and
grids, storing and processing images, managing data
in spread-sheets and databases, solving mathematical problems
such as matrix multiplication, and handling geographic data in maps and
GIS systems. Let's now look at the following HTML,
CSS, and JavaScript code that provides an interactive representation of
a movie theater seating arrangement. This portion of the code defines a basic
HTML structure with a div element, having the class seating chart to
display the seating arrangement. Within the seating chart div, individual seats are represented as
div elements with the class seat. These seats are given static
labels like A1, A2, B1, and so on. When a seat is selected, the bookSeat
row col function is triggered, passing the corresponding row and
column indices of the clicked seat. Next, this portion of the code
contains the CSS styles, used to visually style
the theater seating chart. Let's break down the key styles, the .seating-chart class styles
the container for the seating chart. It uses CSS grid to create a grid layout
with three columns of 70 pixels each, a gap of ten pixels, and
content centered. The .seat class styles individual seats.
It sets the width and height of each seat, centers the text, adds a one-pixel
solid border, and changes the cursor to a pointer
to indicate it's clickable. The .booked class styles booked seats.
It changes the background color to red, sets the cursor to not-allowed to
indicate it's not clickable, and changes the text color to white. Whereas the dot available
class styles available seats. It changes the background
color to light green. The .select-button class styles
the select random seat button. It sets the width to 100%,
adds padding and margin, changes the background color to blue,
sets the text color to white, removes the border, and
changes the cursor to a pointer. Lastly, this JavaScript section of
the code handles the functionality for booking seats in
the theater seating chart. Let's break down the key aspects, the theater seating arrangement is defined
as a 2D array called theaterSeats. It contains X for booked seats and O for available seats. This array is
used to manage seat availability. bookSeat(row, col) function is
called when a seat is clicked. It checks if the selected
seat is available, books it by changing its class to booked,
and displays an alert message. This function updates the class of
a seat div to reflect its status, available or booked. When the selectRandomSeat button is
clicked, the bookRandomSeat function finds all availableSeats, randomly selects one,
books it, and displays an alert. If all seats are already booked,
it alerts that all seats are taken. This code allows you to interact with the
seating arrangement by clicking on seats to book them or
using the Select Random Seat button to automatically book
a random available seat. It's a simple representation
of a movie theater seating chart with booking functionality. In this video, you learn that a 2D array, also known as a two-dimensional array,
organizes elements in rows and columns. It's a versatile data structure used in
programming and mathematical contexts. Accessing elements in a 2D array
involves using two indices, one for the row and
another for the column. And HTML, CSS, and JavaScript can
be used to create an interactive representation of a movie
theater seating arrangement. [MUSIC]Welcome to Classes and
Objects in JavaScript. After watching this video, you will be able to define a class and an object
in JavaScript. Explain how to create
classes and objects, and identify the
difference between object literals and
function constructors. Classes and objects are fundamental concepts in
JavaScript that allow you to create an organized code in a more structured
and reusable way. In JavaScript, you
can work with classes and objects to model
real-world functionalities. Let's delve into
the definitions and relationships between
classes and objects. A class is a blueprint or template for creating
objects in JavaScript. It defines the structure and behavior by encapsulating data, or properties, and methods, or functions that are common
to a group of objects. Classes provide a way to
model real-world entities, bringing a level of
abstraction to your code. For example, a person class could define properties
like name and age, and methods like say Hello. Objects are specific
instances of a class created based
on the class blueprint. They represent specific entities on unique values for the
properties defined in the class. Objects encapsulate
state or property values and behavior or methods
in a single unit. For instance, you can
create individual person objects such as person 1 with the name of John
and an age of 30, and person 2 with the name
of Alice and an age of 25. These objects have
the structure and behavior specified
by the person class. Now let's understand
how to create classes and objects
in Javascript. In Javascript, you
can define a class using the class keyword.
Here is an example. In this example, we've
defined a person class with a constructor to initialize the first name and
last name properties, and a get full name method
to retrieve the full name. Next, let's look at an example of creating
an object from a class. In this example, we've
created an instance of the car class named myCar and called the
startEngine method on it. Now let's explore
creating objects using object literals and
function constructors. Object literals are
a way to create ad hoc objects without defining a class.
Here's an example. In this example, we've created a person object with
properties and a method. Function constructors are
regular JavaScript functions used to create and
initialize objects. It's a convention to name
functional constructors with an initial capital letter. In this case, we have
created a car constructor to create instances of car objects with properties for
the make and model. The Car1 and Car2 objects
represent different cars. We print their details
using console.log. Let's distinguish between object literals and
function constructors. Both object literals and function constructors can be used to create objects
in JavaScript. Object literals are suitable
for creating ad hoc objects, like storing individual customer orders with unique details. While function constructors are useful when you want to create multiple instances of objects with shared properties
and methods. Such as creating instances of a Car object with shared
properties like make, model and methods
like Start engine. This makes them
more suitable for scenarios where you
need to model and manage multiple similar objects such as users,
products, or vehicles. Object literals are suitable
for scenarios where you need unique details for
specific instances. Object literals
provide quick creation of one off objects, while function
constructors provide a more structured and
organized way to create objects, making it
easier to work with object oriented programming
concepts in JavaScript. Object literals are also
adaptable for various scenarios. In this video, you learned that JavaScript allows
you to work with classes and objects to
real world entities. A class serves as a blueprint for creating objects with shared
properties and methods. You can create objects using classes or object literals for one-off instances and use function constructors
for structured, shared properties and methods. Function constructors
are ideal for creating multiple instances of objects with common
characteristics. They offer a more organized
approach to object creation, aligning with object-oriented
programming principles.Welcome to Accessing
Objects Properties. After watching this video, you will be able to describe the use of dot and
bracket notations, define an array of objects and explain array iteration methods, and explain how a nested
array and objects work. In JavaScript, you can
access objects and their properties using
dot or bracket notations. Let's explain how to
access object properties. Dot notation is the
most common way to access object properties. You use a dot followed
by the property name. This example starts by defining an object named person with
properties first name, last name, and age. The console.log
statements display specific properties of an
object using dot notation. Bracket notation is
an alternative way to access object properties, especially useful
when property names contain special
characters or spaces. In this example, the console.log statements display
specific properties enclosed in square brackets. Bracket notation is also handy when you need to access
properties dynamically, such as with variables. Both dot and bracket
notation serve the same purpose, accessing
object properties. You can choose the one that best suits your needs
and coding style. Let's now learn about
arrays of objects. An array of objects is a common and powerful
way to store and manage structured
data in JavaScript. They allow you to organize
and manipulate data in a structured manner by combining the features of both
arrays and objects. Let's explore how
to create, access, modify, and iterate
through these arrays. You can create an array
of objects by placing objects inside an array
using square brackets. In this example, the
student array contains objects representing a student with name and age properties. You can access elements
within an array of objects using
the array index, and then you can access object properties
using dot notation. You can modify objects
in the array by assigning new values
to their properties. You can loop through
an array of objects to perform operations
on each object. Common methods for iterating
through arrays include for loop and array
methods like foreach. Let's first explore
using a for loop. You can set up a for loop to
iterate through the array. Within the loop
console.log(students[i]. name) prints the name property of each object in the array. Now let's iterate using
the foreach loop. The foreach loop iterates
through an array of objects, students and outputs the name
property of each object. You can add new objects to the array using the push method. You can also remove objects
using the pop method. Array methods like
filters and maps are powerful tools for working
with arrays of objects. You can use them to filter and transform arrays of objects. You can search for objects
within an array of objects using array
methods like find. Now, let's examine a nested array of
objects in JavaScript. Here is a breakdown of JavaScript
code featuring objects. The first object represents
a person named John. It includes
properties like name, age, and hobbies. The address property
is an object with properties like
street, city, and zip. The second object represents
a person named Alice. It consists of
properties like name, age, an array of skills, and an array of projects. Each project in the
project's array is an object with properties
like title and completed. The third object is
a generic object labeled as a special object. It includes properties
like a title, an array called data, and an object called meta data. The fourth object is an empty object with
no defined properties. The fifth object includes a Boolean property
named another object, an array of nested arrays, and an additional
string property called additional property. Let's break down and
explain each line of code. This section focuses
on accessing the first object's properties
in the array of objects. ArrayOfObjects[0] retrieves the first object in the array.
ArrayOfObjects[0].name retrieves the value of the name property in
the first object, John. Array of objects[0].hobbies[0] retrieves the first element of the hobbies array
in the first object: Reading. This section accesses the properties of the second object in
the array of objects. ArrayOfObjects [1]
retrieves the second object in the array.
ArrayOfObjects [1]. skills[2], retrieves the third element of the skills array in the
second object Node.js. ArrayOfObject[1]. projects[0]. title retrieves
the title property of the first object in
the projects array in the second object
which is Project A. This section accesses
the properties of the third object in
the array of objects. ArrayOfObjects[2] retrieves the third object in the array. ArrayOfObject[2]. metadata.
key retrieves the value of the key property in
the metadata object in the third object which is value. This section accesses
the properties of the fourth object in
the array of objects. ArrayOfObjects[3] retrieves
the fourth object in the array which
is an empty object. This final section
accesses the properties of the fifth object in
the array of objects. ArrayOfObjects[4]. another
object retrieves the value of another object property in the fifth object which is true. ArrayOfObjects[4].additional
property retrieves the value of the additional
property property in the fifth object Extra. In this video, you learned that objects can be accessed using dot notation or
bracket notation. Dot notation involves using a dot followed by
the property name, while bracket notation encloses the property name
in square brackets. Arrays of objects
are a powerful way to organize structured
data in JavaScript. You can create, modify, and iterate through
arrays of objects. Common methods include push, pop, filter, and map, which allow you to add, remove, filter, and transform
objects within the array. You can also search for
specific objects using the find method and a
nested array of objects.[MUSIC] Welcome to introduction to string and
string manipulation. After watching this video, you will be
able to define the basics of JavaScript strings and explore various
string manipulation techniques. Strings are a fundamental data type
in JavaScript used to represent text. They can contain letters, numbers,
symbols, and white space characters. Strings are enclosed in single or
double quotes. You can also use backticks template
literals to create strings, allowing for string interpolation. Let's explore how to work with strings and
manipulate their contents for various JavaScript applications. You can concatenate strings
using the + operator. The concatenation operator, +,
in JavaScript is used to combine or join two or more strings together
to create a single longer string. It allows you to append
one string to another. In this example, the + operator
concatenates the first name and greeting strings to
create the full message. To determine the length of a string,
you can use the length property. In this example, the spaces are also counted when
calculating the string length. You can access individual characters
within a string using bracket notation and a zero-based index. In this example, you have a string
text with the value JavaScript. The second line is extracting the first
character of the string using bracket notation and storing it in
the variable first character. This expression accesses the character
at the zero index of the string text. In JavaScript, string indices
are zero-based, meaning that the first character is at index zero and the second
character is at index one, and so on. So, text zero retrieves the character at
the zero index of the string JavaScript, which is J, and assigns it to
the first character variable. JavaScript provides methods to
change the case of a string. For instances in this code, you start by defining a string called
text with the value, Hello, World!. This line uses the two lowercase
method on the text string. The two lowercase method is a built in
string method in JavaScript that converts all characters in a string to lowercase. The results is assigned to
the variable lowercase text and now holds the string in
all lowercase letters. This line uses the two uppercase
method on the text string. The two uppercase method is
another built in string method that converts all characters
in a string to uppercase. The result is assigned to
the variable uppercase text, so uppercase text now holds the string
in all uppercase letters. You can search for substrings within
a string using methods like index of, last index of, and includes. In this example, first, you define
a string sentence containing the text. The includes method checks if the string
fox is found within the sentence. It returns true because fox
exists in the sentence. The indexOf method returns the index or position of the first occurrence
of fox in this sentence. It returns 16 because fox starts
at index 16 in this sentence. To extract a portion of a string, you can
use the substring slice or substr methods. They allow extracting specific portions
based on character positions and provide flexibility. For instance, in this code, you have a
string text with the value Hello, World!. The substring method extracts a portion of
the text string starting from index 0 and ending before index 5. It retrieves the characters hello. The slice method extracts a portion of
the text string starting from index seven until the end. It retrieves the characters world. The substr method extracts
a substring starting from index 7 and spanning five characters. It retrieves the characters world. The replace method allows you to
replace substrings with new values, allowing you to modify
the string's content. In this example, you have a string
text with the value Hello, World!. The replace method is
used on the text string. It finds the first occurrence of world and
replaces it with universe. The result is stored in
the updated text variable. You can split a string into an array
of substrings using the split method. It is handy for parsing data
separated by a specific character or sequence of characters for
further processing or analysis. In this example, we have a string
csvData that contains data in csv or comma separated values format. It represents information about people, with each person's data separated by
semicolons and individual attributes. The split method is used
on the csvData string and takes the semicolon as the delimiter. It splits the string at each semicolon, creating an array where each element
represents the data for one person. After splitting, the resulting peopleArray
is an array of strings with each element containing the data for one person. The trim method removes leading and
trailing white space from a string. It is especially useful for
cleaning and formatting user input or working with data from external sources. For instance, in this code,
you have a string text with leading and trailing spaces. Its length is determined by text.length,
which includes the spaces and other characters, so
the initial length is 15. The trim method is applied to
text which removes leading and trailing white spaces such as spaces,
tabs, and so on. The trim string is stored in trimmedText. The length of trimmedText is checked, which
excludes the leading and trailing spaces. The length of trimmedText string
is 8 as the spaces are removed. Template literals provide a powerful and
readable way to format strings. Template literals
are enclosed by backticks and allow you to embed expressions within
the string using dollar sign syntax. The example calculates
the total cost of widgets and uses template literals to
construct an invoice string. In this video, you learned that key
string operations include concatenation, length determination, and
character access via index. Case changes with toLowerCase and
toUpperCase. Substring searching with includes and
indexOf. Extracting with substring slice and
substr. Substring replacement with replace and
string splitting into arrays with split. Whitespace trimming with trim. And complex string manipulation
using template literals. Proficiency in these operations is crucial
for effective text manipulation and data handling in JavaScript applications. [MUSIC]Welcome to Introduction
to Math and Date Objects. After watching this video, you will be able to explain
the significance of the math object and implement
mathematical operations. Utilize date objects to extract specific date components and
perform date arithmetic. Explain the use of timing
functions in Javascript. In Javascript, the math
object is a powerful built in global object that
equips developers with a wide range of mathematical
methods and constants. It serves as a toolbox
for performing essential mathematical
operations in your code. Here are some common
operations you can achieve using math objects, rounding numbers,
exponentation and logarithms, and random number generation. Let's explore each
with examples. Math object provides
functions for rounding numbers which are handy
for various applications. In this example,
const number equals 3.6 defines a variable
number with the value 3.6. The math.round method, rounds numbers to
the nearest integer, resulting in rounded
being set to four. The math.ceil method rounds numbers to the nearest integer, setting ceil to four. The math.floor method rounds numbers to the nearest integer, setting floor to three. Math object is
equipped to handle exponentation and
logarithmic calculations. For instance, in this code, constant base = 2 defines a variable base
with the value two. Const exponent = 3 defines a variable exponent
with the value three. The math.pow method calculates the power of base
to the exponent, resulting in power
being set to eight. The math.SQRT method to calculate the square
root of base, setting square root to
approximately 1.41421356237. Math.log base uses the math.log method to calculate the natural logarithm of base setting natural log
to approximately 0.69314718056. When you need
randomness in your code, you can utilize the math object to generate random numbers. This code snippet creates a
variable random that stores a random decimal number for use in your
Javascript program. Let's look at an example
that will help you understand how the math object and its methods can be used. This code creates a simple
interactive web page. An h1 heading displays random quote generator
as the page heading. A p element with
the id qouteDisplay is initially empty
for displaying the randomly selected quote. A button element labeled get quote has an on click attribute that triggers the
Javascript function generate random quote when
the button is clicked. The Javascript code
within a script tag defines an array called quotes
containing several quotes. A Javascript function called
generate random quote, that is called when the
Get button is clicked. The generate random
quote function generates a random
index using math dot random 0-1 and multiplies it by the length of
the quote array. The result is then
rounded down using math.floor to obtain a
random integer index. It retrieves the quote at the random index and assigns it to the
random quote variable, which then displays the
randomly selected quote by setting the text
content to randomQuote. Now let's learn about
the date object. The date object in Javascript is a crucial tool for working
with date and time values. It offers methods for creating, formatting, and manipulating
dates and times. Let's delve into the date object and some of its primary methods. Date objects are used to represent specific
moments in time. You can create them
in various ways. This example shows the
different ways to create date objects representing
the current date and time, a specific date and a date calculated from
milliseconds since the epoch date.
Date objects provide access to individual
components of a date, such as year, month, day, hour, and more. You can format date objects into human readable
strings using methods like toLocaleDateString
and toLocaleTimeString. Date objects allow for various date
arithmetic operations including adding and
subtracting time intervals. Let's now learn about
the timing functions. Timing functions
are essential for controlling the flow of
your Javascript code. They enable you
to create delays, schedule repetitive tasks,
and manage animations. There are two types
of timing functions, set timeout function and
set interval function. Let's explore both in detail. The set timeout function
schedules the execution of a function after a specified
delay in milliseconds. In this example, the
first argument is an anonymous function or a
function without a name inside set time out that will
be executed after a delay of 2000 milliseconds
or two seconds. During the two second delay, the rest of the program
continues to execute. After the delay, the function is invoked and it
logs the message. This message appears after
a delay to the console. Set interval is a built in Javascript function
that schedules the repeated execution of a specified function at a
specified time interval. For instance, this
code demonstrates a simple interval
based countdown that stops after six iterations. Count is initialized to zero, and set interval is used to
create a repeating interval. The anonymous function
inside set interval logs the current count to the console and increments it by one. It also checks if the
count has reached six. If true, it stops using the interval using clear
interval inter valid. The interval is set to 1,000
milliseconds or one second. The console logs count x every second until
count exceeds five. The intervalid variable holds the ID returned by set interval, allowing you to later clear the interval using clear
interval when needed. This video you learned
that the math object in Javascript provides methods and constants for
mathematical operations. It includes rounding,
exponentation, square roots, logarithms, and
random number generation. The date object manages date and time values
in Javascript, you can create date objects
for specific moments, extract date components,
format dates, and perform date arithmetic. Javascript has two
key timing functions, set time out and set interval.Welcome to Introduction to
debugging in JavaScript. After watching this video, you will be
able to recognize the significance of debugging in JavaScript, differentiate
the various debugging techniques and tools, and explore the structure and
purpose of try-catch block. Debugging in JavaScript is the process of
of identifying and fixing errors, bugs and issues in your JavaScript code. These errors can include syntax errors,
logical errors, runtime errors, and other issues that prevent your JavaScript
program from functioning as intended. Let's look at some common techniques and
tools for debugging in JavaScript. One, the simplest form of debugging
involves adding console.log statements to your code. These statements allow you to
print values, variables or messages to the browser's console. By examining these outputs, you can get
insights into the flow of your program and the values of variables at
different points in your code. Two, most modern web browsers come with
built-in developer tools that allow you to set breakpoints in your JavaScript code. When a breakpoint is reached,
the code execution stops and you can inspect variables, the call stack,
and other relevant information. You can insert the debugger statement
directly into your code to halt execution and trigger the browser's debugger. This is similar to setting breakpoints,
but is initiated programmatically. Four, every major web browser,
such as Google Chrome, Mozilla Firefox, Microsoft Edge, and Safari, includes developer tools that
provide debugging capabilities. You can access these
tools by pressing F12 or right-clicking on a web page and
selecting inspect or inspect element. In the developer tools, navigate to
the console tab for logging, sources or debugger tab for setting breakpoints,
and Network tab for debugging network requests. Five, a try-catch block in JavaScript
is a structured mechanism used for error handling. It allows you to manage and recover from runtime errors that might
occur during the execution of your code. Now let's explore how
the try-catch block works. The code that might generate an error
is enclosed within a try block. This is the segment of code that
you want to monitor for errors. Catch block, if an error occurs within the
try-block, the catch block is executed. The catch block specifies
how to handle the error. It takes an error object as a parameter
which contains information about the error. The catch block can log the error,
provide fallback behavior, or perform any other action
to handle the error. Try-catch blocks are invaluable for
debugging in JavaScript for the following reasons. Try-catch blocks allow you to isolate
potential issues by wrapping specific code segments in try blocks you can focus on
debugging those sections individually, making it easier to identify
the root cause of errors. When an unhandled error
occurs in JavaScript, it can lead to application crashes or
abrupt behavior. Try-catch blocks prevent
this by handling errors, allowing your application
to continue running. Catch blocks provide a place
to log error information. You can log error information to
the console or send them to a server for detailed analysis. These logs are invaluable for
debugging during development and diagnosing issues in
production environments. The error object passed to the catch block
contains valuable information such as the error type, message and stack trace. This information helps you understand what
went wrong and where the error occurred. Catch block allows you to define fallback
behavior or alternative code paths. This ensures that your application
continues to function even when errors occur. You can use the throw statement within
a try block to throw custom expectations based on specific conditions. This enables you to provide more
meaningful error information, aiding in debugging. In web applications, try-catch blocks
help create a user-friendly experience by preventing crashes and providing
information error messages. Users see meaningful error messages
instead of cryptic error popups. Try-catch blocks are not just for
development, they are essential for diagnosing and addressing issues that
occur in production environments. Logging and reporting errors in
production helps developers track and resolve user reported issues. Let's now look at an example
of what happens when you try accessing a property of an undefined
object without using a try-catch block. In this code, we try to access a property,
property of an undefined object object. This code will result in
an unhandled error, and the script will terminate
before reaching the message. This message will never be reached. Now let's handle the same
scenario using a try-catch block. We use a try-catch block to
attempt the property access. If an error occurs,
it is caught by the catch block and we log an error message.
Despite the error, the script continues to execute
after error handling and the message program continues
after error handling is logged. Let's look at another example where we
attempt to access an undefined array element without using a try-catch block. In this code,
we attempt to access an array element at an out of bounds index
index 5 in an array R. This code will throw an error because you
cannot access properties of undefined. And this message will never be
reached will not be logged. Now let's handle the same
scenario using a try-catch block. We use a try-catch block to attempt
to access the array element. If an error occurs, it is caught by the
catch block and we log an error message. Despite the error, the script continues
to execute after error handling, and the message program continues after error
handling is logged. In this video, you'll learn that try-catch blocks are essential
tools for debugging in JavaScript. They provide a structured and
organized approach to handling errors, logging error information,
maintaining application stability, and enhancing the overall user experience. And by mastering these blocks,
developers can efficiently identify, diagnose, and resolve issues in
their JavaScript applications. [MUSIC]Welcome to Introduction to
the Document Object Model. After watching this video,
you will be able to define the document object model, DOM. Explain the purpose of $0 and
identify the key node types and describe the importance
of DOM in JavaScript. The document object model, or DOM, is
a programming interface for web documents. It represents the web page so
that programs like JavaScript can change the document structure,
content, and style. It provides a structured
representation of the web page, making it easier for developers to
interact with and manipulate web content. Let's understand the DOM document,
object, and model terms. The term document refers to a web page or any XML document such as HTML,
XHTML, or XML. The DOM represents this document as
a structured tree-like hierarchy with each part represented as a node. An object represents a JavaScript object
that corresponds to an element, attribute, or content within the web document. Each DOM element is an element
of the web page, accessible and manipulable using JavaScript. The model denotes the structured and
abstract representation of a web document. Now let's explore how the DOM works. When a web page is loaded in a browser, the browser creates a DOM
representation of the page's structure. It forms a hierarchical tree structure
with the document's root as the top node. Document node is the top level node
representing the entire web page. Element nodes represent HTML
elements such as div, p, a, and form the bulk of the DOM structure. Attribute nodes represent attributes
of HTML elements including id, class, and src. Text nodes contain the text
content within elements. Before we dive into the different
types of nodes and how they are used, let's first understand
the special variable $0. $0 is a special variable that you can use
in the browser's development console as a quick reference to the currently
selected DOM element in the elements panel in web development. It is often used for debugging and
inspecting elements in a web page. Here's how it works. To open the browser's developer tools, Right-click on an element in
the web page and select Inspect. Alternatively, you can open
developer tools by pressing F12, Ctrl+Shift+I or Cmd+Option+I on Mac OS. Once developer tools is open,
navigate to the elements panel. Here, you can interact with and
inspect the DOM elements of the web page. Next, you can use the console tab within
developer tools to type commands in JavaScript. To reference the currently selected
element in the elements panel, type $0 in the console. For example, if you have selected
a div element in the elements panel and you type $0 in the console,
it will refer to that div element. Once you have the element
referenced with $0, you can interact with it using JavaScript. This includes accessing its properties or
modifying its attributes. Now let's explore the different types
of nodes that are used in DOM and their various purposes. The entire HTML document is
represented as the document node. To access the entire document
using the document object, Right-click on the paragraph you
want to inspect in your browser and select Inspect from the context menu. Navigate to the console tab in
the developer tools and declare a variable called document node using var
documentNode = document in the console. Now the entire document is accessible
through the documentNode variable. Type documentNode in the console and
press Enter. You will be able to see
the entire document object. An element node represents an HTML
element within the document. One, to access the paragraph tag, select the paragraph you want
to inspect and select inspect. Two, navigate to the console tab and
enter $0. It will output the HTML code and
details of that specific element. A text node represents the text
content within an element. To retrieve the text of
the selected element, in this case, a paragraph,
use the $0.textContent command. This will give the text content,
This is a paragraph. Attribute nodes represent
element attributes and provide additional
information about an element. One, to access the attributes, select the anchor tag you want
to inspect and select inspect. Two, navigate to the console tab and
enter $0.getAttribute("href"); command. This will give you the following output. You can also change the values
of the attributes or modify them using this command. Now, if you access the attribute again,
it will give you the updated output. A comment node represents an HTML
comment within the document. To access the comment node,
you must first retrieve a reference to the HTML element with the id
attribute set to myDiv. To access the HTML comment code,
you can now type the following codes in the console tab and receive the following
details of that specific element. This code assigns the comment
code to comment node and when you type commentNode in the console
tab, you will receive this output. This code assigns the comment
text to commentContent and when you type commentContent in the
console tab, you will receive this output. A document type node represents
the document type declaration, DOCTYPE in an HTML document. To access the document type, you can use the document DOCTYPE
command in the console tab. This will provide the node type of
the currently selected element and for the DOCTYPE HTML declaration,
the node type is typically ten. The DOM is an integral part of JavaScript
and web development for several reasons. The DOM provides a structured,
hierarchical representation of web documents, enabling developers to
interact consistently with web content. The DOM allows developers to swiftly
respond to user actions in real time with JavaScript. Developers leverage the DOM to access and
modify page content and structure. The DOM bridges browser differences,
ensuring consistent functionality across various platforms and
simplifying cross-browser compatibility. The DOM facilitates real-time content
updates without requiring a full page refresh. The DOM allows developers to attach
event listeners to the elements, enabling them to respond
to user interactions. The DOM supports assistive
technologies like screen readers and ensures inclusivity for
users with disabilities. Dynamic and interactive features
facilitated by the DOM, contribute to an improved user experience. In this video, you learn that the DOM
is a programming interface that allows JavaScript to modify web
document structure, content, and style. Document refers to web pages, objects corresponding to JavaScript
objects representing elements, and model signifies the structured
representation for programming languages. $0 is a special console variable for referencing the currently selected DOM
element for debugging and inspection. DOM has various types of nodes
like document, element, text, attribute, comment, and
document-type nodes. And DOM is vital for structured access to
web content, creating dynamic web apps, content manipulation, and enhanced user
experience, among other functionalities. [MUSIC]Welcome to Introduction to
the Document Object Model. After watching this video,
you will be able to define the document object model, DOM. Explain the purpose of $0 and
identify the key node types and describe the importance
of DOM in JavaScript. The document object model, or DOM, is
a programming interface for web documents. It represents the web page so
that programs like JavaScript can change the document structure,
content, and style. It provides a structured
representation of the web page, making it easier for developers to
interact with and manipulate web content. Let's understand the DOM document,
object, and model terms. The term document refers to a web page or any XML document such as HTML,
XHTML, or XML. The DOM represents this document as
a structured tree-like hierarchy with each part represented as a node. An object represents a JavaScript object
that corresponds to an element, attribute, or content within the web document. Each DOM element is an element
of the web page, accessible and manipulable using JavaScript. The model denotes the structured and
abstract representation of a web document. Now let's explore how the DOM works. When a web page is loaded in a browser, the browser creates a DOM
representation of the page's structure. It forms a hierarchical tree structure
with the document's root as the top node. Document node is the top level node
representing the entire web page. Element nodes represent HTML
elements such as div, p, a, and form the bulk of the DOM structure. Attribute nodes represent attributes
of HTML elements including id, class, and src. Text nodes contain the text
content within elements. Before we dive into the different
types of nodes and how they are used, let's first understand
the special variable $0. $0 is a special variable that you can use
in the browser's development console as a quick reference to the currently
selected DOM element in the elements panel in web development. It is often used for debugging and
inspecting elements in a web page. Here's how it works. To open the browser's developer tools, Right-click on an element in
the web page and select Inspect. Alternatively, you can open
developer tools by pressing F12, Ctrl+Shift+I or Cmd+Option+I on Mac OS. Once developer tools is open,
navigate to the elements panel. Here, you can interact with and
inspect the DOM elements of the web page. Next, you can use the console tab within
developer tools to type commands in JavaScript. To reference the currently selected
element in the elements panel, type $0 in the console. For example, if you have selected
a div element in the elements panel and you type $0 in the console,
it will refer to that div element. Once you have the element
referenced with $0, you can interact with it using JavaScript. This includes accessing its properties or
modifying its attributes. Now let's explore the different types
of nodes that are used in DOM and their various purposes. The entire HTML document is
represented as the document node. To access the entire document
using the document object, Right-click on the paragraph you
want to inspect in your browser and select Inspect from the context menu. Navigate to the console tab in
the developer tools and declare a variable called document node using var
documentNode = document in the console. Now the entire document is accessible
through the documentNode variable. Type documentNode in the console and
press Enter. You will be able to see
the entire document object. An element node represents an HTML
element within the document. One, to access the paragraph tag, select the paragraph you want
to inspect and select inspect. Two, navigate to the console tab and
enter $0. It will output the HTML code and
details of that specific element. A text node represents the text
content within an element. To retrieve the text of
the selected element, in this case, a paragraph,
use the $0.textContent command. This will give the text content,
This is a paragraph. Attribute nodes represent
element attributes and provide additional
information about an element. One, to access the attributes, select the anchor tag you want
to inspect and select inspect. Two, navigate to the console tab and
enter $0.getAttribute("href"); command. This will give you the following output. You can also change the values
of the attributes or modify them using this command. Now, if you access the attribute again,
it will give you the updated output. A comment node represents an HTML
comment within the document. To access the comment node,
you must first retrieve a reference to the HTML element with the id
attribute set to myDiv. To access the HTML comment code,
you can now type the following codes in the console tab and receive the following
details of that specific element. This code assigns the comment
code to comment node and when you type commentNode in the console
tab, you will receive this output. This code assigns the comment
text to commentContent and when you type commentContent in the
console tab, you will receive this output. A document type node represents
the document type declaration, DOCTYPE in an HTML document. To access the document type, you can use the document DOCTYPE
command in the console tab. This will provide the node type of
the currently selected element and for the DOCTYPE HTML declaration,
the node type is typically ten. The DOM is an integral part of JavaScript
and web development for several reasons. The DOM provides a structured,
hierarchical representation of web documents, enabling developers to
interact consistently with web content. The DOM allows developers to swiftly
respond to user actions in real time with JavaScript. Developers leverage the DOM to access and
modify page content and structure. The DOM bridges browser differences,
ensuring consistent functionality across various platforms and
simplifying cross-browser compatibility. The DOM facilitates real-time content
updates without requiring a full page refresh. The DOM allows developers to attach
event listeners to the elements, enabling them to respond
to user interactions. The DOM supports assistive
technologies like screen readers and ensures inclusivity for
users with disabilities. Dynamic and interactive features
facilitated by the DOM, contribute to an improved user experience. In this video, you learn that the DOM
is a programming interface that allows JavaScript to modify web
document structure, content, and style. Document refers to web pages, objects corresponding to JavaScript
objects representing elements, and model signifies the structured
representation for programming languages. $0 is a special console variable for referencing the currently selected DOM
element for debugging and inspection. DOM has various types of nodes
like document, element, text, attribute, comment, and
document-type nodes. And DOM is vital for structured access to
web content, creating dynamic web apps, content manipulation, and enhanced user
experience, among other functionalities. [MUSIC][MUSIC]
Welcome to Manipulating DOM Elements. After watching this video,
you will be able to describe accessing and manipulating DOM elements
using various methods and explain methods and
manipulation actions using examples. Accessing the document object model or DOM means obtaining references to
specific HTML elements on a web page. Once you access a part, you can
perform actions like reading content, modifying attributes, or
adding event listeners. This basic step in web development
empowers you to manipulate a web page's content and behavior. Accessing elements in the DOM can
be done using methods like one, getElementById, two,
getElementsByClassName, three, GetElementsByTagName, and
four, querySelector. Let's talk about each in more detail. getElementById is a method in JavaScript
used to access a specific HTML element within the DOM based
on its unique ID attribute. In the HTML code,
there are two elements with ID attributes. The JavaScript code selects the HTML
element with the ID main heading. The code then assigns the selected
element, in this case the h1 part, to the variable heading element. The console.log(headingElement) statement
logs the selected element to the console. This helps verify that the JavaScript
successfully accesses the specific element. You can use the getElementsByClassName
method in JavaScript to access multiple HTML elements within the DOM
that share the same class name. In the HTML code, you have three
paragraph elements in your HTML code. Two of them have the class
attribute set to highlighted. One is a regular paragraph
without the highlighted class. The JavaScript code use the
getElementByClassName method to access all elements with the class name highlighted. The result is a collection of elements
stored in the variable highlighted elements. The code then iterates through each
element in the collection using a for loop. Inside the loop it sets the text content
property of each element to this paragraph is highlighted while
the regular paragraph remains unchanged. You can use the getElementsbyTagName
method in JavaScript to access multiple HTML elements within
the DOM based on their tag name. In the HTML code,
you have three elements in your HTML code, one h2 element, and
two paragraph elements. The JavaScript code uses
getElementsByTagName to access all paragraph elements. The result is a collection of elements
stored in the variable paragraphElements. The code then logs the entire
collection to the console and separately logs each paragraph element. querySelector is a versatile method
in JavaScript used to access HTML elements within the DOM
based on CSS-like selectors. In this HTML code,
you have three elements in your HTML code, two paragraph elements,
and one div element. One of the paragraph elements
has the class highlighted and the other has the ID, my-paragraph. The JavaScript code uses querySelector
to select specific elements, this selects the first element
with the class highlighted. This selects the element with
the ID my-paragraph. This selects the first div elements on the page. Now that you have learned
about accessing DOM elements, let's explore DOM manipulation. Manipulating elements using the DOM
refers to changing the structure, content, attributes, or
styles of HTML elements within a web page. Everyday actions involved in
manipulating elements using the DOM include modifying the text or
HTML contents of elements. Suppose the HTML code has
the following command, you have a paragraph element with
the attribute ID set to my-paragraph. The content of the paragraph
is "This is some text." This JavaScript code selects a paragraph
by ID and changes its text content. The expected output is an HTML paragraph
displaying "This is updated text." You can also alter
the attributes of each element, which can affect their behavior or
appearance. Suppose you have the following HTML code, you have an image element with
an attribute ID set to my-image and an src attribute pointing to
an image file named old-image.jpg. This JavaScript code selects
an image by its ID and changes the src attribute
to load a new image. The expected output is an updated
image displayed on the web page. You can dynamically add new
elements to the page or remove existing ones based on user
interactions or other conditions. Suppose you have the following HTML code.
This code consists of an unordered list with an attribute ID set to my-list,
inside the ul, there are two list items, one with the content item one and
another with the content item two. This JavaScript code selects an unordered
list, creates a new list item, adds text content, and appends it to
the list using the appendChild method. The expected output is an updated
list with three items. You can also set up event listeners on
elements to respond to user interactions. Suppose the HTML has the following code. This JavaScript code adds a click
event listener to a button. When you click the button,
a button clicked alert is displayed. You can change the order of
elements within a parent container, which affects their
display order on the page. Suppose the HTML code has
the following command. This code selects a container div and
reorders the two paragraphs, making the second paragraph
the first child of the div. The expected output is
the first paragraph, followed by the second paragraph. You can also create copies
of existing elements and insert them elsewhere in the document. Suppose the HTML code has the following
command. This code selects a list, clones the first list item, and attaches
the cloned item to the end of the list. The expected output is an updated
list with three identical list items. In this video, you learned that,
accessing the DOM involves obtaining references to
specific HTML elements on a web page. Methods for
accessing elements include getElementById, getElementsByClassName,
getElementsByTagName, and querySelector. Manipulating elements using the DOM
is the process of making changes to the structure, content, attributes, or
styles of HTML elements within a web page. And it involves changing content,
altering attributes, setting up event listeners, changing
order, and creating copies of elements. [MUSIC][MUSIC]
Welcome to Manipulating DOM Elements. After watching this video,
you will be able to describe accessing and manipulating DOM elements
using various methods and explain methods and
manipulation actions using examples. Accessing the document object model or DOM means obtaining references to
specific HTML elements on a web page. Once you access a part, you can
perform actions like reading content, modifying attributes, or
adding event listeners. This basic step in web development
empowers you to manipulate a web page's content and behavior. Accessing elements in the DOM can
be done using methods like one, getElementById, two,
getElementsByClassName, three, GetElementsByTagName, and
four, querySelector. Let's talk about each in more detail. getElementById is a method in JavaScript
used to access a specific HTML element within the DOM based
on its unique ID attribute. In the HTML code,
there are two elements with ID attributes. The JavaScript code selects the HTML
element with the ID main heading. The code then assigns the selected
element, in this case the h1 part, to the variable heading element. The console.log(headingElement) statement
logs the selected element to the console. This helps verify that the JavaScript
successfully accesses the specific element. You can use the getElementsByClassName
method in JavaScript to access multiple HTML elements within the DOM
that share the same class name. In the HTML code, you have three
paragraph elements in your HTML code. Two of them have the class
attribute set to highlighted. One is a regular paragraph
without the highlighted class. The JavaScript code use the
getElementByClassName method to access all elements with the class name highlighted. The result is a collection of elements
stored in the variable highlighted elements. The code then iterates through each
element in the collection using a for loop. Inside the loop it sets the text content
property of each element to this paragraph is highlighted while
the regular paragraph remains unchanged. You can use the getElementsbyTagName
method in JavaScript to access multiple HTML elements within
the DOM based on their tag name. In the HTML code,
you have three elements in your HTML code, one h2 element, and
two paragraph elements. The JavaScript code uses
getElementsByTagName to access all paragraph elements. The result is a collection of elements
stored in the variable paragraphElements. The code then logs the entire
collection to the console and separately logs each paragraph element. querySelector is a versatile method
in JavaScript used to access HTML elements within the DOM
based on CSS-like selectors. In this HTML code,
you have three elements in your HTML code, two paragraph elements,
and one div element. One of the paragraph elements
has the class highlighted and the other has the ID, my-paragraph. The JavaScript code uses querySelector
to select specific elements, this selects the first element
with the class highlighted. This selects the element with
the ID my-paragraph. This selects the first div elements on the page. Now that you have learned
about accessing DOM elements, let's explore DOM manipulation. Manipulating elements using the DOM
refers to changing the structure, content, attributes, or
styles of HTML elements within a web page. Everyday actions involved in
manipulating elements using the DOM include modifying the text or
HTML contents of elements. Suppose the HTML code has
the following command, you have a paragraph element with
the attribute ID set to my-paragraph. The content of the paragraph
is "This is some text." This JavaScript code selects a paragraph
by ID and changes its text content. The expected output is an HTML paragraph
displaying "This is updated text." You can also alter
the attributes of each element, which can affect their behavior or
appearance. Suppose you have the following HTML code, you have an image element with
an attribute ID set to my-image and an src attribute pointing to
an image file named old-image.jpg. This JavaScript code selects
an image by its ID and changes the src attribute
to load a new image. The expected output is an updated
image displayed on the web page. You can dynamically add new
elements to the page or remove existing ones based on user
interactions or other conditions. Suppose you have the following HTML code.
This code consists of an unordered list with an attribute ID set to my-list,
inside the ul, there are two list items, one with the content item one and
another with the content item two. This JavaScript code selects an unordered
list, creates a new list item, adds text content, and appends it to
the list using the appendChild method. The expected output is an updated
list with three items. You can also set up event listeners on
elements to respond to user interactions. Suppose the HTML has the following code. This JavaScript code adds a click
event listener to a button. When you click the button,
a button clicked alert is displayed. You can change the order of
elements within a parent container, which affects their
display order on the page. Suppose the HTML code has
the following command. This code selects a container div and
reorders the two paragraphs, making the second paragraph
the first child of the div. The expected output is
the first paragraph, followed by the second paragraph. You can also create copies
of existing elements and insert them elsewhere in the document. Suppose the HTML code has the following
command. This code selects a list, clones the first list item, and attaches
the cloned item to the end of the list. The expected output is an updated
list with three identical list items. In this video, you learned that,
accessing the DOM involves obtaining references to
specific HTML elements on a web page. Methods for
accessing elements include getElementById, getElementsByClassName,
getElementsByTagName, and querySelector. Manipulating elements using the DOM
is the process of making changes to the structure, content, attributes, or
styles of HTML elements within a web page. And it involves changing content,
altering attributes, setting up event listeners, changing
order, and creating copies of elements. [MUSIC][MUSIC] Welcome to Introduction to
Browser Object Model (BOM). After watching this video,
you will be able to, define Browser Object Model, BOM,
and identify critical components, explain steps to integrate BOM with HTML,
and differentiate between DOM and BOM. The browser Object model BOM
in JavaScript, is a crucial aspect that provides a structured way
to interact with the web browser. It allows you to control browser behavior,
manipulate the browser window, and access client-specific information. Unlike the document object model (DOM),
which represents the web page's content, the BOM deals with
the browser's environment. Some of the key components of
BOM are as follows, window, document, navigator, screen,
history, and location. Let's learn about each in detail. The Global Window object represents
the browser window or tab, and serves as the root of the BOM. All Global JavaScript objects and
functions are part of the window object. The window object encompasses
various properties and methods. For instance, window.alert (message)
displays a simple alert dialog, window.confirm (message),
shows a confirmation dialog, and window.open (url, name, specs, replace)
opens a new browser window or tab. You can also close the current
window with a window.close, and manipulate the current URL
using the window.location. The window object extends its
functionalities with features like setTimeout, for delayed function
execution and storage options, such as localStorage, and
sessionStorage for client-side data storage. Additionally, window.history provides
access to the browser session's history. While the document object is primarily
part of the document Object model DOM, closely related to the BOM, it represents
the web page within the browser window. The navigator object gives information
about the client's browser, including the browser's name,
version, and supported features. The screen object details the user's
screen, including its dimensions and color depth. The history object represents
the browser's session history, enabling navigation in
the user's browsing history. The location object provides information
about the current URL, and allows manipulation of the URL, facilitating
redirection to other web pages. The browser object model proves
versatile in various scenarios, including user interaction through alerts
and confirmations, window control, navigation between web pages,
accessing client information, and data storage using local storage and
session storage. To integrate BOM methods with HTML,
follow these steps. Begin crafting an HTML document
with the necessary structure, and a script element for
embedding your JavaScript code. Include HTML elements such as buttons,
to trigger BOM methods. Develop a JavaScript file, for example, yourscript.js containing the code for
employing BOM methods. Link this file to your HTML
document using the script tag. Open your HTML file in a web browser
to interact with the buttons, and witness the BOM methods. Clicking the buttons,
triggers the associated BOM methods. In web development,
the document object model (DOM) and browser object model (BOM),
serve distinct purposes. The DOM represents a web
page's structure and content, offering a hierarchical,
easy access and manipulation model. Meanwhile, the BOM provides access to
browser specific features, settings, and behaviors, enabling control over windows,
navigation, and user interactions. The DOM consists of a tree-like structure
of HTML elements, attributes, and text nodes,
representing the web page's content, accessible through the document object. The BOM includes various objects and
features like a window, navigator, screen, history, and location, providing access to browser-specific
information and functionalities. Primarily, the DOM allows dynamic
manipulation of HTML elements, including text, attributes,
styles, and structure. Meanwhile, the BOM goes beyond content,
empowering control over browser features like alerts, windows,
history, and client information. DOM is organized hierarchically and
represents HTML elements, attributes, and text nodes as notes,
forming a structured layout. In contrast, the BOM lacks a hierarchical
structure with loosely related objects offering independent access. Accessing the DOM involves interacting
through the document object, like using document.getElementById
Element ID. For the BOM, direct interaction with
objects occurs through the window object, for example, window.alert,
this is an alert. Lastly, DOM usage includes modifying text
content, adding or removing HTML elements, updating attributes, changing styles,
and handling events within the web page. BOM usage includes opening
new browser windows or tabs, controlling browser history,
displaying alerts, managing client information, and
handling browser-specific tasks. In this video, you learn that,
the browser object mode, or BOM, includes vital components like the window,
document, navigator, screen, history,
and location objects. BOM facilitates user interaction,
window control, navigation, client information access,
and data storage. Integrating BOM methods with HTML,
involves creating an HTML document, a JavaScript file, and
testing in a web browser. The DOM focuses on the structure and
content of web pages, while the BOM deals with browser
specific functionalities. Both DOM and BOM are essential for
building interactive and user friendly web application. [MUSIC][MUSIC] Welcome to Introduction to
Browser Object Model (BOM). After watching this video,
you will be able to, define Browser Object Model, BOM,
and identify critical components, explain steps to integrate BOM with HTML,
and differentiate between DOM and BOM. The browser Object model BOM
in JavaScript, is a crucial aspect that provides a structured way
to interact with the web browser. It allows you to control browser behavior,
manipulate the browser window, and access client-specific information. Unlike the document object model (DOM),
which represents the web page's content, the BOM deals with
the browser's environment. Some of the key components of
BOM are as follows, window, document, navigator, screen,
history, and location. Let's learn about each in detail. The Global Window object represents
the browser window or tab, and serves as the root of the BOM. All Global JavaScript objects and
functions are part of the window object. The window object encompasses
various properties and methods. For instance, window.alert (message)
displays a simple alert dialog, window.confirm (message),
shows a confirmation dialog, and window.open (url, name, specs, replace)
opens a new browser window or tab. You can also close the current
window with a window.close, and manipulate the current URL
using the window.location. The window object extends its
functionalities with features like setTimeout, for delayed function
execution and storage options, such as localStorage, and
sessionStorage for client-side data storage. Additionally, window.history provides
access to the browser session's history. While the document object is primarily
part of the document Object model DOM, closely related to the BOM, it represents
the web page within the browser window. The navigator object gives information
about the client's browser, including the browser's name,
version, and supported features. The screen object details the user's
screen, including its dimensions and color depth. The history object represents
the browser's session history, enabling navigation in
the user's browsing history. The location object provides information
about the current URL, and allows manipulation of the URL, facilitating
redirection to other web pages. The browser object model proves
versatile in various scenarios, including user interaction through alerts
and confirmations, window control, navigation between web pages,
accessing client information, and data storage using local storage and
session storage. To integrate BOM methods with HTML,
follow these steps. Begin crafting an HTML document
with the necessary structure, and a script element for
embedding your JavaScript code. Include HTML elements such as buttons,
to trigger BOM methods. Develop a JavaScript file, for example, yourscript.js containing the code for
employing BOM methods. Link this file to your HTML
document using the script tag. Open your HTML file in a web browser
to interact with the buttons, and witness the BOM methods. Clicking the buttons,
triggers the associated BOM methods. In web development,
the document object model (DOM) and browser object model (BOM),
serve distinct purposes. The DOM represents a web
page's structure and content, offering a hierarchical,
easy access and manipulation model. Meanwhile, the BOM provides access to
browser specific features, settings, and behaviors, enabling control over windows,
navigation, and user interactions. The DOM consists of a tree-like structure
of HTML elements, attributes, and text nodes,
representing the web page's content, accessible through the document object. The BOM includes various objects and
features like a window, navigator, screen, history, and location, providing access to browser-specific
information and functionalities. Primarily, the DOM allows dynamic
manipulation of HTML elements, including text, attributes,
styles, and structure. Meanwhile, the BOM goes beyond content,
empowering control over browser features like alerts, windows,
history, and client information. DOM is organized hierarchically and
represents HTML elements, attributes, and text nodes as notes,
forming a structured layout. In contrast, the BOM lacks a hierarchical
structure with loosely related objects offering independent access. Accessing the DOM involves interacting
through the document object, like using document.getElementById
Element ID. For the BOM, direct interaction with
objects occurs through the window object, for example, window.alert,
this is an alert. Lastly, DOM usage includes modifying text
content, adding or removing HTML elements, updating attributes, changing styles,
and handling events within the web page. BOM usage includes opening
new browser windows or tabs, controlling browser history,
displaying alerts, managing client information, and
handling browser-specific tasks. In this video, you learn that,
the browser object mode, or BOM, includes vital components like the window,
document, navigator, screen, history,
and location objects. BOM facilitates user interaction,
window control, navigation, client information access,
and data storage. Integrating BOM methods with HTML,
involves creating an HTML document, a JavaScript file, and
testing in a web browser. The DOM focuses on the structure and
content of web pages, while the BOM deals with browser
specific functionalities. Both DOM and BOM are essential for
building interactive and user friendly web application. [MUSIC]Welcome to Traversing the DOM. After watching this video, you will be
able to explain the significance of traversing the DOM and identify how DOM
traversal facilitates navigation and manipulation of HTML elements. The process of traversing the DOM or
document object model, involves navigating and manipulating the structure and content
of an HTML document using JavaScript. The DOM represents a web page as
a hierarchical tree of objects, where each HTML element
is a node in the tree. Traversing the DOM allows you to
programmatically access, manipulate, and interact with these nodes. Various methods and
techniques are commonly employed to facilitate a better understanding of
traversing the DOM in JavaScript. These include: navigating parent and
child elements, navigating sibling elements, finding elements within a container, traversing up and
down the DOM tree. Let's explore each in detail. Navigating parent and
child elements within the DOM involves moving up and down the tree-like structure of
an HTML document using JavaScript. This process is crucial for accessing and manipulating relationships
between elements. Several methods and properties are commonly
used for navigating parent and child elements. ParentNode property is used to access
the parent node of an element. It allows movement up one level in the DOM tree to access elements containing or
surrounding the element. For example, you can use element.parentNode
to retrieve the parent element of the current element. ChildNodes property returns a NodeList
containing all child nodes of an element. ChildNodes can include elements,
text nodes, comments, and other types of nodes that are direct
descendants of the element. Individual child nodes are accessed
using their index within the node list. FirstChild and lastChild properties
allow access to the first and last child nodes of an element. These are useful for
accessing the first and last elements or nodes within a parent element. Let's consider the following
HTML structure. Here's how you can use the mentioned properties
to navigate the parent and child elements. In this example, you start by selecting
the parent element with the ID parent and then use the firstChild and lastChild properties to access
the first and last child nodes. Now let's learn about navigating
sibling elements. It involves moving horizontally within the
hierarchical tree structure of an HTML document. This process allows access and manipulation of elements that
share the same parent node. Key methods and properties include:
nextSibling and previousSibling properties allow access to the next and previous
sibling nodes at the same hierarchical level; include various node types such as elements,
text nodes, comments, or other types. FirstChild and lastChild properties allow access to the first and last child nodes of the current element-- different from navigating siblings,
as they go one level deeper into the hierarchical structure. Consider the following HTML structure,
here's how you can use the mentioned properties to navigate the sibling and
child elements. In this example, the code selects the
middle paragraph element using this statement. It then uses the previousSibling
and nextSibling properties to access the previous
and next sibling nodes. The code also used the firstChild and
lastChild properties, which return null in this case because the paragraph does
not have child elements, only text nodes. This demonstrates that sibling navigation
can include various node types, and you should handle them accordingly
based on your specific use case. Finding elements within a container
involves searching for and accessing HTML elements within
a specific parent or container element. This is a common task in web development
when working with a subset of elements within a particular section of a web page. Here are some key methods used for
finding elements within a container. This method allows you to find the first
element that matches the specified CSS selector within a given container. It returns the first matched element or
null if no matching element is found. This is useful when you want to find
a single element within a container that matches a specific criterion. This method returns a NodeList containing
all elements that match the specified CSS selector within a given container. It returns an empty node list if
no matching elements are found. This is useful for finding multiple elements within a container that match a specific criterion. Consider the following HTML structure. Here's how you can use the mentioned methods
to find elements within the container. In this example, you start by selecting the container
element with the ID container. By using this statement, you can then
use the querySelector to find the first element within the container
with the class "myClass", and querySelectorAll to find all elements
within the container with the same class. Lastly, let's learn about traversing
up and down the DOM tree. This involves navigating between parent
and child elements, moving up and down the hierarchy of HTML
elements within a web page. Methods and properties like parentNode,
childNodes, firstChild, and lastChild are essential for
these operations. In this video, you learned that
traversing the DOM allows for programmatic access, manipulation, and interaction
with HTML elements using JavaScript. Navigating parent and
child elements involves moving up and down the tree-like structure
of an HTML document. Navigating sibling elements entails moving
horizontally within the hierarchical tree structure. Finding the elements within
a container involves searching for and accessing HTML elements within
a specific parent or container element. And traversing up and
down the DOM tree is essential for navigating between parent and
child elements. [MUSIC]Welcome to Styling DOM Elements. After watching this video, you will be able to define the concept of styling
in the context of web development
and explain how to use various methods to modify the style
attribute of an element. Styling the DOM elements is crucial for dynamically changing the visual presentation
of HTML elements on your web page using CSS properties and styles
through JavaScript. This process enhances user interactions
and responsiveness, helping to make changes such as altering elements, color, size, position, or visibility in response to user actions
or other events. There are several
methods for styling DOM elements using JavaScript. Here are some common ones:
element.style.property, element.classList,
element.setAttribute, element.styles.cssText, element.style.setProperty, and
element.style.removeProperty. Let's explore each
method in detail. You can directly access and
modify the inline styles of an HTML element using
the style property. This method is beneficial
for dynamically adjusting the appearance of elements based on user
interactions or events. For instance, in this example, you have a button element
with the ID, myButton, and click me text
in the HTML file, you can use the button variable to store the selected
button element. The style property
is then used to manipulate the inline styles
of the button directly. This line sets the
background color of the button to blue. This line sets the
text color to white. This line sets the font
size to 16 pixels. The class list property
facilitates adding, removing, or toggling CSS
classes on an element. This property is
especially useful for applying
predefined styles from CSS classes and enables the toggling of classes in
response to user interactions. This example involves a
div element with the ID, myDiv, and an initial
class active. This div contains the
text 'This is a div.' There is also a
button element with the ID myButton
labeled toggle class. You can use the
classlist.toggle method to alternate between the active and inactive classes on
the div element. This process means that each
time you call the function, it alternates between adding
or removing these classes. An if statement checks if the
active class is present on the div element using the
classlist.contains method. If the class is present, it sets the background
color of the div to green. If it's not present, the code sets the background
color to yellow. The setAttribute method
allows you to set or modify the style attribute
of an element using a string
containing inline CSS. While effective, the
set attribute process replaces the entire style
attribute of an element. This method may be less
suitable when you want to preserve existing styles while making specific
adjustments. In this example, a
paragraph element with the ID, myParagraph has an inline style setting
the text color to red. The set attribute method sets the entire
style attribute to change the text
color to blue and the font size to 18 pixels. The CSS text property
enables setting the entire inline style of an element using
a single string. While convenient for adjusting multiple style properties
simultaneously, it replaces the
existing inline style. For instance, in this example, the paragraph
element with the ID myText is stored in the text
variable for easy access. The style.cssText method sets the text color to green
and font weight to bold. The set property
method allows setting a specific CSS property with
an optional important flag. This flag ensures that
the specified style takes precedence
over other styles applied to the same element. In this example, a
paragraph element with the ID myParagraph is selected and stored in
the paragraph variable. You can use the setProperty
method to set a specific CSS property. In this case, the
color to purple and marks the specified change
with the important parameter. This method ensures
that this style takes precedence over other styles
applied to the same element. Lastly, the remove
property method is useful for selectively removing specific CSS properties from an element's inline style, this method provides
a way to reset or adjust styling on
a granular level. For instance, in this example, a paragraph element with the ID, myParagraph is selected and stored in
the paragraph variable. You can use the remove
property method to selectively remove a
specific CSS property, in this case the font size from the inline styles
of the paragraph. In this video, you learned that styling DOM elements
using JavaScript allows you to dynamically change the visual presentation of HTML elements on your web page, elements.style.property directly modifies
the inline styles of an element by setting
CSS properties and values. Element.classList adds, removes, or
toggles CSS classes on an element using class list. Element.setAttribute
sets or modifies the entire style attribute
of an element with a string containing inline
CSS properties and values, element.style.cssText sets
the entire inline style of an element using
the CSS text property. element.styls.setProperty
sets a specific CSS property. With an optional priority for
an element's inline style. Ensuring it takes precedence
over other styles and element.style.removeProperty removes a specific CSS property from an element's inline style, allowing you to reset or
adjust styling selectively.Welcome to introduction to JSON. After watching this video, you will be able to define JSON and its significance
in data interchange, differentiate between JSON
and objects in programming, and explain how to use JSON
in a JavaScript project. JSON, or JavaScript
object notation is a lightweight data interchange
format that is easy for humans to read and write and easy for machines to
parse and generate. It is a text-based format
used for structuring data in a way that is both human readable and machine readable. JSON is important
for several reasons. JSON is widely used for exchanging data
between a server and a web application or between different parts
of a software system. It serves as a common language
for data communication. For example, when you make an API request to a web service, the response is often
in JSON format. JSON is designed to make it easy for humans to
read and write codes. It uses a simple syntax with
key value pairs and arrays, making it accessible to developers and non
developers alike. This human readability is
valuable for debugging, configuration files, and
manual data editing. JSON is equally easy
for machines to parse, making it a popular choice for data serialization
and deserialization. This means that software
applications can easily convert JSON data into the
internal data structures of the programming
language and vice versa. JSON is not tied to any
specific programming language, which means it can be used in a wide range of
programming environments. It is supported virtually by all modern programming languages through various
libraries and APIs. JSON is simpler than other data interchange
formats like XML. It doesn't have the complexity
of tags and attributes, making it less verbose
and more concise. JSON can be extended to support additional data
types and structures, making it versatile
for various use cases. This is typically
achieved through custom objects or arrays. JSON and objects in programming
are related concepts, but they have some
key differences. JSON is a text based
data interchange format. It represents data as a string, which is a sequence
of characters. JSON is a way to serialize
and transmit data, primarily used for data exchange between systems or for
storing data and files. Whereas an object is a
fundamental data structure that can hold data and methods
to manipulate that data. Objects are typically
used to model real world entities or abstract concepts within
a software application. JSON has a specific syntax and rules that must be followed. It uses key value pairs and is limited to a specific
set of data types, including strings, numbers, Booleans, arrays and
other JSON objects. JSON follows a strict format and keys are enclosed
in double quotes. In programming, objects
are not restricted to a specific syntax
or set of data types. They are a part of the
programming language and can include a wide
variety of data types, such as integers, floats, custom data
structures, and more. JSON is primarily used
for data interchange. It is used to transmit data between a
client and a server, between different parts
of a software system or to store configuration
data in files. Its main purpose
is to facilitate data transfer and
interoperability. While objects in
programming are used to model and manipulate data within the application itself, they represent entities or concepts within the
program's logic and can encapsulate both data and the methods that
operate on that data. Here's an example to
illustrate the difference. In the JSON example, you see a simple data structure
with key value pairs. In the object example, you have a JavaScript
object that not only holds data but also
includes a method, say hello, to perform
a specific action. This method is not part of JSON, it's a feature of the
programming language. Let's now look at
an example of how JSON can be used to
represent a list of books. First, create a JSON file called books.JSON with a list of books. Next, create a
JavaScript project that reads and manipulates
this JSON data. We'll use the fetch API to load the JSON data from the file and then perform some
operations with it. Here's a breakdown of
what the code does. The fetch books
function is defined. This function is responsible for fetching and
processing JSON data. Inside the fetch function, books.JSON is provided as the URL to fetch JSON data from. The fetch function returns
a promise that resolves to the response object representing the response to the request. The dot then method is used to handle the response data
when it becomes available. It receives a callback function
that parses the response as JSON data using
response.JSON. This function also
returns a promise. Another dot then method is used to handle the
parse JSON data. Inside this callback function, the code iterates
over each book in the JSON data using
a for each loop. For each book, it logs
the book's title, author, and publication
year to the console. After logging the
information for each book, it adds a line of hyphens to separate the
entries visually. If an error occurs during the fetch operation
or JSON parsing, the code uses dot catch to handle and log the
error to the console. Finally, the fetch
books function is called to initiate the data
fetching and processing. This is a basic example of how JSON can be used in a
JavaScript project. In this video you learned that JSON or JavaScript Object
Notation is a lightweight, human readable, and machine readable data
interchange format. It is easy for
humans to read and write and easy for machines
to parse and generate. JSON utilizes key value
pairs and arrays, providing simplicity for both developers and
non developers. JSON is a versatile data
format that can be used in various ways to handle structured data in
JavaScript projects.Welcome to Introduction to
Async and Sync Execution. After watching this video, you will be able to define synchronous programming
with examples, explain asynchronous
programming with examples, and differentiate between synchronous and
asynchronous programming. Synchronous programming
in JavaScript refers to the execution of code in a sequential and
blocking manner. In a synchronous program, each operation or task is
executed one after the other, and the program waits
for each task to complete before moving
on to the next one. This means that if one operation takes a long time to execute, it can block the entire
program's execution, making it unresponsive. Here's an example of
synchronous code. In this example, Task 2 will only be executed after
Task 1 is completed, and Task 3 will only be executed after Task
2 is completed. If any of these tasks takes
a long time to complete, it will delay the execution
of subsequent tasks. Let's look at another
example that demonstrates the synchronous nature of
Javascript using functions. This code has three functions: greet, ask question,
and farewell. It also has console
statements to log messages when you call these functions and log
messages sequentially. JavaScript will
execute them one after the other in the order
they appear in the code. Now let's look at
asynchronous programming. Asynchronous programming
in JavaScript is a programming paradigm that allows you to execute code without blocking the
main execution thread. It enables tasks to
run concurrently, making it particularly
useful for handling operations that may
take some time to complete, such as network requests, file I/O, or user interactions. The key concepts
and mechanisms for asynchronous programming
and JavaScript include the following. Callbacks are functions
that are passed as arguments to other functions and are
executed at a later time, typically when an asynchronous
operation completes. They allow you to
specify what should happen after the
asynchronous task is done. Promises are objects
that represent the eventual completion or failure of an
asynchronous operation. They provide a cleaner and
more structured way to work with asynchronous code
compared to callbacks. Introduced in ES2017, ES8, async/await is a more recent way to work with
asynchronous operations. It allows you to write
asynchronous code in a more synchronous-looking
style, making it easier to
read and maintain. JavaScript uses an event loop to manage asynchronous
operations. The event loop
continuously checks the message queue for tasks
that need to be executed, and runs them in the
order they were added. Asynchronous programming
is essential for web applications to remain responsive and handle multiple tasks
simultaneously. For example, when
a web page makes an HTTP request to fetch
data from a server, it doesn't block the entire page while waiting for the response. Instead, the page
can continue to respond to user interactions
while waiting for the data. Here's a basic example using the setTimeout function to illustrate
asynchronous programming. In this example, start and end will be
logged immediately, but delayed message will be logged after a two-second delay, because setTimeout is an
asynchronous operation. This demonstrates how
asynchronous programming allows non-blocking
execution of code. Let's look at another example. In this example, the simulateAsyncOperation
function simulates an asynchronous
operation with a two-second delay
using setTimeout. It takes a callback
function as a parameter. When you run this code, you'll notice that the
async operation and progress message is logged while the asynchronous operation
is being simulated. After the two-second delay, the data is received. Data received and end of
the program are logged. This illustrates how
asynchronous code can execute non-blocking
operations, and handle them
when they complete using callback functions. Here are the differences between synchronous and asynchronous
programming in JavaScript. In synchronous programming, code is executed in
the order it appears, one step at a time,
blocking the main thread. While in asynchronous
programming, code doesn't wait for
a task to complete and can continue to execute
other operations. Synchronous programming blocks
the program's execution while a task is in progress, potentially making
it unresponsive. Whereas asynchronous programming doesn't block the program, it allows other tasks
to run alongside the asynchronous one,
improving responsiveness. Synchronous
programming relies on the natural order
of code execution, where each line follows
the previous one. Asynchronous programming
uses callbacks, promises, or async/await to manage and control the flow of
asynchronous operations. Synchronous programming is
suitable for simple scripts, mathematical
calculations, or tasks that don't involve waiting
for external resources. While asynchronous
programming is ideal for handling I/O operations
like network requests, file reading/writing,
and tasks that require waiting for external events
or user interactions. In this video, you learned that
synchronous programming in JavaScript executes
code sequentially, blocking the main thread while waiting for each
task to complete. It can lead to unresponsiveness, especially for time-consuming
operations. Asynchronous programming
enables task execution without blocking, crucial for operations involving external resources, and asynchronous programming
uses callbacks, promises, and async/await to manage and control the flow
of asynchronous tasks, ensuring a more responsive
user experience.Welcome to Introduction to AJAX. After watching this video, you will be able to define the concept of AJAX and
identify key components, recognize the advantages in
common use cases of AJAX, and identify the best practices
for implementing AJAX. AJAX, short for asynchronous
JavaScript and XML, is a set of web development
techniques used to create dynamic and
responsive web applications. It enables asynchronous
communication between the web browser
and the server, allowing data to be exchanged without requiring a
full page reload. This results in a more seamless and interactive user experience. AJAX emerged in the early 2000s, representing a significant shift in web development paradigms. Its concept was
popularized by the term coined by Jesse James
Garrett in 2005. However, the underlying
technologies and principles of asynchronous communication
existed earlier. AJAX operates asynchronously, meaning it allows the webpage to send and receive data
from the server in the background while the user
interacts with the page. Now let's look at
some AJAX components. JavaScript is the
primary language used to initiate AJAX requests
and handle responses. XMLHttpRequest or XHR object is the core technology enabling communication between the
browser and the server. It's used to send HTTP
requests and handle responses. AJAX was initially associated
with XML for data transfer, but later commonly uses JSON due to its simplicity
and ease of parsing. Let's delve into the details
of how AJAX operates. Typically, an event
like a button click triggers an AJAX request
within a web page. JavaScript code initiates
an XMLHttpRequest object, or uses modern fetch API to send an asynchronous
request to the server. The server processes
the request, performs necessary operations
such as database queries, and generates a response. Upon receiving the response, JavaScript processes the data and updates specific
parts of the web page, often without needing
a full page reload. Now let's look at some
advantages of using AJAX. AJAX facilitates smooth and
dynamic content updates, leading to a more
interactive user interface. By updating only specific
portions of the page, AJAX reduces bandwidth usage and server load, enhancing
performance. Users can continue interacting
with the webpage while data is being fetched or
processed in the background. Here are some of the
common uses of AJAX. You can use AJAX to
load additional content on a page without
reloading the entire page, as seen in infinite scrolling
on social media platforms. It enables sending form data to the server without
refreshing the entire page. AJAX plays a vital role
in enabling features like live chat or stock
market updates without interrupting
user activity. Automatically saving
feature saves user input without requiring
manual submissions. Let's explore some
AJAX best practices. Robust error handling
mechanisms are essential to manage failed
requests or timeouts. Implementing retries
or fallback strategies ensures a smoother
user experience. Cross-site scripting, XSS, and other security
vulnerabilities should be considered
when implementing AJAX. Implementing proper
authentication and encryption measures is crucial. Understanding and addressing cross-origin restrictions
by using cores, cross-origin resource
sharing headers, when making requests
to different domains. Now let's explore why AJAX continues to play a crucial role in modern web development. Many modern frameworks
such as React, Angular, and Vue.js, offer built in
functionalities that utilize AJAX principles for efficient data handling
and rendering. The fetch API introduced in
modern browsers provides a more streamlined and promise-based approach to
making HTTP requests, offering an alternative
to XMLHttpRequest. AJAX has diverse applications
and impactful use cases. The seamless experience of infinite scrolling,
live updates, and comments that load without
page refreshes is made possible through AJAX,
enhancing the user experience. AJAX powers dynamic product
listings, filtering, and shopping cart updates, providing users with a seamless and efficient
shopping experience. Collaborative platforms like Google Docs or Trello
leverage AJAX for real-time updates and
collaborative editing, seamlessly enhancing
workflow without disruption. In this video, you
learned that AJAX, or asynchronous JavaScript and XML, revolutionizes
web development by facilitating dynamic and
responsive applications. Key components include
JavaScript for initiating requests, the XMLHttpRequest, XHR object for communication, and a shift from XML to
JSON for data transfer. Advantages of using AJAX include enhanced
user interfaces, reduced server load, and
uninterrupted user interactions. Common uses range
from dynamic content loading to real-time updates
and auto-saving features. Its applications are
diverse from enhancing social media experiences to powering e-commerce
interactions, and facilitating real-time
collaboration.Welcome to HTTP Requests
with XMLHttpRequest (XHR). After watching this video, you will be able to explain the purpose and functionality of XMLHttpRequest and recall
the practical application of XMLHttpRequest
using an example. XMLHttpRequest (XHR) is a JavaScript API that enables communication between a
web browser and a server. It allows for making
HTTP requests to retrieve data
from a server or send data to a server in the background without
reloading the entire web page. XMLHttpRequest is at
the core of AJAX, asynchronous JavaScript and XML, a technique for creating more responsive and
dynamic web applications. Let's look at some
of the features and functionalities
of XMLHttpRequest. You can create an XHR
object by following a step-by-step guide explaining the associated
properties and method. You can use XMLHttpRequest
to fetch data from external APIs or
servers managing different data formats
such as JSON or XML. With XHR, you can utilize event listeners
to handle responses, including response codes
like success or failure. Additionally, you
can dynamically update web page content
based on the received data. You can effectively
manage errors and timeouts with XMLHttpRequest. You can use XMLHttpRequest
to retrieve data securely, addressing concerns such
as cross-origin request. Now let's explore creating
an XMLHttpRequest object, making a get request and
sending the requested data. To initiate an HTTP request, developers create an instance of the XMLHttpRequest object. This object exposes
various properties and methods that facilitate
configuring and sending requests, handling responses,
and managing errors. Next, the open method
sets up the request specifying the HTTP
method get and the URL. After configuring the request, you can invoke the
send method to send the request to
the specified URL. Let's look at an example
demonstrating XMLHttpRequests, asynchronous data fetching,
and explore each section. This part of the code represents the basic HTML structure of a web page featuring a button,
loadUsersBtn, for users to trigger
the AJAX request and an empty div userList designated for displaying
fetched user data. The code then adds
an event listener to the load user's button. When clicked, this
listener triggers the function to initiate
Ajax functionality. You then install an
XMLHttpRequest object XHR, inside the event listener and
configure the request using the open method to execute a get request to a mock server. The code then sets
the onload event to manage the response
upon receipt. Error handling addresses
potential issues that may arise during the
AJAX request process. Finally, you can dispatch the request using
the send method. The displayUsers function takes the received array of users and dynamically
generates a list of their names within
an unordered list. It updates the content of the userListDiv by
attaching the created list. This example demonstrates using XMLHttpRequest to
fetch data from a server asynchronously
and update specific web page parts
based on the received data, achieving dynamic
content updates without reloading
the entire page. Let's now understand the step by step explanation of the code. Clicking the load user's button triggers the event listener. You then create an
XMLHttpRequest object to make an asynchronous Get Request to a URL that serves
mock user data. The onload event handles the response if the
request is successful (status code 200-399), it processes
the received JSON data, converts it into
an array of users, and calls display
users to render the user list on
the page. Onerror handles errors during the
request or network issues. The display user's function dynamically generates
HTML elements to display each user's name within
a list and updates the content of the userListDiv
with this information. In this video, you learned
that XMLHttpRequest, or XHR, is a JavaScript API facilitating communication between web browsers
and servers. It enables asynchronous
HTTP requests, allowing data retrieval or submission without reloading
the entire web page. XMR is the core
component of AJAX, or asynchronous JavaScript and XML, enhancing web
application interactivity.[MUSIC] Welcome to Understanding Promises for
API. After watching this video, you will be able to define callbacks and
promises in programming, explain the three states of promises,
and explain creating promises using the promise constructor
with resolve and reject functions. A callback is a function passed as
an argument to another function and executed later or
after a specific event occurs. JavaScript commonly uses
callbacks to handle asynchronous operations such as event handling,
timers, and user interactions. Let's consider a realistic example where
you want to get user information and recent posts from an API and
then display the user's information and posts on a web page. In this example, getUserInfo and getUserPosts are two functions that
simulate making asynchronous API requests. They accept a userId as a parameter and
a callback function. Inside these functions are setTimeout
calls, which simulate delays to mimic the time it takes to fetch
user information and user posts. GetUserInfo simulates fetching user
information and passes the information to the callback function after a delay
of 1000 milliseconds or 1 second. GetUserPosts simulates fetching user posts
and passes the posts to the callback function after a delay of 1500
milliseconds, or 1.5 seconds. The code structure then demonstrates
a callback scenario where you have deeply nested callbacks where you first
call getUserInfo with a userId of 1. When the user information is received,
it invokes the callback function, which logs the user
information to the console. Within this callback function, you then
call getUserPosts with the same userId. Once the user posts are received,
the callback function for getUserPosts logs the user
post to the console. Now that we know what a callback
function is and how it works, let's understand promises. Promises are a powerful and flexible way to work with asynchronous
operations in JavaScript. They represent a value that may not be
available yet, but will be in the future. You can use promises for
tasks like fetching data from a server, reading files, or performing other
operations that may take time to complete. Promises have three states. Pending is the initial state
when you create the promise and the asynchronous operation is in progress. Fulfilled is when the asynchronous
operation is completed and the result is available. Rejected is the state
when the asynchronous operation encounters an error or
is unsuccessful. You can create promises using the promise
constructor, providing a method to handle the results once the asynchronous
operation is complete. Here's the basic syntax of a promise, you create a new promise using
the promise constructor. The promise constructor takes a function
as an argument with two parameters, resolve and reject. Calling a resolve function indicates completion
of the asynchronous operation, and it provides the result of that operation. A reject function, when called, indicates
that an error has occurred during the asynchronous operation, and
it provides the error information. Inside the promise constructor,
you typically perform an asynchronous operation, for
example making an HTTP request reading a file that will eventually
resolve or reject the promise. After creating the promise,
you can use the then method to specify what should happen when the promise
is resolved or rejected. Then, the method takes two
callback functions as arguments. The first callback function
executes when the promise resolves, it receives the result provided
by the resolve function. The second callback function executes
when the promise is rejected and receives the error information
the reject function provides. Now let's explore an example
of a callback using promises. GetUserInfo and getUserPosts make
a userId parameter and return a promise. In getUserInfo, a promise is formed
with a one-second delay simulating user information retrieval, the promise
resolves with user data, a user object. Similarly, getUserPosts creates
another promise with a 1.5 second delay to mimic fetching user posts. After the delay, an array of
post data resolves the promise. The code then uses promise chaining
to execute these asynchronous operations sequentially in a clear and
organized way. You initiate the process by calling
getUserInfo 1, which returns a promise for user information retrieval using dot then you
handle the resolved user information. In the first dot then block, you log
the userInfo to the console and return the result of getUserPosts 1. The returned promise from getUserPosts 1,
represents fetching user posts. Another dot then block handles
the resolved userposts. In the second dot then block, you log the user posts to
the console, simulating data processing. For error handling, the dot catch block
at the end of the promise chain logs any errors that may occur during execution. Lastly, let's look at some
advantages of using promises. The key advantage of using promises is
that they allow you to handle asynchronous operations linearly without
needing deeply nested callbacks. This code structure makes understanding
and maintaining asynchronous code easier. Which is partially important in real
world scenarios involving API requests, data processing, and
updating the user interface, UI. In this video, you learned that
callbacks are functions passed as arguments executed later or
after specific events. They are commonly used in JavaScript for asynchronous operations like
event handling and timers. Promises offer a powerful way to
handle asynchronous operations. Promises have three states pending or
initial fulfilled or successful completion,
rejected or encountered error. And you can create promises
using the promise constructor, taking resolve, and reject functions. [MUSIC]Welcome to Understanding
the fetch() API. After watching this video, you will be able to define the Fetch API and
its characteristics, explain the use of
promises in the Fetch API, and recall common
HTTP request methods. The Fetch API is
a modern built-in JavaScript interface for
making network requests, typically used for fetching
resources from the web, such as data from a
server or an API. It provides a more flexible
and powerful way to work with HTTP requests
than older techniques, like XML HTTP request. Here are some of the
characteristics of the Fetch API. The Fetch API promises cleaner and more
structured handling of asynchronous operations. It's straightforward
and easy to use syntax, facilitating the setup, sending, and handling
of requests. Lastly, the Fetch API supports a range of HTTP request methods, including GET, POST, PUT, DELETE, and others. Let's look at the basic
syntax of the Fetch API. Now let's break down the key
components of the Fetch API. This is the resources
URL you want to fetch. It can be an absolute
or relative URL. You can use an optional object
to customize the request. It can include various
properties like method, headers, mode,
credentials, and more. You use the dot then method on the promise returned by Fetch
to handle the response. Inside this block, you can
process the response data, check the response status, and perform any necessary
actions based on the response. You can use the dot catch
method on the promise to catch and handle any errors that might occur
during the fetch, such as network issues
or server errors. A Fetch API provides a way to make various HTTP requests, including GET, POST, PUT, DELETE, and more. You can use these
methods to perform various types of operations
on web resources. Let's explore some
common HTTP methods used with the fetch API. You use the GET method to retrieve data from the
specified resource. It should only retrieve data and not modify it on the server. It is the most
common HTTP method for fetching information
from the server. Meanwhile, you can use
the POST method to submit data that meets processing to a
specified resource. You can use it to
create new records on the server or submit data
for further processing. The PUT method updates or replaces data at the
specified resource. You can use it to update
existing records on the server. Meanwhile, the DELETE method requests the removal of a
resource from the server. It deletes records or resources. You can use the PATCH method to apply partial modifications
to a resource. It updates parts of a resource while keeping the
rest unchanged. Meanwhile, the OPTIONS method describes the
communication options for the target resource. It is often used to
check what methods and headers are allowed for
a particular resource. Now let's look at an example
of using the Fetch API to make a GET request to an API
and handle the response. In this example, you define the API URL variable with the URL of the API endpoint
you want to fetch data from. In this case, it's
set to this URL. The Fetch function initiates an HTTP GET request to
the specified API URL. It returns a promise
that resolves to a response object representing the response from the server. The code uses the
dot then method on the promise returned by Fetch
to handle the response. Here it calls response to JSON to parse the
response body as JSON. This method also
returns a promise. In the next dot then block, you receive the parsed JSON
data as the data argument. This is where you
can process and use the data retrieved
from the API. The catch block at the end of the promise chain
catches and handles any errors that may occur during the fetch and logs
it to the console. In this video, you learned
that the Fetch API is a modern Java script
interface that offers a flexible and powerful approach to fetching resources
from the web. It utilizes promises for cleaner and structured handling of asynchronous operations. It is an easy-to-use syntax
that simplifies the set up, sending, and handling
of requests. The Fetch API supports
various HTTP request methods, including GET, POST, PUT, DELETE, PATCH, and OPTIONS.Welcome to
Introduction to Axios. After watching this video, you will be able to define Axios and its role in
making HTTP requests, identify the essential
components of an Axios request, and differentiate between
Axios and Fetch API. Axios is a popular
JavaScript library used to make HTTP requests
from the browser. It provides a simple and
consistent API for making asynchronous HTTP requests to interact with RESTful APIs
or other web services. Developers commonly Axios in front-end and Node.js
applications. Axios provides a clean
and consistent syntax for making HTTP requests. Let's look at the
basic structure of an Axios request and
the key components. Method refers to the HTTP method for the request like get, post, put, or delete. URL specifies the URL of the resource you want to
request from the server. Header is an object that shows you to specify
custom headers for the request such as authorization or
content type headers. Data represents the request data typically used for post, put, and more. Depending on the content type, it can be an object or a string. The dot then method handles the successful
response from the server. It receives a response object that contains the response data, headers and status information. Dot catch
method handles errors. It receives an error
object with details such as a network time
out or server error. Let's take an example of
making a GET request using Axios to retrieve data from
a fictitious JSON-based API. In this example, the
code starts by importing the Axios library using
the required statement. This is required to use Axios
in a Node.js environment. You can include Axios in a browser-based environment
through a script tag. You don't need this
important statement. The API URL variable is defined storing the URL of the API
endpoint you want to request. In this example, it's
set to this URL. The library requests
the specified API URL. Axios provides the request
configuration as an object, including the method URL
and additional settings. Axios returns a promise
that resolves with the response object representing the response from the server. The dot then method handles
the successful response. The dot catch block handles errors that may occur
during the request. If there is an
error, you receive the error object as an argument, and handle the
error accordingly. Fetch and Axios are both popular JavaScript libraries for
making HTTP requests, but they have some
key differences in terms of usage and features. Fetch is a built-in web
API in modern browsers. It provides a basic
interface for making HTTP requests and is available
natively in the browser. It returns promises for
asynchronous operations. Meanwhile, Axios is
a separate library you must include
in your project. It provides a more convenient
and high-level API for making HTTP requests. Axios also returns promises
for asynchronous operations, but is not built
into the browser, so you must include
it explicitly. Modern browsers
widely support fetch, but may not be available in older browsers
without a polyfill. Conversely, Axios
is designed to work consistently across
different browsers and has better compatibility, including support
for older versions of Internet Explorer. Fetch requires more
manual configuration of headers and request options, and you need to call
additional methods to parse the response body. Axios offers a more intuitive
and higher-level API for request configuration
and response handling. It automatically
parses the response based on the
specified data type. Fetch requires
explicitly checking the response status and throwing errors for non-okay statuses. Error handling can be more complex and may
involve custom logic. Meanwhile, Axios
automatically handles response status
checks and treats non-okay responses as errors. It provides a more streamlined
error-handling process. Fetch does not have
built-in support for request cancellation, which can be important when you need to cancel ongoing requests. Whereas Axios provides
built-in support for request cancellation
using cancel tokens. Fetch does not have built-in
interceptor support, so you need to handle
these tasks separately. Axios allows you to
define requests and response interceptors for
tasks like authentication, logging, or global
error handling. Fetch requires you to apply these settings to each
request manually. Meanwhile, Axios
allows you to set global defaults and
configurations for headers, base URLs, and other
request parameters, making it easier to maintain consistency in your API calls. In this video, you
learned that Axios is a widely used JavaScript library for making HTTP requests. It offers a clean and
consistent API for asynchronous interactions with RESTful APIs or web services. Axios provides a structured
syntax for defining requests, including the HTTP
method, URL, headers, and optional data, and Axios streamlines the process
of making HTTP requests, providing a user
friendly interface and additional
features that enhance the overall
development experience compared to native
solutions like Fetch.